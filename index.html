
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="xxinso">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/11/06/webpack-之十二（创建自己的loader）/" title="webpack之十二创建自己的loader" itemprop="url">webpack之十二创建自己的loader</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-11-06T08:35:45.000Z" itemprop="datePublished"> Published 2018-11-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="loader是一个函数"><a href="#loader是一个函数" class="headerlink" title="loader是一个函数"></a>loader是一个函数</h2><hr>
<p>先来看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">"marked"</span>);</span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">"loader-utils"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 loaderUtils 来获取 loader 的配置项</span></span><br><span class="line">    <span class="comment">// this 是构建运行时的一些上下文信息</span></span><br><span class="line">    <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.cacheable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把配置项直接传递给 marked</span></span><br><span class="line">    marked.setOptions(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 marked 处理 markdown 字符串，然后返回</span></span><br><span class="line">    <span class="keyword">return</span> marked(markdown);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是markdown-loader的实现代码，笔者添加了一些代码说明，看上去很简单。</p>
<p>markdown-loader 本身仅仅只是一个函数，接收模块代码的内容，然后返回代码内容转化后的结果。webpack loader 的本质就是这样的一个函数。</p>
<p>上述代码中用到的 loader-utils 是 webpack 官方提供的一个工具库，提供 loader 处理时需要用到的一些工具方法，例如用来解析上下文 loader 配置项的 <code>getOptions</code>。关于这个工具库的内容和功能不是特别复杂，就不展开了，直接参考这个库的官方文档即可。</p>
<p>代码中还用到了 marked，marked 是一个用于解析 Markdown 的类库，可以把 Markdown 转为 HTML，markdown-loader 的核心功能就是用它来实现的。基本上，webpack loader 都是基于一个实现核心功能的类库来开发的，例如 sass-loader 是基于 node-sass 实现的，等等。</p>
<h2 id="开始一个loader的开发"><a href="#开始一个loader的开发" class="headerlink" title="开始一个loader的开发"></a>开始一个loader的开发</h2><hr>
<p>我们可以在 webpack 配置中直接使用路径来指定使用本地的 loader，或者在 loader 路径解析中加入本地开发 loader 的目录。看看配置例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader: path.resolve(<span class="string">'./loader/index.js'</span>), <span class="comment">// 使用本地的 ./loader/index.js 作为 loader</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 resolveLoader 中添加本地开发的 loaders 存放路径</span></span><br><span class="line"><span class="comment">// 如果你同时需要开发多个 loader，那么这个方式会更加适合你</span></span><br><span class="line">resolveLoader: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    <span class="string">'node_modules'</span>,</span><br><span class="line">    path.resolver(__dirname, <span class="string">'loaders'</span>)</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>如果你熟悉 Node 的话，也可以使用 npm link 的方式来开发和调试，关于这个方式，可以参考 npm 的官方文档 npm-link。</p>
<h2 id="复杂一点的情况"><a href="#复杂一点的情况" class="headerlink" title="复杂一点的情况"></a>复杂一点的情况</h2><hr>
<p>当我们选择上述任意一种方法，并且做好相应的准备后，我们就可以开始写 loader 的代码了，然后通过执行 webpack 构建来查看 loader 是否正常工作。</p>
<p>上面已经提到，loader 是一个函数，接收代码内容，然后返回处理结果，有一些 loader 的实现基本上就是这么简单，但是有时候会遇见相对复杂一点的情况。</p>
<p>首先loader函数接受的参数是有三个的：<code>content,map,meta</code>。<code>content</code>是模块内容，但是不仅限于字符串，也可以是buffer，例如一些图片或者字体等文件。<code>map</code>则是sourcemap对象，<code>meta</code>是其他的一些元数据。loader函数单纯返回一个值，这个值是当成content去处理，但如果你需要返回sourcemap对象或者meta数据，甚至抛出一个loader异常给webpack时，你需要使用<code>this.callback(err, content, map, meta)</code>来传递数据。</p>
<p>我们日常使用webpack，有时候会把多个loader串起来一起使用，最常见的莫过于css-loader和style-loader了。当我们配置<code>use: [&#39;bar-loader&#39;, &#39;foo-loader&#39;]</code>时，laoder是以相反的顺序执行的，即先跑foo-loader，再跑bar-loader。这一部分内容配置loader 的小节中有提及，这里再以开发 loader 的角度稍稍强调下，搬运官网的一段说明：</p>
<ul>
<li>最后的 loader 最早调用，传入原始的资源内容（可能是代码，也可能是二进制文件，用 buffer 处理）</li>
<li>第一个 loader 最后调用，期望返回是 JS 代码和 sourcemap 对象（可选）</li>
<li>中间的 loader 执行时，传入的是上一个 loader 执行的结果</li>
</ul>
<p>虽然有多个 loader 时遵循这样的执行顺序，但对于大多数单个 loader 来说无须感知这一点，只负责好处理接受的内容就好。</p>
<p>还有一个场景是loader中的异步处理。有一些loader在执行古城中可能依赖于外部I/O的结果，导致它必须使异步的方式来处理，这个使用需要在loader执行使用<code>this.asyn（）</code>来标识该loader是异步的，然后使用<code>this.callback</code>来返回loader处理结果。例子可以参考官方文档：<code>异步loader</code></p>
<h2 id="Pitching-loader"><a href="#Pitching-loader" class="headerlink" title="Pitching loader"></a>Pitching loader</h2><hr>
<p>我们可以使用<code>pitch</code>来跳过loader的处理，<code>pitch</code>方法时loader额外实现的一个函数，看下官方文档中的一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content, <span class="keyword">this</span>.data.value); <span class="comment">// pitch 的缘故，这里的 data.value 为 42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在 loader 函数上的 pitch 函数</span></span><br><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span>(<span class="params">remainingRequest, precedingRequest, data</span>) </span>&#123;</span><br><span class="line">  data.value = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以简单的把<code>pitch</code>理解为loader的前置钩子，它可以使用<code>this.data</code>来传递数据，然后具备跳过剩余loader的能力。</p>
<p>在一个<code>use</code>配置中所有的loader执行前会执行对应的<code>pitch</code>,并且于loader执行顺序时相反的，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use: [</span><br><span class="line">  <span class="string">'bar-loader'</span>,</span><br><span class="line">  <span class="string">'foo-loader'</span>,</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 执行 bar-loader 的 pitch</span></span><br><span class="line"><span class="comment">// 执行 foo-loader 的 pitch</span></span><br><span class="line"><span class="comment">// bar-loader</span></span><br><span class="line"><span class="comment">// foo-loader</span></span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其中，当pith中返回了结果，那么执行顺序会回过头来，跳掉剩余的loader，如`</span>bar-loader<span class="string">`的pitch返回结果了，那么执行只剩下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// 执行 bar-loader 的 pitch</span></span><br></pre></td></tr></table></figure>
<p>可能只有比较少的 loader 会用到 pitch 这个功能，但有的时候考虑实现 loader 功能需求时把 pitch 纳入范围会有不一样的灵感，它可以让你更加灵活地去定义 loader 的执行。</p>
<p>这里的简单介绍仅做抛砖引玉之用，详细的学习和了解可以参考官方文档 Pitching loader 或者 bundler-loader 源码 bundler-loader。</p>
<h2 id="loader-上下文"><a href="#loader-上下文" class="headerlink" title="loader 上下文"></a>loader 上下文</h2><hr>
<p>上述提及的一些代码会使用到<code>this</code>,即loader函数的额上下文，包括<code>this.callback</code>和<code>this.data</code>等，可以这样简单地理解：  <code>this</code>是作为loader运行时数据和方法补充载体。</p>
<p>loader上下文有很多运行时的信息，如<code>this.context</code>和<code>this.request</code>等等，而最重要的方法莫过于<code>this.callback</code>和<code>this.async</code>,官方文档有比较详细的说明：loader API。当你在开发 loader 过程中发现需要某些运行时数据时，就可以查阅 loader API，基本上该有的数据都有了。</p>
<h2 id="一个好的loader时什么样的"><a href="#一个好的loader时什么样的" class="headerlink" title="一个好的loader时什么样的"></a>一个好的loader时什么样的</h2><hr>
<p>loader 作为 webpack 解析资源的一种扩展方式，最重要的是足够简单易用，专注于处理自己那一块的内容，便于维护，可以和其他多个 loader 协同来处理更加复杂的情况。</p>
<p>官方对于 loader 的使用和开发有一些准则，一个好的 loader 应该符合官方的这些定义：Loader 准则。</p>
<p>社区中有相当多的优秀 loader 可以作为参考，例如刚开始提及的 markdown-loader，相当地简单易用。由于 loader 的这种准则和特性，大部分的 loader 源码都相对容易解读，便于我们学习参考。</p>
<p>作为一个 loader 开发者，你应该尽可能遵循这些准则（有些特殊情况需要特殊处理），这样会让你开发出质量更高、更易维护和使用的 webpack loader。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/创建自己的loader/">创建自己的loader</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/30/webpack-之十一（进一步控制JS大小）/" title="优化前端资源加载 3 - 进一步控制 JS 大小" itemprop="url">优化前端资源加载 3 - 进一步控制 JS 大小</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-10-30T01:10:59.000Z" itemprop="datePublished"> Published 2018-10-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>前面已经介绍了一些优化资源加载的方法，这一小节是这个主题的最后一部分，内容更为深入，主要介绍如何把我们的 JS 代码文件变得更小。</p>
<h2 id="按需加载模块"><a href="#按需加载模块" class="headerlink" title="按需加载模块"></a>按需加载模块</h2><hr>
<p>前面讲述了如何把大的代码文件进行拆分，抽离出多个页面共享的部分,但是当你的Web应用是单个页面，并且极其复杂的时候，你会发现一些代码并不是每一个用户都需要涌动的。你可能希望将这一部分代码抽离出去，仅当用户真正需要用到时才加载，这个时候就需要用到webpack提供的一个优化功能———— 按需加载代码模块</p>
<p>在webpck的构建环境中，要按需加载代码模块很简单，尊许ES标准的动态加载语法<code>dynamic-import</code>来编写代码即可，webpack回自动处理使用该语法编写的模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象</span></span><br><span class="line"><span class="comment">// 注释 webpackChunkName: "lodash" 可以用于指定 chunk 的名称，在输出文件时有用</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="string">'lodash'</span>).then(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(_.lash([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 打印 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意一下，如果你使用了<code>Babel</code>的话，还需要<code>Syntax Dynamic Import</code>这个Babel插件来处理<code>import()</code>这种语法。</p>
<p>由于动态加载代码模块的语法依赖于promise，对于低版本的浏览器，需要添加promise的polyfill才能使用。</p>
<p>如上的代码，webpack构建时回自动把lodash某块分离出来，并且在代码内部实现动态加载lodash的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以<code>import</code>方法是返回一个promise来获取动态加载的内容某块内容。</p>
<p><code>import</code>后面注释<code>webpackChunkName:lodash</code>用于告知webpack所要动态加载某块的名称。我们在webpack配置中添加一个<code>output.chunkFilename</code>的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].[hash:8].js'</span>,</span><br><span class="line">  chunkFilename: <span class="string">'[name].[hash:8].js'</span> <span class="comment">// 指定分离出来的代码文件的名称</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>如果没有添加注释 <code>webpackChunkName: &quot;lodash&quot;</code> 以及 <code>output.chunkFilename</code> 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别。</p>
<h2 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree shaking"></a>Tree shaking</h2><hr>
<p>Tree shaking 这个术语起源于 ES2015 模块打包工具 <code>rollup</code>，依赖于 ES2015 模块系统中的<code>静态结构特性</code>，可以移除 JavaScript 上下文中的未引用代码，删掉用不着的代码，能够有效减少 JS 代码文件的大小。拿官方文档的例子来说明一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; cube &#125; <span class="keyword">from</span> <span class="string">'./math.js'</span> <span class="comment">// 在这里只是引用了 cube 这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>如果整个项目代码只是上述的两个文件，那么很明显，<code>square</code>这个方式是未被引用的代码，是可以删掉的。在webapck中，只有启动了JS代码压缩功能（即使用uglify）时，会做Tree shaking的优化。webpack 4.x需要指定mode为production，而webpack 3.x的话需要配置UglifyJsPlugin。启动了之后，构建出来的结果就会移除<code>square</code>的那一部分代码了。</p>
<p>如果你在项目中使用了Babel的话，要把Babel解析某班语法功能关掉，在<code>.babelrc</code>配置中增加<code>&quot;modules&quot;: false</code>这个配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [[<span class="string">"env"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以把 <code>import/export</code> 的这一部分模块语法交由 webpack 处理，否则没法使用 Tree shaking 的优化。</p>
<p>有的时候你启用了 Tree shaking 功能，但是发现好像并没有什么用，例如这样一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/component.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (&#123; name &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (&#123; model &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model</span><br><span class="line">  &#125;</span><br><span class="line">  getModel () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Apple &#125; <span class="keyword">from</span> <span class="string">'./components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appleModel = <span class="keyword">new</span> Apple(&#123;</span><br><span class="line">  model: <span class="string">'X'</span></span><br><span class="line">&#125;).getModel()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(appleModel)</span><br></pre></td></tr></table></figure>
<h2 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h2><hr>
<p>这是 webpack 4.x 才具备的特性，暂时官方还没有比较全面的介绍文档，笔者从 webpack 的 examples 里找到一个东西：side-effects/README.md。</p>
<p>我们拿<code>lodash</code>举个例子，有些同学可能对<code>lodash</code>已经蛮熟悉了，他是一个工具库，提供了大量的对字符串、数组、对象等常见数据类型的处理函数，但是有的时候我们只是使用了其中的几个函数，全部函数的实现都打包到我们的应用代码中其实很浪费。</p>
<p>webpack的sideEffects可以帮助我们解决这个问题。现在lodash<code>ES版本</code>在<code>package.json</code>文件中已经有<code>sideEffects: false</code>这个声明了，当某个模块的 package.json 文件中有了这个声明之后，webpack 会认为这个模块没有任何副作用，只是单纯用来对外暴露模块使用，那么在打包的时候就会做一些额外的处理。</p>
<p>例如你这么使用 <code>lodash</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; forEach, includes &#125; <span class="keyword">from</span> <span class="string">'lodash-es'</span></span><br><span class="line"></span><br><span class="line">forEach([<span class="number">1</span>, <span class="number">2</span>], (item) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(includes([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>由于 lodash-es 这个模块的 <code>package.json</code> 文件有 <code>sideEffects: false</code> 的声明，所以 webpack 会将上述的代码转换为以下的代码去处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> forEach &#125; <span class="keyword">from</span> <span class="string">'lodash-es/forEach'</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> includes &#125; <span class="keyword">from</span> <span class="string">'lodash-es/includes'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他代码...</span></span><br></pre></td></tr></table></figure>
<p>最终 webpack 不会把 lodash-es 所有的代码内容打包进来，只是打包了你用到的那两个方法，这便是 sideEffects 的作用。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/优化前端资源加载-3-进一步控制-JS-大小/">优化前端资源加载 3 - 进一步控制 JS 大小</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/24/webpack-之十（分离代码文件）/" title="优化前端资源加载 2 - 分离代码文件" itemprop="url">优化前端资源加载 2 - 分离代码文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-10-24T08:49:53.000Z" itemprop="datePublished"> Published 2018-10-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="分离代码文件"><a href="#分离代码文件" class="headerlink" title="分离代码文件"></a>分离代码文件</h2><hr>
<p>关于分离CSS文件这个主题，在webpack中使用<code>extract-text-webpack-plugin</code>插件即可。</p>
<p>先解释一下为什么要把CSS文件分离出来，而不是直接一起打包在JS中。最主要的原因是我们希望更好地利用缓存。</p>
<p>假设我们原本页面的静态资源打包成一个JS文件，加载页面时虽然只需要加载一个JS文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的JS文件。在有些情况下，我们只是单独修改了样式，这样重新加载整个JS文件，相当不划算。</p>
<p>还有一种情况我们有多个页面，他们都可以公用一部分样式（这是常见的，CSSReset、基础组件样式等基本都是可以跨页面通用），如果每个页面都单独打包一个JS文件，那么每次访问页面都会重复加载原本可以共享的那些CSS代码。如果分离开来，第二个页面就有了CSS缓存，访问速度自然回加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相当可观。</p>
<p>因此当我们考虑更好地利用缓存来加速静态资源访问时，会尝试把一些公共资源单独分离开来，利用缓存加速，以避免重复的加载。除了公共的 CSS 文件或者图片资源等，当我们的 JS 代码文件过大的时候，也可以用代码文件拆分的办法来进行优化。</p>
<p>那么，如何使用 webpack 来把代码中公共使用的部分分离成为独立的文件呢？由于 webpack 4.x 和 webpack 3.x 在代码分离这一块的内容差别比较大，因而我们分别都介绍一下。</p>
<p>3.x 以前的版本是使用 CommonsChunkPlugin 来做代码分离的，而 webpack 4.x 则是把相关的功能包到了 optimize.splitChunks 中，直接使用该配置就可以实现代码分离。</p>
<p>我们先介绍在 webpack 4.x 中如何使用这个配置来实现代码分离。</p>
<h2 id="webpck4-x的optimization"><a href="#webpck4-x的optimization" class="headerlink" title="webpck4.x的optimization"></a>webpck4.x的optimization</h2><hr>
<p>webpack的作者直接推荐这样简单地配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">"all"</span>, <span class="comment">// 所有的 chunks 代码公共的部分分离出来成为一个单独的文件</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 commons.js 需要在入口代码之前。下面是个简单的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"commons.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"entry.bundle.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你使用了html-webpack-plugin，那么对应需要的JS文件都会在HTML文件中正确引用，不用担心，如果没有使用，那么你需要从<code>status</code>的<code>entrypoints</code>属性来获取入口文件应该引用哪些JS文件，可以参考<code>Node API</code>了解如何从status中获取信息，或者开发一个plugin来处理正确引用JS文件这个问题。</p>
<p>之前我们提到拆分文件是为了更好的利用缓存，分离公共类库是为了让更多的页面利用缓存，从而减少代码量的下载，同时，也有代码变更时可以利用缓存减少下载代码量的好处。从这个角度出发，笔者建议讲公共使用的类库显示地为公共部分，而不是webpack自己去处理判断，因为公共的第三方类库通常升级频率相对低一些，着样可以避免因公共chunk的频繁而导致缓存失效。</p>
<p>显示配置共享类库可以这么操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">"react"</span>, <span class="string">"lodash"</span>, <span class="string">"angular"</span>, ...], <span class="comment">// 指定公共使用的第三方类库</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          test: <span class="string">"vendor"</span>,</span><br><span class="line">          name: <span class="string">"vendor"</span>, <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/react|angluar|lodash/</span>, <span class="comment">// 直接使用 test 来做路径匹配</span></span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          name: <span class="string">"vendor"</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          test: path.resolve(__dirname, <span class="string">"node_modules"</span>) <span class="comment">// 路径在 node_modules 目录下的都作为公共部分</span></span><br><span class="line">          name: <span class="string">"vendor"</span>, <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 <code>test</code> 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">webpack 3.x 的 CommonsChunkPlugin</span><br><span class="line">------</span><br><span class="line">下面我们简单介绍一下在 webpack 3.x 中如何配置代码分离。webpack 3.x 以下的版本需要用到 webpack 自身提供的 CommonsChunkPlugin 插件。我们先来看一个最简单的例子：</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &quot;commons&quot;, // 公共使用的 chunk 的名称</span><br><span class="line">      filename: &quot;commons.js&quot;, // 公共 chunk 的生成文件名</span><br><span class="line">      minChunks: 3, // 公共的部分必须被 3 个 chunk 共享</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>chunk 在这里是构建的主干，可以简单理解为一个入口对应一个 chunk。</p>
<p>以上插件配置在构建后会生成一个 commons.js 文件，该文件就是代码中的公共部分。上面的配置中  <code>minChunks</code> 字段为 3，该字段的意思是当一个模块被 3 个以上的 chunk 依赖时，这个模块就会被划分到 <code>commons</code> chunk 中去。单从这个配置的角度上讲，这种方式并没有 4.x 的 <code>chunks: &quot;all&quot;</code> 那么方便。</p>
<p>CommonChunkPlugin也是显式配置共享类库的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'react'</span>, <span class="string">'react-redux'</span>], <span class="comment">// 指定公共使用的第三方类库</span></span><br><span class="line">    app: <span class="string">'./src/entry'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor'</span> <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">      filename: <span class="string">"vendor.js"</span>, </span><br><span class="line">      minChunks: <span class="literal">Infinity</span>, <span class="comment">// 这个配置会让 webpack 不再自动抽离公共模块</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述配置会生成一个名为 vendor.js 的共享代码文件，里面包含了 React 和 React-Redux 库的代码，可以提供给多个不同的入口代码使用。这里的 <code>minChunks</code> 字段的配置，我们使用了 <code>Infinity</code>，可以理解为 webpack 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的 chunk 依赖的模块会和 React、React-Redux 一同打包进 vendor，这样就失去显式指定的意义了。</p>
<p><code>minChunks</code>其实还可以是一个函数，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minChunks: <span class="function">(<span class="params"><span class="built_in">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>, count);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 <code>module</code>，以及已经被作为公共模块的数量 <code>count</code>，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minChunks: <span class="function">(<span class="params"><span class="built_in">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.context &amp;&amp; <span class="built_in">module</span>.context.includes(<span class="string">"node_modules"</span>); </span><br><span class="line">  <span class="comment">// node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, "node_modules")</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>更多使用 CommonsChunkPlugin 的配置参考官方文档 commons-chunk-plugin。</p>
<p>而关于 webpack 4.x 的 splitChunks 配置，笔者写这一部分的时候官方文档还没有更新出来，上述配置预估可以满足大部分项目的需求，更加详细的内容还请等待官方文档更新后查阅。 </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/优化前端资源加载-2-分离代码文件/">优化前端资源加载 2 - 分离代码文件</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/23/webpack-之九 （前端资源加载）/" title="优化前端资源加载 1 - 图片加载优化和代码压缩" itemprop="url">优化前端资源加载 1 - 图片加载优化和代码压缩</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-09-23T08:48:00.000Z" itemprop="datePublished"> Published 2018-09-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们总是希望浏览器在加载页面时用的时间越短越好，所以构建出来的文件应该越少越小越好，一来减少浏览器需要发起请求的数量，二来减少下载静态资源的时间。</p>
<p>其实 webpack 把多个代码文件打包成几个必需的静态资源，已经很大程度减少了静态资源请求数量了，接下来我们来介绍下如何使用 webpack 实现更多的前端资源加载的优化需求。</p>
<h2 id="CSS-Script"><a href="#CSS-Script" class="headerlink" title="##CSS Script"></a>##CSS Script</h2><p><code>CSS Script</code>技术时前端领域一种常见减少图片请求数的优化方式，这里不做详细的介绍。</p>
<blockquote>
<p>在了解webpack配置之前，需要先明白CSS Script的原理。</p>
</blockquote>
<p>如果你是用的webpack 3.x版本，需要CSS Script的话，可以使用<code>webpack-spritesmith</code> 或者 <code>sprite-webpack-plugin</code>。</p>
<p>我们以 webpack-spritesmith 为例，先安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-spritesmith --save-dev</span><br></pre></td></tr></table></figure>
<p>在webpack的配置中应用插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    <span class="comment">// ... 这里需要有处理图片的 loader，如 file-loader</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    <span class="string">'node_modules'</span>, </span><br><span class="line">    <span class="string">'spritesmith-generated'</span>, <span class="comment">// webpack-spritesmith 生成所需文件的目录</span></span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> SpritesmithPlugin(&#123;</span><br><span class="line">    src: &#123;</span><br><span class="line">      cwd: path.resolve(__dirname, <span class="string">'src/ico'</span>), <span class="comment">// 多个图片所在的目录</span></span><br><span class="line">      glob: <span class="string">'*.png'</span> <span class="comment">// 匹配图片的路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    target: &#123;</span><br><span class="line">      <span class="comment">// 生成最终图片的路径</span></span><br><span class="line">      image: path.resolve(__dirname, <span class="string">'src/spritesmith-generated/sprite.png'</span>), </span><br><span class="line">      <span class="comment">// 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子</span></span><br><span class="line">      css: path.resolve(__dirname, <span class="string">'src/spritesmith-generated/sprite.styl'</span>), </span><br><span class="line">    &#125;,</span><br><span class="line">    apiOptions: &#123;</span><br><span class="line">      cssImageRef: <span class="string">"~sprite.png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>在你需要的样式中引入<code>sprite。styl</code>后调用需要的mixins即可</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">'~sprite.styl'</span></span><br><span class="line"></span><br><span class="line">.close-button</span><br><span class="line">    sprite(<span class="variable">$close</span>)</span><br><span class="line">.open-button</span><br><span class="line">    sprite(<span class="variable">$open</span>)</span><br></pre></td></tr></table></figure>
<p>更多的 webpack-spritesmith 配置可以参考：Config of webpack-spritesmith。</p>
<p>遗憾的是，上面提到的两个plugin还没有更新到webpack4.x, 你需要配合postcss和postcss-sprites相关构建</p>
<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="##图片压缩"></a>##图片压缩</h2><p>在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了。</p>
<p>用file-loader来处理图片文件，在此基础上，我们再添加一个<code>image-webpack-loader</code>来压缩图片文件。简单的配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/.*\.(gif|png|jpe?g|svg|webp)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123; <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">                progressive: <span class="literal">true</span>,</span><br><span class="line">                quality: <span class="number">65</span></span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123; <span class="comment">// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">                enabled: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123; <span class="comment">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">                quality: <span class="string">'65-90'</span>,</span><br><span class="line">                speed: <span class="number">4</span></span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123; <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">                interlaced: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123; <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">                quality: <span class="number">75</span></span><br><span class="line">              &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>image-webpack-loader的压缩是使用<code>imagemin</code>提供的一系列图片库来处理的，如果需要进一步了解详细的配置，可以查看对应类库的官方文档<code>usage of image-webpck-loader</code>。</p>
<h2 id="使用DataURL"><a href="#使用DataURL" class="headerlink" title="使用DataURL"></a>使用DataURL</h2><hr>
<p>有的时候我们项目中会有一些很小的图片，因为某些缘故并不想使用CSS Script的方式来处理（譬如小图片不多，因此引入CSS Script感觉麻烦），那么我们可以在webpack中使用url-loader来处理这些很小的图片。</p>
<p><code>url-loader</code>和<code>file-loader</code>的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置时，url-loader会将其转换为一个base64的DataURL，配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span>, <span class="comment">// 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多关于url-loader的配置可以参考官方文档<code>url-loader</code>,一般情况下使用<code>limit</code>即可。</p>
<h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="##代码压缩"></a>##代码压缩</h2><p>除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。</p>
<p>对于 HTML 文件，html-webpack-plugin 插件可以帮助我们生成需要的 HTML 并对其进行压缩：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'assets/index.html'</span>, <span class="comment">// 配置文件模板</span></span><br><span class="line">      minify: &#123; <span class="comment">// 压缩 HTML 的配置</span></span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩 HTML 中出现的 CSS 代码</span></span><br><span class="line">        minifyJS: <span class="literal">true</span> <span class="comment">// 压缩 HTML 中出现的 JS 代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，使用<code>minify</code>字段配置就可以使用HTML压缩，这个插件是使用<code>html-minifier</code>来实现HTML代码压缩的<code>minify</code>下的配置项直接透传给html-minifier，配置产考html-minifier文档即可。</p>
<p>对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 css-loader，也提供了压缩 CSS 代码的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">        ],</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              minimize: <span class="literal">true</span>, <span class="comment">// 使用 css 的压缩功能</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 css-loader 的选项中配置 minimize 字段为 true 来使用 CSS 压缩代码的功能。css-loader 是使用 cssnano 来压缩代码的，minimize 字段也可以配置为一个对象，来将相关配置传递给 cssnano。更多详细内容请参考 cssnano 官方文档。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/优化前端资源加载-1-图片加载优化和代码压缩/">优化前端资源加载 1 - 图片加载优化和代码压缩</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/01/webpack-之七 （开发和生产环境的构建配置差异）/" title="开发和生产环境的构建配置差异" itemprop="url">开发和生产环境的构建配置差异</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-08-31T17:15:54.000Z" itemprop="datePublished"> Published 2018-09-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 debug 信息，包含 sourcemap 文件；另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 debug 信息，静态文件不包括 sourcemap 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 mock 等工作。</p>
<p>webpack4.x版本引入了mode的概念，在运行webpack时需要指定使用production或development两个mode其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。</p>
<p>当你指定使用production mode时，默认会启用各种性能优化的功能，包括构建结果优化以及webpack运行性优化，而如果是development mode的话，则会开启debug工具，运行时打印详细的错误信息，以及更加快速的增量编译构建。关于这两个 mode 的更详细区别，可以查阅 webpack 作者的这篇文章：<code>webpack 4: mode and optimization</code>。</p>
<p>虽然webpack的mode参数已经给我们带来了很方便的环境差异化配置，但是针对一些项目的情况，例如使用css-loader或者url-loader等，不同环境传入loader的配置也不一样，而mode病没有帮组我们做这些事情，因此有些配置还是需要手动区分环境后来进行调整。</p>
<h2 id="在配置文件中区分mode"><a href="#在配置文件中区分mode" class="headerlink" title="在配置文件中区分mode"></a>在配置文件中区分mode</h2><hr>
<p>之前我们的配置文件都是直接对外暴露一个JS对象，这种方式暂时没有办法获取到webpack的mode参数，我们需要更换一种方式来处理配置。根据官方文档<code>多种配置类型</code>，配置文件可以对外暴露一个函数，因此我们可以这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 使用 argv 来获取 mode 参数的值</span></span><br><span class="line">    minimizer: argv.mode === <span class="string">'production'</span> ? [</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123; <span class="comment">/* 你自己的配置 */</span> &#125;), </span><br><span class="line">      <span class="comment">// 仅在我们要自定义压缩配置时才需要这么做</span></span><br><span class="line">      <span class="comment">// mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin</span></span><br><span class="line">    ] : [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样获取mode之后，我们就能区分不同的构建环境，然后根据不同环境再对特殊的loader或plugin做额外的配置就可以了。</p>
<p>以上是webpck 4.x的做法，由于有了mode参数，区分就变的简答了。不过在当前业界还是使用webpck3.x版本居多，这里我们就简单介绍一下3.x如何区分环境。</p>
<p>webpack的运行环境是Node.js,我们可以通过Node.js提供的机制给要运行的webpack程序传递环境变量，来控制不同环境下的构建行为。例如，我们在npm的<code>script</code>字段添加一个用于生产环境的构建命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span>:&#123;</span><br><span class="line">     <span class="attr">"build"</span>: <span class="string">"NODE_ENV=production webpack"</span>,</span><br><span class="line">    <span class="attr">"develop"</span>: <span class="string">"NODE_ENV=development webpack-dev-server"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>webpack.config.js</code>文件可以通过<code>process.env.NODE_ENV</code>来过去命令传入的环境变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="comment">// 生产环境需要做的事情，如使用代码压缩插件等</span></span><br><span class="line">  config.plugins.push(<span class="keyword">new</span> UglifyJsPlugin())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure>
<h2 id="运行时的环境变量"><a href="#运行时的环境变量" class="headerlink" title="运行时的环境变量"></a>运行时的环境变量</h2><hr>
<p>我们使用webpack时传递的mode参数，是可以在我们的应用代码运行是，通过<code>process.env.NODE_EVN</code>这个变量来获取的。这样方便我们在运行是判断当前执行的构建环境，使用最多的场景莫过于控制是否打印debug信息。</p>
<p>下面这个简单的例子，在应用开发的代码中实现一个简单的console打印封装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span> &amp;&amp; <span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，以上是webpack4.x的做法，下面介绍一下3.x版本应该如何实现。这里需要用DefinePlugin插件，它可以帮助我们在构建是给运行时定义变量，那么我们只要在前面webpack3.x版本区分构建环境例子的基础上，再使用DefinePlugin添加环境变量即可影响运行时的代码。</p>
<p>在webpack的配置中添加DefinePlugin插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// webpack 的配置</span></span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="comment">// webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的</span></span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见的环境差异配置"><a href="#常见的环境差异配置" class="headerlink" title="常见的环境差异配置"></a>常见的环境差异配置</h2><hr>
<p>前面提及的使用环境变量的方式可以让我们在不同的构建环境中完成不同的构建需求，这里列举一下常见的webpack构建差异配置：</p>
<ul>
<li>生产环境需要分离CSS成单独的文件，以便多个页面课共享同一个CSS文件</li>
<li>生产环境需要压缩HTML/CSS/JS代码</li>
<li>生产环境需要压缩图片</li>
<li>生产环境需要生成sourcemap文件</li>
<li>开发环境需要打印debug信息</li>
<li>开发环境需要live reload或者hot reload的功能</li>
</ul>
<p>以上是常见的环境需求差异，可能更复杂的项目中会有更多的构建需求（如划分静态域名等），但是我们都可以通过判断环境变量来实现这些有环境差异的构建需求。</p>
<p>以上是常见的环境需求差异，可能更加复杂的项目我们会有更多的构建需求（如划分静态域名等），但是我们都可以通过判断环境变量来实现这些有环境差异的构建需求。</p>
<p>webpack4.x的mode已经提供了上述配置的大部分功能，mode为production时默认使用JS压缩代码，而mode为developement时默认启用hot reload，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的loader和pugin做区分配置就可以了。</p>
<p>webapck 3.x版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要使用一个新的项目，建议使用webpack4.x版本。</p>
<h2 id="拆分配置"><a href="#拆分配置" class="headerlink" title="拆分配置"></a>拆分配置</h2><hr>
<p>前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个webpack的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以吧webapck的配置按照不同环境拆分成多个文件，运行是直接根据环境变量加载对应的配置即可。基本可以划分如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* webapck.base.js:基础部分，即多个文件中的共享配置</span><br><span class="line">* webpack.development.js: 开发环境中使用的配置</span><br><span class="line">* webpack.production.js:生产环境中使用的配置</span><br><span class="line">* webpack.test.js 测试环境中使用的配置</span><br></pre></td></tr></table></figure>
<p>一些复杂的项目可能会有更多配置。这里介绍一下如何处理这样的配置拆分。</p>
<p>首先我们要明白，对于webpack的配置，其实是对外暴露一个JS对象，所以对于这个对象，我们都可以用JS代码来修改它，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以修改这个 config 来调整配置，例如添加一个新的插件</span></span><br><span class="line">config.plugins.push(<span class="keyword">new</span> YourPlugin());</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<p>因此，只要有一个工具能够智能地合并多个配置对象，我们就可以轻松的拆分webapck配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给webpack使用。这个工具就是<code>webpack-merge</code>。</p>
<p>我们webpack配置基础部分，即webpack.base.js应该大致是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'...'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里是一个简单的例子，后面介绍 API 时会用到</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">        use: [<span class="string">'babel'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后webpack.development.js需要添加loader或plugin，这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'...'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里是一个简单的例子，后面介绍 API 时会用到</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">        use: [<span class="string">'babel'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后webpack.development.js需要添加loader或plugin，就可以使用webpack-merge的API，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; smart &#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = smart(base, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理</span></span><br><span class="line">      <span class="comment">// 和上述 base 配置合并后，这里会是 &#123; test: /\.js$/, use: ['babel', 'coffee'] &#125;</span></span><br><span class="line">      <span class="comment">// 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'coffee'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// plugins 这里的数组会和 base 中的 plugins 数组进行合并</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可见webppack-marge提供的<code>smart</code>方法，可以帮助我们更加轻松地处理loader配置的合并。webpack-merge还有其他的API可以用于自定义合并行为，这里就不详细介绍了，需要更深入了解的同学可以直接查阅官方文档<code>webpack-merge</code>。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/开发和生产环境的构建配置差异/">开发和生产环境的构建配置差异</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/03/webpack-之五 （使用plugin）/" title="webpack-之五" itemprop="url">webpack-之五</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-08-03T10:01:33.000Z" itemprop="datePublished"> Published 2018-08-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>webpack 中的 plugin 大多都提供额外的能力，它们在 webpack 中的配置都只是把插件实例添加到 <code>plugins</code> 字段的数组中。不过由于需要提供不同的功能，不同的插件本身的配置比较多样化。</p>
<p>社区中有很多 webpack 插件可供使用，而优秀的插件基本上都提供了详细的使用说明文档。更多的插件可以在这里查找：plugins in awesome-webpack。</p>
<p>下面通过介绍几个常用的插件来了解使用方法</p>
<h2 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h2><hr>
<p>DefinePlugin 是 webpack 内置的插件，可以使用 <code>webpack.DefinePlugin</code> 直接获取。</p>
<p>这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 webpack 的配置中去指定，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      PRODUCTION: <span class="built_in">JSON</span>.stringify(<span class="literal">true</span>), <span class="comment">// const PRODUCTION = true</span></span><br><span class="line">      VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">'5fa3b9'</span>), <span class="comment">// const VERSION = '5fa3b9'</span></span><br><span class="line">      BROWSER_SUPPORTS_HTML5: <span class="literal">true</span>, <span class="comment">// const BROWSER_SUPPORTS_HTML5 = 'true'</span></span><br><span class="line">      TWO: <span class="string">'1+1'</span>, <span class="comment">// const TWO = 1 + 1,</span></span><br><span class="line">      CONSTANTS: &#123;</span><br><span class="line">        APP_VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">'1.1.2'</span>) <span class="comment">// const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Running App version "</span> + VERSION);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!BROWSER_SUPPORTS_HTML5) <span class="built_in">require</span>(<span class="string">"html5shiv"</span>);</span><br></pre></td></tr></table></figure>
<p>上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。</p>
<ul>
<li>如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 <code>&quot;1+1&quot;</code>，最后的结果是 <code>2</code></li>
<li>如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 <code>true</code>，最后的结果是 <code>&#39;true&#39;</code></li>
<li>如果配置的是一个对象字面量，那么该对象的所有 key 会以同样的方式去定义</li>
</ul>
<p>这样我们就可以理解为什么要使用 JSON.stringify() 了，因为 JSON.stringify(true) 的结果是 ‘true’，JSON.stringify(“5fa3b9”) 的结果是 “5fa3b9”。</p>
<p>社区中关于 DefinePlugin 使用得最多的方式是定义环境变量，例如 PRODUCTION = true 或者 <strong>DEV</strong> = true 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。</p>
<blockquote>
<p>建议使用 process.env.NODE_ENV: … 的方式来定义 process.env.NODE_ENV，而不是使用 process: { env: { NODE_ENV: … } } 的方式，因为这样会覆盖掉 process 这个对象，可能会对其他代码造成影响。</p>
</blockquote>
<h2 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h2><hr>
<p>这个插件看名字就知道它有什么作用，没错，就是用来复制文件的。</p>
<p>我们一般会把开发的所有源码和资源文件放在 src/ 目录下，构建的时候产出一个 build/ 目录，通常会直接拿 build 中的所有文件来发布。有些文件没经过 webpack 处理，但是我们希望它们也能出现在 build 目录下，这时就可以使用 CopyWebpackPlugin 来处理了。</p>
<p>我么来看看如何配置这个插件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123; <span class="attr">from</span>: <span class="string">'src/file.txt'</span>, <span class="attr">to</span>: <span class="string">'build/file.txt'</span>, &#125;, <span class="comment">// 顾名思义，from 配置来源，to 配置目标路径</span></span><br><span class="line">      &#123; <span class="attr">from</span>: <span class="string">'src/*.ico'</span>, <span class="attr">to</span>: <span class="string">'build/*.ico'</span> &#125;, <span class="comment">// 配置项可以使用 glob</span></span><br><span class="line">      <span class="comment">// 可以配置很多项复制规则</span></span><br><span class="line">    ]),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>glob 用法可以参考 glob-primer。</p>
</blockquote>
<p>上述的配置日常应用已经足够，跟多的配置内容可以参考copy-webpack-plugin。</p>
<h2 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h2><hr>
<p>我们用它来把依赖的 CSS 分离出来成为单独的文件。这里再看一下使用 extract-text-webpack-plugin 的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123; </span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;), </span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'index.css'</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述的配置中，我们使用了 index.css 作为单独分离出来的文件名，但有的时候构建入口不止一个，extract-text-webpack-plugin 会为每一个入口创建单独分离的文件，因此最好这样配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>这样确保在使用多个构建入口时，生成不同名称的文件。</p>
<p> extract-text-webpack-plugin是蛮常用的插件，并且它的使用方式比较特别，除了在 <code>plugins</code> 字段添加插件实例之外，还需要调整 loader 对应的配置。</p>
<p> 在这里要强调的是，在 webpack 中，loader 和 plugin 的区分是很清楚的，针对文件模块转换要做的使用 loader，而其他干涉构建内容的可以使用 plugin。 ExtractTextWebpackPlugin 既提供了 plugin，也提供了 extract 方法来获取对应需要的 loader。</p>
<h2 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h2><hr>
<p>ProvidePlugin 也是一个 webpack 内置的插件，我们可以直接使用 <code>webpack.ProvidePlugin</code> 来获取。</p>
<p>该组件用于引用某些模块作为应用运行时的变量，从而不必每次都用 require 或者 import，其用法相对简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  identifier: <span class="string">'module'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  identifier: [<span class="string">'module'</span>, <span class="string">'property'</span>], <span class="comment">// 即引用 module 下的 property，类似 import &#123; property &#125; from 'module'</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在你的代码中，当 <code>identifier</code> 被当作未赋值的变量时，module 就会被自动加载了，而 <code>identifier</code> 这个变量即 module 对外暴露的内容。</p>
<p>注意，如果是 ES 的 <code>default export</code>，那么你需要指定模块的 default 属性：<code>identifier: [&#39;module&#39;, &#39;default&#39;],</code>。</p>
<p>更多使用例子可以查看官方文档 ProvidePlugin。</p>
<h2 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h2><hr>
<p>IgnorePlugin 和 ProvidePlugin 一样，也是一个 webpack 内置的插件，可以直接使用 <code>webpack.IgnorePlugin</code> 来获取。</p>
<p>这个插件用于忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去。例如我们使用 moment.js，直接引用后，里边有大量的 i18n 的代码，导致最后打包出来的文件比较大，而实际场景并不需要这些 i18n 的代码，这时我们可以使用 IgnorePlugin 来忽略掉这些代码文件，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IgnorePlugin 配置的参数有两个，第一个是匹配引入模块路径的正则表达式，第二个是匹配模块的对应上下文，即所在目录名。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/使用Plugin/">使用Plugin</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/27/webpack-之十四（内部工作流程）/" title="内部工作流程" itemprop="url">内部工作流程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-07-26T17:13:22.000Z" itemprop="datePublished"> Published 2018-07-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>了解 webpack 整个基础工作流程，有助于我们解决日常使用 webpack 时遇到的一些问题，也有助于我们更好地理解 webpack loader 和 plugin 的使用。</p>
<p>抛开复杂的loader和plugin机制，webpack本质上就是一个JS ModuleBundler，用于将多个代码某块进行打包，所以我们先撇开webpack错综复杂的整体实现，来看一下一个相对简单的 JS Module Bunlder 的基础工作流程是怎么样的，在了解了 bundler 如何工作的基础上，再进一步去整理 webpack 整个流程，将 loader 和 plugin 的机制弄明白。</p>
<blockquote>
<p>以下内容将 module bundler 简称为 bundler。</p>
</blockquote>
<h2 id="bundler的基础流程"><a href="#bundler的基础流程" class="headerlink" title="bundler的基础流程"></a>bundler的基础流程</h2><hr>
<p>首先，bundler 从一个构建入口出发，解析代码，分析出代码模块依赖关系，然后将依赖的代码模块组合在一起，在 JavaScript bundler 中，还需要提供一些胶水代码让多个代码模块可以协同工作，相互引用。下边会举一些简单的例子来说明一下这几个关键的部分是怎么工作的。</p>
<p>首先是解析代码，分析依赖关系，对于 <code>ES6 Module</code> 以及 <code>CommonJS Modules</code> 语法定义的模块，例如这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'./bar.js'</span>; <span class="comment">// 依赖 ./bar.js 模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">'./foo.js'</span>); <span class="comment">// 依赖 ./foo.js 模块</span></span><br></pre></td></tr></table></figure>
<p>bundler 需要从这个入口代码（第一段）中解析出依赖 bar.js，然后再读取 bar.js 这个代码文件，解析出依赖 foo.js 代码文件，继续解析其依赖，递归下去，直至没有更多的依赖模块，最终形成一颗模块依赖树。</p>
<p>如果 foo.js 文件没有依赖其他的模块的话，那么这个简单例子的依赖树也就相对简单：<code>entry.js -&gt; bar.js -&gt; foo.js</code>，当然，日常开发中遇见的一般都是相当复杂的代码模块依赖关系。</p>
<p>分析出依赖关系后，bunlder 需要将依赖关系中涉及的所有文件组合到一起，但由于依赖代码的执行是有先后顺序以及会引用模块内部不同的内容，不能简单地将代码拼接到一起。webpack 会利用 JavaScript Function 的特性提供一些代码来将各个模块整合到一起，即是将每一个模块包装成一个 JS Function，提供一个引用依赖模块的方法，如下面例子中的 <strong>webpack</strong>require__，这样做，既可以避免变量相互干扰，又能够有效控制执行顺序，简单的代码例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别将各个依赖模块的代码用 modules 的方式组织起来打包成一个文件</span></span><br><span class="line"><span class="comment">// entry.js</span></span><br><span class="line">modules[<span class="string">'./entry.js'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; bar &#125; = __webpack__require__(<span class="string">'./bar.js'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.js</span></span><br><span class="line">modules[<span class="string">'./bar.js'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> foo = __webpack__require__(<span class="string">'./foo.js'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.js</span></span><br><span class="line">modules[<span class="string">'./foo.js'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经执行的代码模块结果会保存在这里</span></span><br><span class="line"><span class="keyword">const</span> installedModules = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack__require__</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="comment">// 如果 installedModules 中有就直接获取</span></span><br><span class="line">  <span class="comment">// 没有的话从 modules 中获取 function 然后执行，将结果缓存在 installedModules 中然后返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这只是webpack的实现的简单方式，<code>rollup</code>有另外的实现方式，并且笔者个人觉得 rollup 的实现方式比 webpack 要更加优秀一些，rollup 可以让你构建出来的代码量更少一点，有兴趣的同学可以看看这个文章：<a href="https://link.juejin.im/?target=https%3A%2F%2Fmedium.com%2Fwebpack%2Fwebpack-and-rollup-the-same-but-different-a41ad427058c" target="_blank" rel="noopener">Webpack and Rollup: the same but different</a>，也可以使用 rollup 来构建一个简单的例子，看看结果是什么样子的。</p>
<p>我们在介绍bundler的基础流程时，把各个部分的细节都简化了，这有利于我们从整体角度看清楚整个轮廓，至于某一部分的实现，例如解析代码依赖，某块依赖关系管理，胶水代码生成等，深入细节的话会比较复杂，这里不再作相关的展开</p>
<h2 id="webpack的结构"><a href="#webpack的结构" class="headerlink" title="webpack的结构"></a>webpack的结构</h2><hr>
<p>webpack 需要强大的扩展性，尤其是插件实现这一块，webpack 利用了 tapable 这个库（其实也是 webpack 作者开发的库）来协助实现对于整个构建流程各个步骤的控制。</p>
<p>关于这个库更多的使用内容可以去查看官方的文档：tapable，使用上并不算十分复杂，最主要的功能就是用来添加各种各样的钩子方法（即 Hook）。</p>
<p>webpack 基于 tapable 定义了主要构建流程后，使用 tapable 这个库添加了各种各样的钩子方法来将 webpack 扩展至功能十分丰富，同时对外提供了相对强大的扩展性，即 plugin 的机制。</p>
<p>在这个基础上，我们来了解一下 webpack 工作的主要流程和其中几个重要的概念。</p>
<ul>
<li>Compiler webpack的运行入口，实例化时定义webpack构建主要流程，同事创建构建使用的核心对象complilation</li>
<li>Complilation, 有Compiler实例化，存储构建过程中各个流程使用到的数据，用于控制这些数据的变化 </li>
<li>Chunk，即用于表示chunk的类，对于构建时需要的chunk对象由Complication创建后保存管理。</li>
<li>Module，用于表示某块的类，衍生出很多子类用于处理不同的情况，关于代码模块的所有的信息都会在Module实例中，例如<code>dependencies</code>记录代码模块的依赖等。</li>
<li>Parser，其中相对复杂的一个部分，基于<code>acron</code>来分析AST语法树，解析出代码某块的依赖</li>
<li>Dependency,解析时用于保存代码模块的对应依赖的对象</li>
<li>Template，生成最中代码要使用的代码模版，像上述提到的胶水代码就是用对应的Template来生成。</li>
</ul>
<blockquote>
<p>官方对于 Compiler 和 Compilation 的定义是：<br>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。<br>compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键步骤的回调，以供插件做自定义处理时选择使用。</p>
</blockquote>
<p>上述时webpack源码实现中比较重要的几个部分，webpack运行的大概工作流程是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建 Compiler -&gt; </span><br><span class="line">调用 compiler.run 开始构建 -&gt;</span><br><span class="line">创建 Compilation -&gt; </span><br><span class="line">基于配置开始创建 Chunk -&gt; </span><br><span class="line">使用 Parser 从 Chunk 开始解析依赖 -&gt; </span><br><span class="line">使用 Module 和 Dependency 管理代码模块相互关系 -&gt; </span><br><span class="line">使用 Template 基于 Compilation 的数据生成结果代码</span><br></pre></td></tr></table></figure>
<p>上述只是笔者理解中的大概流程，细节相对复杂，一方面时技术实现的细节有一定的复杂度，另一方面，深入介绍的话，篇幅会很长，并且效果不理想，当我们还到了要去实现具体功能的时候，无需关注那么多具体的细节，只需要站在更高的层面去分析整体的流程。</p>
<p>有兴趣探究某一部分实现细节的同学，可以查阅webpack源码，从wenpack基础流入手：<code>Compiler Hooks</code></p>
<blockquote>
<p>这里提供的时4.x版本的源码master分支的连接地址，webpack的源码相对难懂，如果是想要学习 bundler 的整个工作流程，可以考虑看阅读 rollup 的源码，可读性相对会好很多。</p>
</blockquote>
<h2 id="从远吗中探索webpack"><a href="#从远吗中探索webpack" class="headerlink" title="从远吗中探索webpack"></a>从远吗中探索webpack</h2><hr>
<p>webpack主要的候检处理方法都在<code>Complilation</code>中,我们要了解loader和plugin的机制，就要深入<code>Compliation</code>这一部分的内容。</p>
<p>Complilation的实现时比较复杂的，<code>lib/Compilation.js</code> 单个文件就近有2000行之多，我们挑关键的几部分来介绍一下。</p>
<h3 id="addEntry和-addModuleChain"><a href="#addEntry和-addModuleChain" class="headerlink" title="addEntry和_addModuleChain"></a>addEntry和_addModuleChain</h3><p><code>addEntry</code>这个方法顾名思义，用于把配置的入口加入到构建任务中去，当解析好webpack配置，准备好构建时，便会执行<code>addEntry</code>,而<code>addEntry</code>会调用<code>_addModuleChain</code>来为入口文件（入口文件这个时候等同于第一个依赖）创建一个对用的<code>Module</code>实例。</p>
<p><code>_addModuleChain</code>方法回根据入口文件这第一个依赖类型创建一个<code>moduleFactory</code>,然后再使用这个<code>moduleFactory</code>给入口文件创建一个<code>Module</code>实例，这个<code>Module</code>实例用来管理后续这个入口构建相关数据信息，</p>
<p>我们介绍<code>addEntry</code>主要是为了寻找整个构建的起点，让这一切有迹可循，后续的深入可以从这个点出发。</p>
<h3 id="buildModule"><a href="#buildModule" class="headerlink" title="buildModule"></a>buildModule</h3><p>当一个Module实例被创建后，比较重要的一步时执行<code>compilation.buildModule</code>这个方法，这个方法主要回调用<code>module</code>实力需要的一些东西，对我们梳理流程来说，这里边最重要的部分就是调用自身的runLoader方法。</p>
<p><code>runLoader</code>这个方法是webpack依赖这个类库实现的：<code>loader-runner</code>,这个方法也比较容易理解，就是执行对应的loader，将代码的源内容一一交由指定的loader处理之后，再把处理的结果保存起来。</p>
<p>我们之前介绍过，webpack的loader就是转换器，loader就是在这个时候发挥作用的，至于loader执行的细节，有兴趣深入的同学可以去了解<code>loader-runner</code>的实现。</p>
<p>上述提到的<code>Module</code>实例的<code>build</code>方法在执行完对应的loader，处理完模块代码自身的转换后，还有相当重要的一步是调用 Parser 的实例来解析自身依赖的模块，解析后的结果存放在<code>module.dependencies</code>中，首先保存的是依赖的路径，后续会经由<code>compilation.processModuleDependencies</code>方法，再来处理各个依赖模块，递归地去建立整个依赖关系树。</p>
<h3 id="Compilation的钩子"><a href="#Compilation的钩子" class="headerlink" title="Compilation的钩子"></a>Compilation的钩子</h3><p>我们前边提到了 webpack 会使用 tapable 给整个构建流程中的各个步骤定义钩子，用于注册事件，然后在特定的步骤执行时触发相应的事件，注册的事件函数便可以调整构建时的上下文数据，或者做额外的处理工作，这就是 webpack 的 plugin 机制。</p>
<p>在webpack执行入口处<code>lib\webpack.js</code>有这么一段代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.plugins &amp;&amp; <span class="built_in">Array</span>.isArray(options.plugins)) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">		plugin.apply(compiler); <span class="comment">// 调用每一个 plugin 的 apply 方法，把 compiler 实例传递过去</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 plugin 的 <code>apply</code> 方法就是用来给 <code>compiler</code> 实例注册事件钩子函数的，而 <code>compiler</code> 的一些事件钩子中可以获得 <code>compilation</code> 实例的引用，通过引用又可以给 compilation 实例注册事件函数，以此类推，便可以将 plugin 的能力覆盖到整个 webpack 构建过程。</p>
<p>而关于这些事件函数的名称和定义可以查看官方的文档：compiler 的事件钩子 和 compilation 的事件钩子。</p>
<h3 id="产出构建结果"><a href="#产出构建结果" class="headerlink" title="产出构建结果"></a>产出构建结果</h3><p>最后还有一个部分，即用<code>Template</code>产出最终构建结果的代码内容，这一部分不做详细介绍了，仅留下一些线索，供有兴趣继续深入的同学使用：</p>
<ul>
<li><code>Template</code> 基础类：lib/Template.js</li>
<li>常用的主要<code>Template</code>类：lib/MainTemplate.js</li>
<li>Compilation 中产出构建结果的代码：compilation.createChunkAssets</li>
</ul>
<p>这一部分内容的介绍就到这里了，对此部分内容有兴趣继续深入探索的同学，建议使用断点调试的方式，结合笔者介绍的这些内容，大致走一遍 webpack 的构建流程，会对这一部分的内容印象更加深刻，同时也可以通过断点更有针对性地了解某一部分的细节处理。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/内部工作流程/">内部工作流程</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/26/webpack-之十三（提升webpack的构建速度）/" title="webpack十二之提升webpack的构建速度" itemprop="url">webpack十二之提升webpack的构建速度</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-11-26T12:48:54.000Z" itemprop="datePublished"> Published 2017-11-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="提升webpack的构建速度"><a href="#提升webpack的构建速度" class="headerlink" title="提升webpack的构建速度"></a>提升webpack的构建速度</h2><hr>
<p>我们的前端项目随着时间推移和业务发展，页面可能会越来越多，或者功能和业务代码会越来越多，又或者依赖的外部类库会越来越多，这个时候原本不足为道的 webpack 构建时间消耗就会慢慢地进入我们的视野。</p>
<p>构建消耗的时间变长了，如果是使用 CI 服务来做构建，大部分情况下我们无须等待，其实影响不大。但是本地的 webpack 开发环境服务启动时的速度和我们日常开发工作息息相关，在一些性能不是特别突出的设备上（例如便携式笔记本等等），启动时的长时间等待可能会让你越来越受不了。</p>
<p>笔者亲身经历的一个项目，使用 webpack 构建的时长可以达到 6 分钟左右，这种场景下，就算用 CI 服务，在遇见需要紧急发布修复问题时，也会让人很抓狂。所以这一小节我们来聊聊如何提升 webpack 的构建速度，也许某一天你负责的项目也会到了需要优化 webpack 构建性能的时候。</p>
<h2 id="让webpack少干点活"><a href="#让webpack少干点活" class="headerlink" title="让webpack少干点活"></a>让webpack少干点活</h2><hr>
<p>提升 webpack 构建速度本质上就是想办法让 webpack 少干点活，活少了速度自然快了，尽量避免 webpack 去做一些不必要的事情。</p>
<h3 id="减少resolve的解析"><a href="#减少resolve的解析" class="headerlink" title="减少resolve的解析"></a>减少<code>resolve</code>的解析</h3><p>我们可以精简 <code>resolve</code>配置，让webpack在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么webpack的构建速度也会快一些，下面举个例子，介绍<code>resolve</code>这一块做优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    path.resolve(__dirname, <span class="string">'node_modules'</span>), <span class="comment">// 使用绝对路径指定 node_modules，不做过多查询</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作</span></span><br><span class="line">  <span class="comment">// 其他文件可以在编码时指定后缀，如 import('./index.scss')</span></span><br><span class="line">  extensions: [<span class="string">".js"</span>], </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度</span></span><br><span class="line">  mainFiles: [<span class="string">'index'</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上述是可以从配置 <code>resolve</code> 下手提升 webpack 构建速度的配置例子。</p>
<p>我们在编码时，如果是使用我们自己本地的代码模块，尽可能编写完整的路径，避免使用目录名，如：<code>import &#39;./lib/slider/index.js&#39;</code>，这样的代码既清晰易懂，webpack 也不用去多次查询来确定使用哪个文件，一步到位。</p>
<h2 id="把loader应用的文件范围缩小"><a href="#把loader应用的文件范围缩小" class="headerlink" title="把loader应用的文件范围缩小"></a>把loader应用的文件范围缩小</h2><p>我们在使用 loader 的时候，尽可能把 loader 应用的文件范围缩小，只在最少数必须的代码模块中去使用必要的 loader，例如 node_modules 目录下的其他依赖类库文件，基本就是直接编译好可用的代码，无须再经过 loader 处理了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">    include: [ </span><br><span class="line">      path.resolve(__dirname, <span class="string">'src'</span>), </span><br><span class="line">      <span class="comment">// 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</span></span><br><span class="line">      <span class="comment">// 通常我们需要 loader 处理的文件都是存放在 src 目录</span></span><br><span class="line">    ],</span><br><span class="line">    use: <span class="string">'babel-loader'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>如上边这个例子，如果没有配置 <code>include</code>，所有的外部依赖模块都经过 Babel 处理的话，构建速度也是会收很大影响的。</p>
<h2 id="减少plugin的消耗"><a href="#减少plugin的消耗" class="headerlink" title="减少plugin的消耗"></a>减少plugin的消耗</h2><p>webpack 的 plugin 会在构建的过程中加入其它的工作步骤，如果可以的话，适当地移除掉一些没有必要的 plugin。</p>
<p>这里再提一下 webpack 4.x 的 mode，区分 mode 会让 webpack 的构建更加有针对性，更加高效。例如当 mode 为 development 时，webpack 会避免使用一些提高应用代码加载性能的配置项，如 UglifyJsPlugin，ExtractTextPlugin 等，这样可以更快地启动开发环境的服务，而当 mode 为 production 时，webpack 会避免使用一些便于 debug 的配置，来提升构建时的速度，例如极其消耗性能的 Source Maps 支持。</p>
<h3 id="换种方式处理图片"><a href="#换种方式处理图片" class="headerlink" title="换种方式处理图片"></a>换种方式处理图片</h3><p>我们在前边的小节提到图片可以使用 webpack 的 image-webpack-loader 来压缩图片，在对 webpack 构建性能要求不高的时候，这样是一种很简便的处理方式，但是要考虑提高 webpack 构建速度时，这一块的处理就得重新考虑一下了，思考一下是否有必要在 webpack 每次构建时都处理一次图片压缩。</p>
<p>这里介绍一种解决思路，我们可以直接使用 imagemin 来做图片压缩，编写简单的命令即可。然后使用 pre-commit 这个类库来配置对应的命令，使其在 git commit 的时候触发，并且将要提交的文件替换为压缩后的文件。</p>
<p>这样提交到代码仓库的图片就已经是压缩好的了，以后在项目中再次使用到的这些图片就无需再进行压缩处理了，image-webpack-loader 也就没有必要了。</p>
<h2 id="使用DLLPlugin"><a href="#使用DLLPlugin" class="headerlink" title="使用DLLPlugin"></a>使用DLLPlugin</h2><hr>
<p>DLLPlugin 是 webpack 官方提供的一个插件，也是用来分离代码的，和 optimization.splitChunks（3.x 版本的是 CommonsChunkPlugin）有异曲同工之妙，之所以把 DLLPlugin 放到 webpack 构建性能优化这一部分，是因为它的配置相对繁琐，如果项目不涉及性能优化这一块，基本上使用 optimization.splitChunks 即可。</p>
<p>我们来看一下 DLLPlugin 如何使用，使用这个插件时需要额外的一个构建配置，用来打包公共的那一部分代码，举个例子，假设这个额外配置是 webpack.dll.config.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  name: <span class="string">'vendor'</span>,</span><br><span class="line">  entry: [<span class="string">'lodash'</span>], <span class="comment">// 这个例子我们打包 lodash 作为公共类库</span></span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"vendor.js"</span>,</span><br><span class="line">    library: <span class="string">"vendor_[hash]"</span> <span class="comment">// 打包后对外暴露的类库名称</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor_[hash]'</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">"dist/manifest.json"</span>), <span class="comment">// 使用 DLLPlugin 在打包的时候生成一个 manifest 文件</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是我们正常的应用构建配置，在那个的基础上添加两个一个新的 <code>webpack.DllReferencePlugin</code> 配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: path.resolve(__dirname, <span class="string">'dist/manifest.json'</span>), </span><br><span class="line">      <span class="comment">// 指定需要用到的 manifest 文件，</span></span><br><span class="line">      <span class="comment">// webpack 会根据这个 manifest 文件的信息，分析出哪些模块无需打包，直接从另外的文件暴露出来的内容中获取</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建的时候我们需要要优先使用<code>webpack.dll.config.js</code>来打包，如<code>webpack -c webpack.dll.config.js --mode production</code>,构建生成公共代码某块的文件<code>vendor.js</code>和<code>manifest.json</code>,然后再进行应用代码的构建。</p>
<p>你会发现构建结果的应用代码中不包含 lodash 的代码内容，这一部分代码内容会放在 <code>vendor.js</code> 这个文件中，而你的应用要正常使用的话，需要在 HTML 文件中按顺序引用这两个代码文件，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vendor.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>作用是不是和<code>·optimization.splitChunks</code> 很相似，但是有个区别，DLLPlugin 构建出来的内容无需每次都重新构建，后续应用代码部分变更时，你不用再执行配置为 <code>webpack.dll.config.js</code> 这一部分的构建，沿用原本的构建结果即可，所以相比 <code>optimization.splitChunks</code>，使用 DLLPlugin 时，构建速度是会有显著提高的。</p>
<p>但是很显然，DLLPlugin 的配置要麻烦得多，并且需要关心你公共部分代码的变化，当你升级 lodash（即你的公共部分代码的内容变更）时，要重新去执行 <code>webpack.dll.config.js</code> 这一部分的构建，不然沿用的依旧是旧的构建结果，使用上并不如 <code>optimization.splitChunks</code> 来得方便。这是一种取舍，根据项目的实际情况采用合适的做法。</p>
<p>还有一点需要注意的是，html-webpack-plugin 并不会自动处理 DLLPlugin 分离出来的那个公共代码文件，我们需要自己处理这一部分的内容，可以考虑使用 add-asset-html-webpack-plugin，关于这一个的使用就不讲解了，详细参考官方的说明文档：使用 add-asset-html-webpack-plugin。</p>
<h2 id="webpack4-x的构建性能"><a href="#webpack4-x的构建性能" class="headerlink" title="webpack4.x的构建性能"></a>webpack4.x的构建性能</h2><hr>
<p>从官方发布的 webpack 4.0 更新日志来看，webpack 4.0 版本做了很多关于提升构建性能的工作，我觉得比较重要的改进有这么几个：</p>
<ul>
<li>AST 可以直接从 loader 直接传递给 webpack，避免额外的解析，对这一个优化细节有兴趣的可以查看这个 PR。</li>
<li>使用速度更快的 md4 作为默认的 hash 方法，对于大型项目来说，文件一多，需要 hash 处理的内容就多，webpack 的 hash 处理优化对整体的构建速度提升应该还是有一定的效果的。</li>
<li>Node 语言层面的优化，如用 for of 替换 forEach，用 Map 和 Set 替换普通的对象字面量等等，这一部分就不展开讲了，有兴趣的同学可以去 webpack 的 PRs 寻找更多的内容。</li>
<li>默认开启 uglifyjs-webpack-plugin 的 cache 和 parallel，即缓存和并行处理，这样能大大提高 production mode 下压缩代码的速度。</li>
</ul>
<p>除此之外，还有比较琐碎的一些内容，可以查阅：webpack release 4.0，留意 performance 关键词。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/提升webpack的构建速度/">提升webpack的构建速度</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/09/21/webpack-之八（用HRM提高开发效率）/" title="用HRM提高开发效率" itemprop="url">用HRM提高开发效率</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-09-21T11:30:49.000Z" itemprop="datePublished"> Published 2017-09-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="用HMR提高开发效率"><a href="#用HMR提高开发效率" class="headerlink" title="##用HMR提高开发效率"></a>##用HMR提高开发效率</h2><p>HMR 全称是Hot Module Replacement，即某块替换。在这个概念之前使用郭Hot Reloading，当代码变更是通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HRM可以理解为增强版的Hot Reloading，但不用整个页面刷新，而是局部替换模块代码并且使其生效，可以看到代码变更的效果。所以HRM即避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率。</p>
<h2 id="配置使用HMR"><a href="#配置使用HMR" class="headerlink" title="配置使用HMR"></a>配置使用HMR</h2><hr>
<p>HRM是webpack提供的非常有用的一个功能，跟我们之前提到的一样，安装好web-dev-server，添加一些简单的配置，即在webpack的配置文件中添加HMR需要的两个插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span> <span class="comment">// dev server 的配置要启动 hot，或者在命令行中带参数开启</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">// 用于启动 HMR 时可以显示模块的相对路径</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// Hot Module Replacement 的插件</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HMR运行原理"><a href="#HMR运行原理" class="headerlink" title="HMR运行原理"></a>HMR运行原理</h2><hr>
<p>HRM的实现和运行相对复杂，需要多个部分协同配合，这里稍微介绍一下HRM的运行原理。</p>
<p>首先我们知道一个概念：webpack内部运行时，回维护一份用于管理构建代码时各个幂快之间交互的表数据。webpack官方称之为Manifest，其中包括入口文件和构建出来的bundle文件的关系。可以使用<code>WebpackManifestPlugin</code>插件来输出这样的一份数据。</p>
<p>开启了hot功能的webpack回往我们应用的主要代码中添加WS相关的代码，用于和服务器保持连接，等待更新动作。</p>
<p>当你配置了HMR的插件时，会往应用代码中添加HRM运行时的代码，主要用于定义代码模块更新时的API，</p>
<p>有了这两个部分就可以支持HMR的功能了。当有更新时，webpack-dev-server发送更新信号给HMR运行时，然后HMR再请求所需要的更新数据，请求的更新数据没有问题的话就应用更新数据。</p>
<p>如果HMR只是简单替换代码模块的内容，如替换掉所谓的<code>installedModules</code>中需要更新新的部分，那么浏览器就没有办法把跟新后的结果实时地在浏览器上显示出来。</p>
<p>前面提到的HMR运行时的代码会提供定义模版应用跟新执行时的API，这些API可以让我们在模块中定义接收到HMR更新应用信号时，需要额外做些什么工作，例如<code>style-loader</code>就需要实现HMR接口，当收到更新时，使用新的样式替换掉久的样式，大概就是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'/some/path'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 用新样式替换旧样式</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情可以产考style-loader中的代码实现<code>HMR interface implemention in style-loader</code> 。</p>
<p>HRM应用更新时是使用<code>webpackHotUpdate</code>来处理的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webpackHotUpdate(id, &#123; </span><br><span class="line">  <span class="string">'modulePath'</span>: </span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块更新后的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行<code>webpackHotUpdate</code>时如发现模块代码实现了HMR接口，就会执行相应的回调或者方法，从而达到应用更新时，模块可以自行管理自己所需要额外做的工作。不过，并不是所有的模块都需要做相关的处理，当遇见没有HMR接口的模块时，就会开始向上层冒泡。</p>
<p>这里还有一个问题提是，webpack如何保证HMR接口中的引用是最新的模块代码？看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./bar'</span></span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./bar'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log('Accepting the updated bar module!')</span></span><br><span class="line">    hello()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看，hello都是同一个，这样的话并没有办法引入最新的代码，但是我们看一下上述代码webpack构建后的结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">"./src/bar.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">__WEBPACK_OUTDATED_DEPENDENCIES__</span>) </span>&#123; </span><br><span class="line">    <span class="comment">/* harmony import */</span> </span><br><span class="line">    __WEBPACK_IMPORTED_MODULE_1__bar__ = __webpack_require__(<span class="string">"./src/bar.js"</span>); </span><br><span class="line">    (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log('Accepting the updated bar module!')</span></span><br><span class="line">      <span class="built_in">Object</span>(__WEBPACK_IMPORTED_MODULE_1__bar__[<span class="string">"default"</span>])()</span><br><span class="line">    &#125;)(__WEBPACK_OUTDATED_DEPENDENCIES__); </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他代码比较复杂，我们集中看<code>module.hot</code>的处理部分。这里可以发现，我们的hello已经重新使用<code>_webpack_require_</code>来引入了，所以可以确保它是最新的代码。</p>
<p>基本上HMR的执行原理就是这样，更具体的实现部分就不展开讲解了。在日常开发中，我们更多的需要工具来实现HMR的接口，避免编写过多HMR需要的代码。例如，React在组件代码更新时可能需要触发render开实现组件的展示效果，官方提供了一些现有的工具，需要的可以参考一下：<code>hot module replacement tools</code>。</p>
<h2 id="module-hot常见API"><a href="#module-hot常见API" class="headerlink" title="module.hot常见API"></a>module.hot常见API</h2><hr>
<p>前面HMR实现部分已经讲解了HRM接口的重要性，下面来看看常见的<code>module.hot</code>API有哪些，以及如何使用。</p>
<p>之前已经介绍过，<code>module.hot.accept</code>方法指定在应用特定代码某块更新时执行相应的callback，第一个参数可以是字符串或者时数组，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept([<span class="string">'./bar.js'</span>, <span class="string">'./index.css'</span>], () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 这样当 bar.js 或者 index.css 更新时都会执行该函数</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module.hot,decline</code>对于指定的代码模块，拒绝进行某块代码更新，进入更新失败状态，如<code>module.hot.decline(&#39;./bar.js&#39;)</code>。这个方法比较少用到。</p>
<p><code>module.hot.dispose</code>用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.dispose(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module.hot.accept</code>通常用于指定当前依赖的某个模块需要更新时需要做的处理，如果当前模块跟新时需要处理的动作，使用<code>module.hot.dispose</code>会更加容易方便。</p>
<p><code>module.hot.removeDisposeHandler</code>用于移除<code>dispose</code>方法添加的callback。</p>
<p>关于<code>module.hot</code>的更多API详情可以产考官方文档：Hot Module Replacement APIs。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/用HRM提高开发效率/">用HRM提高开发效率</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/08/11/webpack-之六 （更好地使用webpack-dev-server）/" title="更好的使用webpack-dev-server" itemprop="url">更好的使用webpack-dev-server</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-08-11T04:18:21.000Z" itemprop="datePublished"> Published 2017-08-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="webpack-dev-server-的基础使用"><a href="#webpack-dev-server-的基础使用" class="headerlink" title="webpack-dev-server 的基础使用"></a>webpack-dev-server 的基础使用</h2><hr>
<p>webpack-dev-server是一个npm package，安装后在已经有 webpack 配置文件的项目目录下直接启动就可以：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server -g</span><br><span class="line">webpack-dev-server --mode development</span><br></pre></td></tr></table></figure>
<p>webpack-dev-server 本质上也是调用webpack，4.x版本的也要指定mode，其实webpack-dev-server应该直接把development作为默认值，有兴趣的同学可以查看这个 issue：Default mode to development?。</p>
<p>建议把 webpack-dev-server 作为开发依赖安装，然后使用 npm scripts 来启动，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>
<p>package中的script配置：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  "scripts": &#123;</span><br><span class="line">    "start": "webpack-dev-server --mode development"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p>webpack-dev-server 默认使用 8080 端口，如果你使用了 html-webpack-plugin 来构建 HTML 文件，并且有一个 index.html 的构建结果，那么直接访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 就可以看到 index.html 页面了。如果没有 HTML 文件的话，那么 webpack-dev-server 会生成一个展示静态资源列表的页面。</p>
<h2 id="webpack-dev-server的配置"><a href="#webpack-dev-server的配置" class="headerlink" title="webpack-dev-server的配置"></a>webpack-dev-server的配置</h2><hr>
<p>在 webpack 的配置中，可以通过 <code>devServer</code> 字段来配置 webpack-dev-server，如端口设置、启动 gzip 压缩等，这里简单讲解几个常用的配置。</p>
<p><code>public</code> 字段用于指定静态服务器的域名，默认是<a href="http://localhost:8080/,当你使用" target="_blank" rel="noopener">http://localhost:8080/,当你使用</a> Nginx 来做反向代理时，应该就需要使用该配置来指定 Nginx 配置使用的服务域名。</p>
<p><code>port</code> 字段用于指定静态服务的端口，如上，默认是 8080，通常情况下都不需要改动。</p>
<p><code>publicPath</code>字段用于指定构建好的静态文件在浏览器中用什么路径去访问，默认是<code>/</code>,例如，对于一个构建好的<code>bundle.js</code>,完整的访问路径是<code>http://localhost:8080/bundle.js</code>。可以使用整个URL来作为<code>publicPath</code>的值，如<code>publicPath: &#39;http://localhost:8080/assets/&#39;</code>。如果你使用了HMR，那么设置<code>publicPath</code>就必须用完整的URL。</p>
<blockquote>
<p>建议将<code>devServer.publicPath</code>和<code>output.publicPath</code>的值保持一致。</p>
</blockquote>
<p><code>proxy</code>用于配置webpack-dev-server将特定的URL的请求代理到另外一台服务器上。当你有单独的后端开发服务器用于请求 API 时，这个配置相当有用。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">  <span class="string">'/api'</span>: &#123;</span><br><span class="line">    target: <span class="string">"http://localhost:3000"</span>, <span class="comment">// 将 URL 中带有 /api 的请求代理到本地的 3000 端口的服务上</span></span><br><span class="line">    pathRewrite: &#123; <span class="string">'^/api'</span>: <span class="string">''</span> &#125;, <span class="comment">// 把 URL 中 path 部分的 `api` 移除掉</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack-dev-server 的 proxy 功能是使用 http-proxy-middleware 来实现的，如果需要更详细的 proxy 配置，可以参考官方文档 http-proxy-middleware。</p>
<p><code>contentbase</code>用于配置提供额外静态文件内容的目录，之前提到的 <code>publicPath</code> 是配置构建好的结果以什么样的路径去访问，而 <code>contentBase</code> 是配置额外的静态文件内容的访问路径，即那些不经过 webpack 构建，但是需要在 webpack-dev-server 中提供访问的静态资源（如部分图片等）。推荐使用绝对路径：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用当前目录下的 public</span></span><br><span class="line">contentBase: path.join(__dirname, <span class="string">"public"</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用数组提供多个路径</span></span><br><span class="line">contentBase: [path.join(__dirname, <span class="string">"public"</span>), path.join(__dirname, <span class="string">"assets"</span>)]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>publicPath 的优先级高于<code>contentBase</code></p>
</blockquote>
<p>before 和 after 配置用于在 webpack-dev-server 定义额外的中间件，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">before(app)&#123;</span><br><span class="line">  app.get(<span class="string">'/some/path'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123; <span class="comment">// 当访问 /some/path 路径时，返回自定义的 json 数据</span></span><br><span class="line">    res.json(&#123; <span class="attr">custom</span>: <span class="string">'response'</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>before</code> 在 webpack-dev-server 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 mock。</p>
<p><code>after</code>在 webpack-dev-server 静态资源中间件处理之后，比较少用到，可以用于打印日志或者做一些额外处理。</p>
<p>webpack-dev-server 的配置项比较多，这里只列举了一些日常比较有用的，更多的请参考官方文档 webpack-dev-server。</p>
<h2 id="webpack-dev-middleware"><a href="#webpack-dev-middleware" class="headerlink" title="webpack-dev-middleware"></a>webpack-dev-middleware</h2><hr>
<p>如果你熟悉使用 Node.js 来开发 Web 服务，使用过 <code>Express</code> 或者 <code>Koa</code>，那么对中间件的概念应该会有所了解。</p>
<p>简而言之，中间件就是在 Express 之类的 Web 框架中实现各种各样功能（如静态文件访问）的这一部分函数。多个中间件可以一起协同构建起一个完整的 Web 服务器。</p>
<p>不熟悉 Express 中间件概念的同学可以参考 Express 的官方文档 <code>使用中间件</code>。</p>
<p>webpack-dev-middleware 就是在Express中提webpack-dev-server静态服务能力的一个中间件，我们可以很轻松地将其集成现有的Express代码中去，就像添加一个Express中间件那么简单。</p>
<p>首先安装webpack-deb-middlesware以来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-middleware --save-dev</span><br></pre></td></tr></table></figure>
<p>接着创建一个 Node.js 服务的脚本文件，如 app.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> middleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>)</span><br><span class="line"><span class="keyword">const</span> webpackOptions = <span class="built_in">require</span>(<span class="string">'webpack.config.js'</span>) <span class="comment">//webpack配置文件的路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地的开发环境默认就是使用 development mode</span></span><br><span class="line">webpackOptions.mode = <span class="string">'development'</span></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(webpackOptions)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(middleware(compiler,&#123;</span><br><span class="line">  <span class="comment">// webpack-dev-middleware 的配置项</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他 Web 服务中间件</span></span><br><span class="line"><span class="comment">// app.use(...)</span></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>))</span><br></pre></td></tr></table></figure>
<p>然后用 Node.js 运行该文件即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js # 使用刚才创建的 app.js 文件</span><br></pre></td></tr></table></figure>
<p>使用 webpack-dev-server 的好处是相对简单，直接安装依赖后执行命令即可，而使用 webpack-dev-middleware 的好处是可以在既有的 Express 代码基础上快速添加 webpack-dev-server 的功能，同时利用 Express 来根据需要添加更多的功能，如 mock 服务、代理 API 请求等。</p>
<p>其实 webpack-dev-server 也是基于 Express 开发的，前面提及的 webpack-dev-server 中 before 或 after 的配置字段，也可以用于编写特定的中间件来根据需要添加额外的功能。</p>
<h2 id="实现一个简单的mock服务"><a href="#实现一个简单的mock服务" class="headerlink" title="实现一个简单的mock服务"></a>实现一个简单的mock服务</h2><hr>
<p>在前端的日常开发工作中，我们本地需要的不仅仅是提供静态内容访问的服务，还需要模拟后端 API 数据来做一些应用测试工作，这个时候我们需要一个 mock 数据的服务，而 webpack-dev-server 的 <code>before</code> 或 <code>proxy</code> 配置，又或者是 webpack-dev-middleware 结合 Express，都可以帮助我们来实现简单的 mock 服务。</p>
<p>这一部分内容涉及比较多的 Node.js 代码实现，这里不做过于详细的例子解释，只提供一些实现的思路。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = <span class="function"><span class="keyword">function</span> <span class="title">mock</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.get(<span class="string">'/some/path'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    res.json(&#123; <span class="attr">data</span>: <span class="string">''</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 其他的请求 mock</span></span><br><span class="line">  <span class="comment">// 如果 mock 代码过多，可以将其拆分成多个代码文件，然后 require 进来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后应用到配置中的 <code>before</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mock = <span class="built_in">require</span>(<span class="string">'./mock'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">before(app) &#123;</span><br><span class="line">  mock(app) <span class="comment">// 调用 mock 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的<code>mock</code>函数照样可以应用到Express中去，提供与 webpack-dev-middleware 同样的功能。</p>
<p>由于 app.get(‘’, (req, res) =&gt; { … }) 的 callback 可以拿到 req 请求对象，其实可以根据请求参数来改变返回的结果，即通过参数来模拟多种场景的返回数据来协助测试多种场景下的代码应用。</p>
<p>当你单独实现或者使用一个 mock 服务时，你可以通过 proxy 来配置部分路径代理到对应的 mock 服务上去，从而把 mock 服务集成到当前的开发服务中去，相对来说也很简单。</p>
<p>当你和后端开发进行联调时，亦可使用 proxy 代理到对应联调使用的机器上，从而可以使用本地前端代码的开发环境来进行联调。当然了，连线上环境的异常都可以这样来尝试定位问题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/更好的使用webpack-dev-server/">更好的使用webpack-dev-server</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/更好的使用webpack-dev-server/" title="更好的使用webpack-dev-server">更好的使用webpack-dev-server<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack的使用方法/" title="webpack的使用方法">webpack的使用方法<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack-如何解析模块代码路径/" title="webpack 如何解析模块代码路径">webpack 如何解析模块代码路径<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/优化前端资源加载-1-图片加载优化和代码压缩/" title="优化前端资源加载 1 - 图片加载优化和代码压缩">优化前端资源加载 1 - 图片加载优化和代码压缩<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack搭建前端基本环境/" title="webpack搭建前端基本环境">webpack搭建前端基本环境<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/使用Plugin/" title="使用Plugin">使用Plugin<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/用HRM提高开发效率/" title="用HRM提高开发效率">用HRM提高开发效率<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/开发和生产环境的构建配置差异/" title="开发和生产环境的构建配置差异">开发和生产环境的构建配置差异<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/优化前端资源加载-3-进一步控制-JS-大小/" title="优化前端资源加载 3 - 进一步控制 JS 大小">优化前端资源加载 3 - 进一步控制 JS 大小<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/提升webpack的构建速度/" title="提升webpack的构建速度">提升webpack的构建速度<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/创建自己的loader/" title="创建自己的loader">创建自己的loader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/配置loader/" title="配置loader">配置loader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/优化前端资源加载-2-分离代码文件/" title="优化前端资源加载 2 - 分离代码文件">优化前端资源加载 2 - 分离代码文件<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/内部工作流程/" title="内部工作流程">内部工作流程<sup>1</sup></a></li>
			
		
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="xxinso">xxinso</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
