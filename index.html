
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="xxinso">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/30/webpack-之五/" title="webpack-之五" itemprop="url">webpack-之五</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-06-30T10:01:33.000Z" itemprop="datePublished"> Published 2018-06-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>webpack 中的 plugin 大多都提供额外的能力，它们在 webpack 中的配置都只是把插件实例添加到 <code>plugins</code> 字段的数组中。不过由于需要提供不同的功能，不同的插件本身的配置比较多样化。</p>
<p>社区中有很多 webpack 插件可供使用，而优秀的插件基本上都提供了详细的使用说明文档。更多的插件可以在这里查找：plugins in awesome-webpack。</p>
<p>下面通过介绍几个常用的插件来了解使用方法</p>
<h2 id="DefinePlugin"><a href="#DefinePlugin" class="headerlink" title="DefinePlugin"></a>DefinePlugin</h2><hr>
<p>DefinePlugin 是 webpack 内置的插件，可以使用 <code>webpack.DefinePlugin</code> 直接获取。</p>
<p>这个插件用于创建一些在编译时可以配置的全局常量，这些常量的值我们可以在 webpack 的配置中去指定，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      PRODUCTION: <span class="built_in">JSON</span>.stringify(<span class="literal">true</span>), <span class="comment">// const PRODUCTION = true</span></span><br><span class="line">      VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">'5fa3b9'</span>), <span class="comment">// const VERSION = '5fa3b9'</span></span><br><span class="line">      BROWSER_SUPPORTS_HTML5: <span class="literal">true</span>, <span class="comment">// const BROWSER_SUPPORTS_HTML5 = 'true'</span></span><br><span class="line">      TWO: <span class="string">'1+1'</span>, <span class="comment">// const TWO = 1 + 1,</span></span><br><span class="line">      CONSTANTS: &#123;</span><br><span class="line">        APP_VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">'1.1.2'</span>) <span class="comment">// const CONSTANTS = &#123; APP_VERSION: '1.1.2' &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了上面的配置，就可以在应用代码文件中，访问配置好的变量了，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Running App version "</span> + VERSION);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!BROWSER_SUPPORTS_HTML5) <span class="built_in">require</span>(<span class="string">"html5shiv"</span>);</span><br></pre></td></tr></table></figure>
<p>上面配置的注释已经简单说明了这些配置的效果，这里再简述一下整个配置规则。</p>
<ul>
<li>如果配置的值是字符串，那么整个字符串会被当成代码片段来执行，其结果作为最终变量的值，如上面的 <code>&quot;1+1&quot;</code>，最后的结果是 <code>2</code></li>
<li>如果配置的值不是字符串，也不是一个对象字面量，那么该值会被转为一个字符串，如 <code>true</code>，最后的结果是 <code>&#39;true&#39;</code></li>
<li>如果配置的是一个对象字面量，那么该对象的所有 key 会以同样的方式去定义</li>
</ul>
<p>这样我们就可以理解为什么要使用 JSON.stringify() 了，因为 JSON.stringify(true) 的结果是 ‘true’，JSON.stringify(“5fa3b9”) 的结果是 “5fa3b9”。</p>
<p>社区中关于 DefinePlugin 使用得最多的方式是定义环境变量，例如 PRODUCTION = true 或者 <strong>DEV</strong> = true 等。部分类库在开发环境时依赖这样的环境变量来给予开发者更多的开发调试反馈，例如 react 等。</p>
<blockquote>
<p>建议使用 process.env.NODE_ENV: … 的方式来定义 process.env.NODE_ENV，而不是使用 process: { env: { NODE_ENV: … } } 的方式，因为这样会覆盖掉 process 这个对象，可能会对其他代码造成影响。</p>
</blockquote>
<h2 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h2><hr>
<p>这个插件看名字就知道它有什么作用，没错，就是用来复制文件的。</p>
<p>我们一般会把开发的所有源码和资源文件放在 src/ 目录下，构建的时候产出一个 build/ 目录，通常会直接拿 build 中的所有文件来发布。有些文件没经过 webpack 处理，但是我们希望它们也能出现在 build 目录下，这时就可以使用 CopyWebpackPlugin 来处理了。</p>
<p>我么来看看如何配置这个插件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123; <span class="attr">from</span>: <span class="string">'src/file.txt'</span>, <span class="attr">to</span>: <span class="string">'build/file.txt'</span>, &#125;, <span class="comment">// 顾名思义，from 配置来源，to 配置目标路径</span></span><br><span class="line">      &#123; <span class="attr">from</span>: <span class="string">'src/*.ico'</span>, <span class="attr">to</span>: <span class="string">'build/*.ico'</span> &#125;, <span class="comment">// 配置项可以使用 glob</span></span><br><span class="line">      <span class="comment">// 可以配置很多项复制规则</span></span><br><span class="line">    ]),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>glob 用法可以参考 glob-primer。</p>
</blockquote>
<p>上述的配置日常应用已经足够，跟多的配置内容可以参考copy-webpack-plugin。</p>
<h2 id="extract-text-webpack-plugin"><a href="#extract-text-webpack-plugin" class="headerlink" title="extract-text-webpack-plugin"></a>extract-text-webpack-plugin</h2><hr>
<p>我们用它来把依赖的 CSS 分离出来成为单独的文件。这里再看一下使用 extract-text-webpack-plugin 的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123; </span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;), </span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'index.css'</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述的配置中，我们使用了 index.css 作为单独分离出来的文件名，但有的时候构建入口不止一个，extract-text-webpack-plugin 会为每一个入口创建单独分离的文件，因此最好这样配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'[name].css'</span>),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>这样确保在使用多个构建入口时，生成不同名称的文件。</p>
<p> extract-text-webpack-plugin是蛮常用的插件，并且它的使用方式比较特别，除了在 <code>plugins</code> 字段添加插件实例之外，还需要调整 loader 对应的配置。</p>
<p> 在这里要强调的是，在 webpack 中，loader 和 plugin 的区分是很清楚的，针对文件模块转换要做的使用 loader，而其他干涉构建内容的可以使用 plugin。 ExtractTextWebpackPlugin 既提供了 plugin，也提供了 extract 方法来获取对应需要的 loader。</p>
<h2 id="ProvidePlugin"><a href="#ProvidePlugin" class="headerlink" title="ProvidePlugin"></a>ProvidePlugin</h2><hr>
<p>ProvidePlugin 也是一个 webpack 内置的插件，我们可以直接使用 <code>webpack.ProvidePlugin</code> 来获取。</p>
<p>该组件用于引用某些模块作为应用运行时的变量，从而不必每次都用 require 或者 import，其用法相对简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  identifier: <span class="string">'module'</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  identifier: [<span class="string">'module'</span>, <span class="string">'property'</span>], <span class="comment">// 即引用 module 下的 property，类似 import &#123; property &#125; from 'module'</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在你的代码中，当 <code>identifier</code> 被当作未赋值的变量时，module 就会被自动加载了，而 <code>identifier</code> 这个变量即 module 对外暴露的内容。</p>
<p>注意，如果是 ES 的 <code>default export</code>，那么你需要指定模块的 default 属性：<code>identifier: [&#39;module&#39;, &#39;default&#39;],</code>。</p>
<p>更多使用例子可以查看官方文档 ProvidePlugin。</p>
<h2 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h2><hr>
<p>IgnorePlugin 和 ProvidePlugin 一样，也是一个 webpack 内置的插件，可以直接使用 <code>webpack.IgnorePlugin</code> 来获取。</p>
<p>这个插件用于忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去。例如我们使用 moment.js，直接引用后，里边有大量的 i18n 的代码，导致最后打包出来的文件比较大，而实际场景并不需要这些 i18n 的代码，这时我们可以使用 IgnorePlugin 来忽略掉这些代码文件，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IgnorePlugin 配置的参数有两个，第一个是匹配引入模块路径的正则表达式，第二个是匹配模块的对应上下文，即所在目录名。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/使用Plugin/">使用Plugin</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/25/webpack-之四loader/" title="webpack-之四loader" itemprop="url">webpack-之四loader</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-06-25T02:58:27.000Z" itemprop="datePublished"> Published 2018-06-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="loader匹配规则"><a href="#loader匹配规则" class="headerlink" title="loader匹配规则"></a>loader匹配规则</h2><hr>
<p>当我们需要配置 loader 时，都是在 <code>module.rules</code> 中添加新的配置项，在该字段中，每一项被视为一条匹配使用 loader 的规则。</p>
<p>先来看一个基础的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [ </span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>, <span class="comment">// 条件</span></span><br><span class="line">        include: [ </span><br><span class="line">          path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">        ], <span class="comment">// 条件</span></span><br><span class="line">        use: <span class="string">'babel-loader'</span>, <span class="comment">// 规则应用结果</span></span><br><span class="line">      &#125;, <span class="comment">// 一个 object 即一条规则</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loader 的匹配规则中有两个最关键的因素：一个是匹配条件，一个是匹配规则后的应用。</p>
<p>匹配条件通常都使用请求资源文件的绝对路径来进行匹配，在官方文档中称为 resource，除此之外还有比较少用到的 <code>issuer</code>，则是声明依赖请求的源文件的绝对路径。举个例子：在 <code>/path/to/app.js</code> 中声明引入 <code>import &#39;./src/style.scss&#39;</code>，resource 是 <code>/path/to/src/style.scss</code>，<code>issuer</code> 是 /path/to/app.js，规则条件会对这两个值来尝试匹配。</p>
<p>上述代码中的 <code>test</code> 和 <code>include</code> 都用于匹配 <code>resource</code> 路径，是 <code>resource.test</code> 和 <code>resource.include</code> 的简写，你也可以这么配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  rules: [ </span><br><span class="line">      &#123;</span><br><span class="line">        resource: &#123; <span class="comment">// resource 的匹配条件</span></span><br><span class="line">          test: <span class="regexp">/\.jsx?/</span>, </span><br><span class="line">          include: [ </span><br><span class="line">            path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 如果要使用 issuer 匹配，便是 issuer: &#123; test: ... &#125;</span></span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ], </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>issuer 规则匹配的场景比较少见，你可以用它来尝试约束某些类型的文件中只能引用某些类型的文件。</p>
</blockquote>
<p>当规则的条件匹配时，便会使用对应的 loader 配置，如上述例子中的 <code>babel-loader</code>。关于 loader 配置后面再详细介绍，这里先来看看如何配置更加复杂的规则匹配条件。</p>
<h2 id="规则条件配置"><a href="#规则条件配置" class="headerlink" title="规则条件配置"></a>规则条件配置</h2><hr>
<p>大多数情况下，配置 loader 的匹配条件时，只要使用 <code>test</code> 字段就好了，很多时候都只需要匹配文件后缀名来决定使用什么 loader，但也不排除在某些特殊场景下，我们需要配置比较复杂的匹配条件。webpack 的规则提供了多种配置形式：</p>
<ul>
<li><code>{ test: ... }</code> 匹配特定条件</li>
<li><code>{ include: ... }</code> 匹配特定的路径</li>
<li><code>{ exclude: ... }</code> 排除特定的路径</li>
<li><code>{ and: [...] }</code> 必须匹配数组中的所有的条件</li>
<li><code>{ or: [...] }</code> 匹配数组中的任意的条件</li>
<li><code>{ not: [...] }</code> 排除数组中的任意条件</li>
</ul>
<p>上诉的所谓条件的值可以是：</p>
<ul>
<li>字符串：必须以提供的字符串开始，所以是字符串的化，这里我们需要提供绝对路径。</li>
<li>正则表达式：调用正则的<code>test</code>方法来匹配。</li>
<li>函数：（path）=&gt;boolean,返回<code>true</code>表示匹配</li>
<li>数组：至少包含一个条件的数组</li>
<li>对象：匹配所有属性值的条件</li>
</ul>
<p>通过例子来帮助理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: /\.jsx?/, // 正则</span><br><span class="line">    include: [</span><br><span class="line">      path.resolve(__dirname, &apos;src&apos;), // 字符串，注意是绝对路径</span><br><span class="line">    ], // 数组</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      js: /\.js/,</span><br><span class="line">      jsx: /\.jsx/,</span><br><span class="line">    &#125;, // 对象，不建议使用</span><br><span class="line">    not: [</span><br><span class="line">      (value) =&gt; &#123; /* ... */ return true; &#125;, // 函数，通常需要高度自定义时才会使用</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>上述多个配置形式结合起来就能够基本满足各种各样的构建场景了，通常我们会结合使用 <code>test/and</code> 和 <code>include&amp;exclude</code> 来配置条件，如上述那个简单的例子。</p>
<h2 id="modile-type"><a href="#modile-type" class="headerlink" title="modile type"></a>modile type</h2><hr>
<p>webpack 4.x 版本强化了 module type，即模块类型的概念，不同的模块类型类似于配置了不同的 loader，webpack 会有针对性地进行处理，现阶段实现了以下 5 种模块类型。</p>
<ul>
<li><p><code>javascript/auto</code>:即 webpack 3 默认的类型，支持现有的各种 JS 代码模块类型 —— CommonJS、AMD、ESM</p>
</li>
<li><p><code>javascript/esm</code>:ECMAScript modules，其他模块系统，例如 CommonJS 或者 AMD 等不支持，是 .mjs 文件的默认类型</p>
</li>
<li><p><code>javascript/dynamic</code>:CommonJS 和 AMD，排除 ESM</p>
</li>
<li><code>javascript/json</code> :JSON 格式数据，<code>require</code> 或者 <code>import</code> 都可以引入，是 <code>.json</code> 文件的默认类型</li>
<li><code>webassembly/experimental</code>:WebAssembly modules，当前还处于试验阶段，是 .wasm 文件的默认类型</li>
</ul>
<p>如果不希望使用默认的类型的话，在确定好匹配规则条件时，我们可以使用 type 字段来指定模块类型，例如把所有的 JS 代码文件都设置为强制使用 ESM 类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js/</span>,</span><br><span class="line">  include: [</span><br><span class="line">    path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">  ],</span><br><span class="line">  type: <span class="string">'javascript/esm'</span>, <span class="comment">// 这里指定模块类型</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上述做法是可以帮助你规范整个项目的模块系统，但是如果遗留太多不同类型的模块代码时，建议还是直接使用默认的 <code>javascript/auto</code>。</p>
<p>webpack 后续的开发计划会增加对更多模块类型的支持，例如极其常见的 CSS 和 HTML 模块类型，这个特性值得我们期待一下。</p>
<h2 id="使用loader配置"><a href="#使用loader配置" class="headerlink" title="使用loader配置"></a>使用loader配置</h2><hr>
<p>当然，在当前版本的 webpack 中，<code>module.rules</code> 的匹配规则最重要的还是用于配置 loader，我们可以使用 <code>use</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.less/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      <span class="string">'style-loader'</span>, <span class="comment">// 直接使用字符串表示 loader</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;, <span class="comment">// 用对象表示 loader，可以传递 loader 配置等</span></span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">'less-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          noIeCompat: <span class="literal">true</span></span><br><span class="line">        &#125;, <span class="comment">// 传递 loader 配置</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>我们看下上述的例子，先忽略laoder的使用情况，单纯看看如何配置。<code>use</code>字段可以是一个数组，也可以是一个自负串或者loader的对象，也可以是这样<code>use: { loader: &#39;babel-loader&#39;, options: { ... } }</code></p>
<p>我们还可以使用<code>options</code>给对应的loader传递一些配置，这里不再展开。当你使用一些 loader 时，loader 的说明一般都有相关配置的描述。</p>
<h2 id="loader应用顺序"><a href="#loader应用顺序" class="headerlink" title="loader应用顺序"></a>loader应用顺序</h2><hr>
<p>一个匹配规则中可以配置使用多个 loader，即一个模块文件可以经过多个 loader 的转换处理，执行顺序是从最后配置的 loader 开始，一步步往前。例如，对于上面的 <code>less</code> 规则配置，一个 style.less 文件会途径 less-loader、css-loader、style-loader 处理，成为一个可以打包的模块。</p>
<p>loader的应用顺序在配置多个loader一起工作时很重要，通常会使用在CSS配置上，除了style-loader和CSS-loader，你可能还要配置less-loader然后再加个postcss的autoprefixe等。</p>
<p>上述从后到前的顺序是在同一个 rule 中进行的，那如果多个 rule 匹配了同一个模块文件，loader 的应用顺序又是怎样的呢？看一份这样的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"eslint-loader"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"babel-loader"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>这样无法保证eslint-loader在babel-loader之前执行。webpack在<code>rules</code>中提供一个<code>enforce</code>的字段来配置当前rule的loader类型，没配置的话是普通类型，我们可以配置<code>pre</code>或<code>post</code>，分别对应前置类型或后置类型的loader</p>
<blockquote>
<p>eslint-loader要检查的时人工便携的代码，如果在babel-loader之后使用，那么检查的时Babel转换之后的代码，所以必须在babel-loader处理之前使用。</p>
</blockquote>
<p>还有一种行内loader，即我们在应用代码中引用依赖时直接声明使用的loader，如<code>const json = require(&#39;json-loader!./file.json&#39;)</code>这种。不建议在应用开发中使用这种 loader。</p>
<p>顾名思义，所有的 loader 按照前置 -&gt; 行内 -&gt; 普通 -&gt; 后置的顺序执行。所以当我们要确保 eslint-loader 在 babel-loader 之前执行时，可以如下添加 <code>enforce</code> 配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    enforce: <span class="string">'pre'</span>, <span class="comment">// 指定为前置类型</span></span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">    loader: <span class="string">"eslint-loader"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>当项目文件类型和应用的 loader 不是特别复杂的时候，通常建议把要应用的同一类型 loader 都写在同一个匹配规则中，这样更好维护和控制。</p>
<h2 id="使用noParse"><a href="#使用noParse" class="headerlink" title="使用noParse"></a>使用noParse</h2><hr>
<p>在webpack中，我们需要使用loader实在<code>module.rules</code>下配置的，webpack 配置中的 module 用于控制如何处理项目中不同类型的模块。</p>
<p>除了<code>module.rules</code>字段用于配置loader之外，还有一个<code>module.noParse</code>字段，可以用于配置哪些模块文件的内容不需要进行解析。对于一些不需要解析依赖（即无依赖） 的第三方大型类库等，可以通过这个字段来配置，以提高整体的构建速度。</p>
<blockquote>
<p>使用 noParse 进行忽略的模块文件中不能使用 import、require、define 等导入机制。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    noParse: <span class="regexp">/jquery|lodash/</span>, <span class="comment">// 正则表达式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者使用 function</span></span><br><span class="line">    noParse(content) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/jquery|lodash/</span>.test(content)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>noParse</code>从某种程度上来说是个优化配置项，日常可以不用去考虑。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/配置loader/">配置loader</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/25/webpack-之三/" title="webpack 之三" itemprop="url">webpack 之三</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-06-24T18:28:02.000Z" itemprop="datePublished"> Published 2018-06-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="webpack-如何解析代码模块路径"><a href="#webpack-如何解析代码模块路径" class="headerlink" title="webpack 如何解析代码模块路径"></a>webpack 如何解析代码模块路径</h2><hr>
<p>在 webpack 支持的前端代码模块化中，我们可以使用类似 import * as m from ‘./index.js’ 来引用代码模块 index.js。</p>
<p>引用第三方类库则是像这样：import React from ‘react’。webpack 构建的时候，会解析依赖后，然后再去加载依赖的模块文件，那么 webpack 如何将上述编写的 ./index.js 或 react 解析成对应的模块文件路径呢？</p>
<blockquote>
<p>在 JavaScript 中尽量使用 ECMAScript 2015 Modules 语法来引用依赖。</p>
</blockquote>
<p>webpack 中有一个很关键的模块 enhanced-resolve 就是处理依赖模块路径的解析的，这个模块可以说是 Node.js 那一套模块路径解析的增强版本，有很多可以自定义的解析配置。</p>
<blockquote>
<p>不熟悉 Node.js 模块路径解析机制的同学可以参考这篇文章：深入 Node.js 的模块机制。</p>
</blockquote>
<h2 id="解析模块规则"><a href="#解析模块规则" class="headerlink" title="解析模块规则"></a>解析模块规则</h2><hr>
<p>我们简单整理一下基本的模块解析规则，以便更好地理解后续 webpack 的一些配置会产生的影响。</p>
<ul>
<li><p>解析相对路径<br>  1.查找相对当前模块路径下是否有对应的文件或文件夹<br>  2.是文件则直接加载<br>  3.是文件夹则继续查找文件夹下的 package.json 文件<br>  4.有 package.json 文件则按照文件中 main 字段的文件名来查找文件<br>  5.无 package.json 或者无 main 字段则查找 index.js 文件</p>
</li>
<li><p>解析模块名<br>查找当前文件目录下，父级目录及以上目录下的 node_modules 文件夹，看是否有对应名称的模块    </p>
</li>
<li>解析绝对路径（不建议使用）<br>直接查找对应路径的文件</li>
</ul>
<p>在webpack配置中，和模块路径解析相关的配置都在<code>resolve</code>字段下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常用的一些配置"><a href="#常用的一些配置" class="headerlink" title="常用的一些配置"></a>常用的一些配置</h2><hr>
<p>我们先从一些简单的需求来阐述 webpack 可以支持哪些解析路径规则的自定义配置。</p>
<p><code>resolve.alias</code><br>假设我们有个 <code>utils</code> 模块极其常用，经常编写相对路径很麻烦，希望可以直接 <code>import &#39;utils&#39;</code> 来引用，那么我们可以配置某个模块的别名，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  utils: path.resolve(__dirname, <span class="string">'src/utils'</span>) <span class="comment">// 这里使用 path.resolve 和 __dirname 来获取绝对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的配置是模糊匹配，意味着只要模块路径中携带了 utils 就可以被替换掉，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'utils/query.js'</span> <span class="comment">// 等同于 import '[项目绝对路径]/src/utils/query.js'</span></span><br></pre></td></tr></table></figure>
<p>如果需要进行精确匹配可以使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias: &#123;</span><br><span class="line">  utils$: path.resolve(__dirname, <span class="string">'src/utils'</span>) <span class="comment">// 只会匹配 import 'utils'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多匹配相关的写法可以参考官方文档 <code>Resolve Alias</code>，这里不一一举例说明。</p>
<blockquote>
<p>resolve.extensions</p>
</blockquote>
<p>看到数组中配置的字符串大概就可以猜到，这个配置的作用是和文件后缀名有关的。是的，这个配置可以定义在进行模块路径解析时，webpack 会尝试帮你补全那些后缀名来进行查找，例如有了上述的配置，当你在 src/utils/ 目录下有一个 common.js 文件时，就可以这样来引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> common <span class="keyword">from</span> <span class="string">'./src/utils/common'</span></span><br></pre></td></tr></table></figure>
<p>webpack 会尝试给你依赖的路径添加上 <code>extensions</code> 字段所配置的后缀，然后进行依赖路径查找，所以可以命中 src/utils/common.js 文件。</p>
<p>但如果你是引用 src/styles 目录下的 common.css 文件时，如 <code>import &#39;./src/styles/common&#39;</code>，webpack 构建时则会报无法解析模块的错误。</p>
<p>你可以在引用时添加后缀，<code>import &#39;./src/styles/common.css&#39;</code> 来解决，或者在 extensions 添加一个 .css 的配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extensions: [<span class="string">'.wasm'</span>, <span class="string">'.mjs'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>, <span class="string">'.css'</span>],</span><br></pre></td></tr></table></figure>
<p><code>resolve.modules</code></p>
<p>前面的内容有提到，对于直接声明依赖名的模块（如 react ），webpack 会类似 Node.js 一样进行路径搜索，搜索 node_modules 目录，这个目录就是使用 resolve.modules 字段进行配置的，默认就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [<span class="string">'node_modules'</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>通常情况下，我们不会调整这个配置，但是如果可以确定项目内所有的第三方依赖模块都是在项目根目录下的 node_modules 中的话，那么可以在 node_modules 之前配置一个确定的绝对路径：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    path.resolve(__dirname, <span class="string">'node_modules'</span>), <span class="comment">// 指定当前目录下的 node_modules 优先查找</span></span><br><span class="line">    <span class="string">'node_modules'</span>, <span class="comment">// 如果有一些类库是放在一些奇怪的地方的，你可以添加自定义的路径或者目录</span></span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这样配置在某种程度上可以简化模块的查找，提升构建速度。</p>
<p><code>resolve.mainFields</code></p>
<p>&lt; 4. 由package.json 文件则按照文件中 main 字段的文件名来查找文件</p>
<p>我们之前有提过这么一句话，其实确切的情况并不是这样的，webpack的<code>resolve.mainFields</code> 配置可以进行调整，当引用的是一个模块或者一个目录时，会使用 package.json 文件的哪一个字段下指定的文件，默认的配置是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  <span class="comment">// 配置 target === "web" 或者 target === "webworker" 时 mainFields 默认值是：</span></span><br><span class="line">  mainFields: [<span class="string">'browser'</span>, <span class="string">'module'</span>, <span class="string">'main'</span>],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// target 的值为其他时，mainFields 默认值为：</span></span><br><span class="line">  mainFields: [<span class="string">"module"</span>, <span class="string">"main"</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>因为通常情况下，模块的package都不会声明<code>browswer</code>或<code>module</code>字段，所以使用的是<code>main</code>了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  mainFiles: [<span class="string">'index'</span>], <span class="comment">// 你可以添加其他默认使用的文件名</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>通常情况下我们也无需修改这个配置，index.js基本就是约定俗成的了。</p>
<p><code>resolve.resolveLoader</code></p>
<p>这个字段<code>resolve.resolveLoader</code>用于配置解析loader时的resolve配置，原本 resolve 的配置项在这个字段下基本都有。我们看下默认的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    mainFields: [<span class="string">'loader'</span>, <span class="string">'main'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这里提供的配置相对少用，我们一般遵从标准的使用方式，使用默认配置，然后把 loader 安装在项目根路径下的 node_modules 下就可以了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/webpack-如何解析模块代码路径/">webpack 如何解析模块代码路径</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/06/21/webpack-之二/" title="webpack 搭建前端开发环境之二" itemprop="url">webpack 搭建前端开发环境之二</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-06-21T13:11:15.000Z" itemprop="datePublished"> Published 2018-06-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <hr>
<h2 id="搭建基本的前端开发环境"><a href="#搭建基本的前端开发环境" class="headerlink" title="搭建基本的前端开发环境"></a>搭建基本的前端开发环境</h2><p>我们把日常开发的需求列一下:</p>
<ul>
<li>构建我们发布需要的 HTML、CSS、JS 文件</li>
<li>使用 CSS 预处理器来编写样式</li>
<li>处理和压缩图片</li>
<li>使用babel来支持ES新特性</li>
<li>本地提供静态服务来开发调试</li>
</ul>
<h2 id="关联HTML"><a href="#关联HTML" class="headerlink" title="关联HTML"></a>关联HTML</h2><hr>
<p>webpack默认作为入口的是.js文件进行构建的（更多的是基于SPA）来考虑，但通常一个前端项目都是从一个页面（即 HTML）出发的，最简单的方法是，创建一个 HTML 文件，使用 script 标签直接引用构建好的 JS 文件，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是，如果我们的文件名或者路径发生变化，例如使用【hash】来进行命名，那么最好讲HTML引用的路径和我们的构建结果关联起来，这个时候可以使用<code>html-webpack-plugin</code></p>
<p><code>html-webpack-plugin</code>是一个独立的node package,所以在使用之前我们应该先安装它，安装到项目依赖的开发中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -D </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line">yarn add html-webpack-plugin -D</span><br></pre></td></tr></table></figure>
<p>然后在webpack配置中奖html-webapck-plugin添加到liugin列表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样配置好之后，构架时html-wabpack-plugin会为我们创建一个HTML文件，其中引用构建出来的JS文件。实际项目中，默认创建的HTML模版：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'assets/index.html'</span>, <span class="comment">// 配置文件模板</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，通过html-webpack-plugin就可以将我们的页面和构建的JS关联起来，回归日常，从页面开始开发，如需要添加多个关联页面，纳闷实例化多个html-webpack-plgin，并讲他们都放到plugins字段数组中就可以了。</p>
<p>参考文档<code>html-webpack-plugin</code>以及官方提供的例子<code>html-webpack-plugin/examples</code>.</p>
<h2 id="构建CSS"><a href="#构建CSS" class="headerlink" title="构建CSS"></a>构建CSS</h2><p>我们编写CSS，并且希望使用webpack来进行构建，为此，需要在配置中引入loader来解析和处理CSS文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      // ...</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.css/,</span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, &apos;src&apos;),</span><br><span class="line">        ],</span><br><span class="line">        use: [</span><br><span class="line">          &apos;style-loader&apos;,</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style-loader 和 css-loader 都是单独的 node package，需要安装。</span><br></pre></td></tr></table></figure>
<p>我们创建一个index.css文件，并在index.js中引用它，然后进行构建。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./index.css"</span></span><br></pre></td></tr></table></figure>
<p>可以发现，构建出来的CSS，先来看下两个loader的作用：</p>
<ul>
<li>css-loader负责解析CSS代码，主要是为了处理CSS中的依赖例如<code>@import</code>和<code>url()</code>等引用外部文件的声明。</li>
<li>style-loader会讲css-loader解析的解惑转变为JS代码，运行是动态插入<code>style</code>标签来让CSS生效。</li>
</ul>
<p>经由上述两个loader的处理后，Css代码会转变位JS，和index.js。如果需要单独把CSS文件分离出来，我们需要使用<code>extract-text-webpack-plugin</code>插件。</p>
<p>extract-text-webpack-plugin 这个插件在笔者写作时并未发布支持 webpack 4.x 的正式版本，所以安装的时候需要指定使用它的 alpha 版本：npm install extract-text-webpack-plugin@next -D 或者 yarn add extract-text-webpack-plugin@next -D。如果你用的是 webpack 3.x 版本，直接用 extract-text-webpack-plugin 现有的版本即可。</p>
<p>看一个简单的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123; </span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;), </span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 引入插件，配置文件名，这里同样可以使用 [hash]</span></span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(<span class="string">'index.css'</span>),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS-预处理"><a href="#CSS-预处理" class="headerlink" title="CSS 预处理"></a>CSS 预处理</h2><hr>
<p>在上述使用的CSS基础上，通常我们会使用Less/Sass等CSS预处理器，webpack可以通过添加对应的loader来支持。以使用Less为例，我们可以在官方文档中找到对应的<code>loader</code>。</p>
<p>我们需要在上面的webpack配置中，添加一个配置来支持后缀为.less的文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        <span class="comment">// 因为这个插件需要干涉模块转换的内容，所以需要使用它对应的 loader</span></span><br><span class="line">        use: ExtractTextPlugin.extract(&#123; </span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="string">'css-loader'</span>, </span><br><span class="line">            <span class="string">'less-loader'</span>,</span><br><span class="line">          ],</span><br><span class="line">        &#125;), </span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="处理图片文件"><a href="#处理图片文件" class="headerlink" title="处理图片文件"></a>处理图片文件</h2><hr>
<p>在前端项目的样式中总会使用到图片，虽然已经提到了css-loader回解析样式中的url（）引用的文件的路径，但是图片对应的jpg/png/gif等文件格式，webpack处理不了我们只要添加一个处理图片的 loader 配置就可以了，现有的 file-loader 就是个不错的选择。</p>
<p>file-loader 可以用于处理很多类型的文件，它的主要作用是直接输出文件，把构建后的文件路径返回。配置很简单，在 rules中添加一个字段，增加图片类型文件的解析配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.(png|jpg|gif)$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &apos;file-loader&apos;,</span><br><span class="line">            options: &#123;&#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Babel"><a href="#使用Babel" class="headerlink" title="##使用Babel"></a>##使用Babel</h2><p>Babel 是一个让我们能够使用 ES 新特性的 JS 编译工具，我们可以在 webpack 中配置 Babel，以便使用 ES6、ES7 标准来编写 JS 代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>, <span class="comment">// 支持 js 和 jsx</span></span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">'src'</span>), <span class="comment">// src 目录下的才需要经过 babel-loader 处理</span></span><br><span class="line">        ],</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Babel 的相关配置可以在目录下使用 .babelrc 文件来处理，详细参考 Babel 官方文档 .babelrc。</p>
<h2 id="启动静态服务"><a href="#启动静态服务" class="headerlink" title="启动静态服务"></a>启动静态服务</h2><hr>
<p>至此，我们完成了处理多种文件的webpack配置。我们可以使用 webpack-dev-server 在本地开启一个简单的静态服务来进行开发。</p>
<p>在项目下安装 webpack-dev-server，然后添加启动命令到 package.json 中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "webpack --mode production",</span><br><span class="line">  "start": "webpack-dev-server --mode development"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以全局安装 webpack-dev-server，但通常建议以项开发依赖的方式进行安装，然后在 npm package 中添加启动脚本。</p>
</blockquote>
<p>尝试着运行 <code>npm run start</code> 或者 <code>yarn start</code>，然后就可以访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 来查看你的页面了。默认是访问 index.html，如果是其他页面要注意访问的 URL 是否正确。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr>
<p>我们现在已经可以使用 webpack 来完成日常中需要的基础前端构建需求：构建 HTML、CSS、JS 文件、使用 CSS 预处理器来编写样式、处理和压缩图片、使用 Babel、方便开发调试的静态服务，接下来的小节会在这个基础上，深入 webpack 配置细节，结合实际工作中的一些需要，更进一步地了解 webpack 的使用。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/webpack搭建前端基本环境/">webpack搭建前端基本环境</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/24/webpack/" title="webpack 基本使用一" itemprop="url">webpack 基本使用一</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-05-24T02:35:23.000Z" itemprop="datePublished"> Published 2018-05-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <hr>
<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><p>webpack 是一个 JS 代码模块化的打包工具，藉由它强大的扩展能力，随着社区的发展，逐渐成为一个功能完善的构建工具。相信开始学习这小册的同学们多多少少都能够理解为什么前端开发中会使用到 webpack，我们不再详细介绍 webpack 的使用背景，直奔本主题…</p>
<hr>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p>我们使用 npm 或者 yarn 来安装 webpack，可以作为一个全局的命令来使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webpack webpack-cli -g </span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line">yarn global add webpack webpack-cli</span><br><span class="line"><span class="meta">#</span> 然后就可以执行全局命令了</span><br></pre></td></tr></table></figure>
<p>webpack-cli 是使用 webpack 的命令行工具，在 4.x 版本之后不再作为 webpack 的依赖了，我们使用时需要单独安装这个工具。</p>
<p>在项目中，我们更多地会把 webpack 作为项目的开发依赖来安装使用，这样可以指定项目中使用的 webpack 版本，更加方便多人协同开发：</p>
<blockquote>
<p>确保你的项目中有 package.json 文件，如果没有可以使用 npm init 来创建。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack -D </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line">yarn add webpack -D</span><br></pre></td></tr></table></figure>
<hr>
<p>这样 webpack 会出现在 package.json 中，我们再添加一个 npm scripts：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "webpack --mode production"</span><br><span class="line">  &#125;,</span><br><span class="line">  "devDependencies": &#123;</span><br><span class="line">    "webpack": "^4.1.1",</span><br><span class="line">    "webpack-cli": "^2.0.12",</span><br><span class="line">  &#125;...</span><br></pre></td></tr></table></figure>
<p>然后我们创建一个 <code>./src/index.js</code> 文件，可以写任意的 JS 代码。创建好了之后执行 <code>npm run build</code> 或者 <code>yarn build</code> 命令，你就会发现新增了一个 <code>dist</code> 目录，里边存放的是 <code>webpack</code> 构建好的 <code>main.js</code> 文件。…</p>
<p>因为是作为项目依赖进行安装，所以不会有全局的命令，<code>npm/yarn</code> 会帮助我们在当前项目依赖中寻找对应的命令执行，如果是全局安装的 <code>webpack</code>，直接执行 <code>webpack --mode production</code> 就可以。</p>
<p>webpack 4.x 的版本可以零配置就开始进行构建，但是笔者觉得这个功能还不全面，缺少很多实际项目需要的功能，所以基本你还是需要一个配置文件，后边会详细讲解。</p>
<p>我们先来了解 webpack 中的一些基本概念</p>
<h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>webpack 会读取这个文件，并从它开始解析依赖，然后进行打包。一开始我们使用 webpack 构建时，默认的入口文件就是 <code>./src/index.js</code>。</p>
<p>我们常见的项目中，如果是单页面应用，那么可能入口只有一个；如果是多个页面的项目，那么经常是一个页面会对应一个构建入口。</p>
<p>入口可以使用 <code>entry</code> 字段来进行配置，<code>webpack</code> 支持配置多个入口来进行构建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述配置等同于</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者配置多个入口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: <span class="string">'./src/page-foo.js'</span>,</span><br><span class="line">    bar: <span class="string">'./src/page-bar.js'</span>, </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组来对多个文件进行打包</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: [</span><br><span class="line">      <span class="string">'./src/foo.js'</span>,</span><br><span class="line">      <span class="string">'./src/bar.js'</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>
<p>最后的例子，可以理解为多个文件作为一个入口，webpack 会解析两个文件的依赖后进行打包。</p>
<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p><code>webpack</code> 中提供一种处理多种文件格式的机制，便是使用 <code>loader</code>。我们可以把 <code>loader</code> 理解为是一个转换器，负责把某种文件格式的内容转换成 <code>webpack</code> 可以支持打包的模块。</p>
<p>举个例子，在没有添加额外插件的情况下，<code>webpack</code> 会默认把所有依赖打包成 <code>js</code> 文件，如果入口文件依赖一个 .hbs 的模板文件以及一个 <code>.css</code> 的样式文件，那么我们需要 <code>handlebars-loader</code> 来处理 <code>.hbs</code> 文件，需要 <code>css-loader</code> 来处理 <code>.css</code> 文件（这里其实还需要 <code>style-loader</code>，后续详解），最终把不同格式的文件都解析成 <code>js</code> 代码，以便打包后在浏览器中运行。</p>
<p>当我们需要使用不同的 <code>loader</code> 来解析处理不同类型的文件时，我们可以在 <code>module.rules</code> 字段下来配置相关的规则，例如使用 Babel 来处理 <code>.js</code> 文件：…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.jsx?/</span>, <span class="comment">// 匹配文件路径的正则表达式，通常我们都是匹配文件类型后缀</span></span><br><span class="line">      include: [</span><br><span class="line">        path.resolve(__dirname, <span class="string">'src'</span>) <span class="comment">// 指定哪些路径下的文件需要经过 loader 处理</span></span><br><span class="line">      ],</span><br><span class="line">      use: <span class="string">'babel-loader'</span>, <span class="comment">// 指定使用的 loader</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>
<h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>在 <code>webpack</code> 的构建流程中，<code>plugin</code> 用于处理更多其他的一些构建任务。可以这么理解，模块代码转换的工作由 <code>loader</code>来处理，除此之外的其他任何工作都可以交由 <code>plugin</code> 来完成。通过添加我们需要的 <code>plugin</code>，可以满足更多构建中特殊的需求。例如，要使用压缩 JS 代码的 <code>uglifyjs-webpack-plugin</code> 插件，只需在配置中通过 plugins 字段添加新的 <code>plugin</code> 即可：…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyPlugin()</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>webpack 的输出即指 webpack 最终构建出来的静态文件，可以看看上面 webpack 官方图片右侧的那些文件。当然，构建结果的文件名、路径等都是可以配置的，使用  <code>output</code> 字段：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者多个入口生成不同文件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    foo: <span class="string">'./src/foo.js'</span>,</span><br><span class="line">    bar: <span class="string">'./src/bar.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径中使用 hash，每次构建时会有一个不同 hash 值，避免发布新版本时线上使用浏览器缓存</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist/[hash]'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>
<p>我们一开始直接使用 webpack 构建时，默认创建的输出内容就是 ./dist/main.js。</p>
<h2 id="一个简单的-webpack-配置"><a href="#一个简单的-webpack-配置" class="headerlink" title="一个简单的 webpack 配置"></a>一个简单的 webpack 配置</h2><hr>
<p>我们把上述涉及的几部分配置内容合到一起，就可以创建一个简单的 webpack 配置了，webpack 运行时默认读取项目下的 <code>webpack.config.js</code> 文件作为配置。</p>
<p>所以我们在项目中创建一个 <code>webpack.config.js</code> 文件：…</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">        ],</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代码模块路径解析的配置</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    modules: [</span><br><span class="line">      <span class="string">"node_modules"</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    extensions: [<span class="string">".wasm"</span>, <span class="string">".mjs"</span>, <span class="string">".js"</span>, <span class="string">".json"</span>, <span class="string">".jsx"</span>],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyPlugin(), </span><br><span class="line">    <span class="comment">// 使用 uglifyjs-webpack-plugin 来压缩 JS 代码</span></span><br><span class="line">    <span class="comment">// 如果你留意了我们一开始直接使用 webpack 构建的结果，你会发现默认已经使用了 JS 代码压缩的插件</span></span><br><span class="line">    <span class="comment">// 这其实也是我们命令中的 --mode production 的效果，后续的小节会介绍 webpack 的 mode 参数</span></span><br><span class="line">  ],</span><br><span class="line">&#125;...</span><br></pre></td></tr></table></figure>
<p>webpack 的配置其实是一个 Node.js 的脚本，这个脚本对外暴露一个配置对象，webpack 通过这个对象来读取相关的一些配置。因为是 Node.js 脚本，所以可玩性非常高，你可以使用任何的 Node.js 模块，如上述用到的 path 模块，当然第三方的模块也可以。</p>
<p>创建了 webpack.config.js 后再执行 webpack 命令，webpack 就会使用这个配置文件的配置了。</p>
<p>有的时候我们开始一个新的前端项目，并不需要从零开始配置 webpack，而可以使用一些工具来帮助快速生成 webpack 配置。…</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><hr>
<p>webpack 的安装和使用和大多数使用 Node.js 开发的命令行工具一样，使用 npm 安装后执行命令即可，webpack 4.x 版本的零配置特性也让上手变得更加简单。</p>
<p>前面我们已经介绍了 webpack 的几个重要的概念：入口，loader，plugin，输出，并且展示了一个简单的 webpack 配置例子，最后提供了前端社区三大框架基于 webpack 的脚手架工具的链接，也许这些工具提供的配置会比较难懂，后续的小节会帮助你逐渐去深入，慢慢地，你会对 webpack 配置越来越得心应手。…</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/webpack的使用方法/">webpack的使用方法</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/webpack-如何解析模块代码路径/" title="webpack 如何解析模块代码路径">webpack 如何解析模块代码路径<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack搭建前端基本环境/" title="webpack搭建前端基本环境">webpack搭建前端基本环境<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/使用Plugin/" title="使用Plugin">使用Plugin<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/配置loader/" title="配置loader">配置loader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack的使用方法/" title="webpack的使用方法">webpack的使用方法<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="xxinso">xxinso</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
