
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="xxinso">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/01/正则表达式/" title="正则表达式" itemprop="url">正则表达式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-06-30T16:34:42.000Z" itemprop="datePublished"> Published 2018-07-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>每次遇到正则的时候都会百度去查找，浪费了很多时间后总是下决心要把正则学会，可是下决心时下决心，做起来又很难，这次下了狠心决定来认认真真学习一下正则</p>
<h3 id="新建正则表达式"><a href="#新建正则表达式" class="headerlink" title="新建正则表达式"></a>新建正则表达式</h3><p>方式一：直接量语法</p>
<p>var reg = /pattern/attributes</p>
<p>方式二：创建RegExp对象语法</p>
<p> var reg = new RegExp(pattern, attributes);</p>
<p>参数说明：</p>
<p>参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。</p>
<p>参数 attributes 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。</p>
<p>两者区别在于：<br>1.采用直接量语法新建的正则表达式对象在代码编译时就会生成，式采用开发常用的方式；<br>2.采用正则构造函数生成的正则对象要在代码运行时生成</p>
<p>正则表达式用于：</p>
<p>正则对象的方法是指这样使用的： RegExp对象.方法(字符串) </p>
<p>字符串对象的方法是这样使用：字符串.方法(RegExp对象)</p>
<h2 id="正则表达式的属性和方法"><a href="#正则表达式的属性和方法" class="headerlink" title="正则表达式的属性和方法"></a>正则表达式的属性和方法</h2><p>属性</p>
<p>gnoreCase 返回布尔值，表示RegExp 对象是否具有标志 i<br>global 返回布尔值，表示RegExp对象是否具有标志g<br>multiline 返回布尔值，表示RegExp 对象是否具有标志 m<br>lastIndex 一个整数，标识开始下一次匹配的字符位置<br>source 返回正则表达式的源文本（不包括反斜杠）</p>
<p>i 执行对大小写不敏感的匹配</p>
<p>g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</p>
<p>m 执行多行匹配</p>
<p>正则表达时的作用</p>
<p>通常作用于两种任务：</p>
<p>1.验证</p>
<p>用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串；</p>
<p>2.搜索替换<br>搜索/替换时是否加上此限定则根据搜索的需求而定，此外，也有可能要在前后加上\b而不是^和$</p>
<p>字符类匹配</p>
<p>[…] 查找方括号之间的任何字符<br>[^…] 查找任何不在方括号之间的字符<br>[a-z] 查找任何从小写 a 到小写 z 的字符<br>[A-Z] 查找任何从大写 A 到大写 Z 的字符<br>[A-z] 查找任何从大写 A 到小写 z 的字符<br>. 查找单个字符，除了换行和行结束符<br>\w 查找单词字符，等价于[a-zA-Z0-9]<br>\W 查找非单词字符，等价于[^a-zA-Z0-9]<br>\s 查找空白字符<br>\S 查找非空白字符<br>\d 查找数字，等价于[0-9]<br>\D 查找非数字字符，等价于[^0-9]<br>\b 匹配单词边界<br>\r 查找回车<br>\t 查找制表符<br>\0 查找NULL字符<br>\n 查找换行符</p>
<p>重复字符匹配</p>
<p>{n,m} 匹配前一项至少n次，但不能超过m次<br>{n,}  匹配一项n次或更多次<br>{n}   匹配前一项n次<br>n？    匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1}<br>n+ 匹配前一项1次或多次，等价于{1，}<br>n* 匹配前一项0次或多次，等价于{0，}<br>^n 匹配任何开头以n的字符串<br>？= n 匹配任何其后紧接着指定字符串n的字符串<br>？！n 匹配任何其后没有紧接着指定字符串n的字符串</p>
<p>匹配特定数字<br>^[1-9]\d<em>$ 匹配正整数<br>^-[1-9]\d</em>$ 匹配负整数<br>^-?[0-9]\d<em>$ 匹配整数<br>^[1-9]\d</em>|0$ 匹配非负整数（）</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/正则表达式总结/">正则表达式总结</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/28/来谈谈better-scroll/" title="Vue中better-scroll" itemprop="url">Vue中better-scroll</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-05-28T15:53:50.000Z" itemprop="datePublished"> Published 2018-05-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="什么是-better-scroll"><a href="#什么是-better-scroll" class="headerlink" title="什么是 better-scroll"></a>什么是 better-scroll</h2><hr>
<p>better-scroll 是一个移动端滚动的解决方案，它是基于 iscroll 的重写，它和 iscroll 的主要区别在这里。better-scroll 也很强大，不仅可以做普通的滚动列表，还可以做轮播图、picker 等等。</p>
<h3 id="better-scroll的滚动原理"><a href="#better-scroll的滚动原理" class="headerlink" title="better-scroll的滚动原理"></a>better-scroll的滚动原理</h3><p>不少同学可能用过 better-scroll，我收到反馈最多的问题是：</p>
<blockquote>
<p>我的better-scroll初始化了，但是没法滚动</p>
</blockquote>
<p>不能滚动是现象，我们得搞清楚其中的根本原因。在这之前，我们先来看看浏览器的滚动原理</p>
<p>浏览器的滚动条大家都会遇到，当页面内容的高度超过视口高度的时候，会出现纵项滚动条；当页面内容的高度超过视<br>口宽度的时候，回出现横向滚动条，也就是当我们的视口展示不下内容的时候，回通过滚动条的方式让用户滚动屏幕看到剩余的内容。</p>
<p>那么对于better-scroll也是一样的道理，我们先来看一下better-scroll常见的html结构</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span> <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span> ... </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。</p>
<p>那么，我们怎么初始化 better-scroll 呢，如果是上述 html 结构，那么初始化代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">'better-scroll'</span> <span class="keyword">let</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)<span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(wrapper, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>better-scroll 对外暴露了一个 BScroll 的类，我们初始化只需要 new 一个类的实例即可。第一个参数就是我们 wrapper 的 DOM 对象，第二个是一些配置参数，具体参考 better-scroll 的文档。</p>
<p>better-scroll的初始化时机很重要，因为它在初始化的时候，回计算氟元素和子元素的高度和宽度，来决定是否可以纵向或者横向滚动。因此，我们在初始化的时候，必须确保父元素和子元素已经正确渲染了。如果子元素或者父元素DOM结构发生改变，必须用scroll.refresh()方法重新计算来确保滚动效果正常。所以同学们反馈的better-scroll不能滚动的问题多半是因为初始化的时机不对，或者是当DOM结构发生变化的时候并没有重新计算beter-scroll。</p>
<h2 id="better-scroll遇见Vue"><a href="#better-scroll遇见Vue" class="headerlink" title="better-scroll遇见Vue"></a>better-scroll遇见Vue</h2><p>相信很多同学对 Vue.js 都不陌生，当 better-scroll 遇见 Vue，会擦出怎样的火花呢？</p>
<h3 id="如何在-Vue-中使用-better-scroll"><a href="#如何在-Vue-中使用-better-scroll" class="headerlink" title="如何在 Vue 中使用 better-scroll"></a>如何在 Vue 中使用 better-scroll</h3><p>很多同学开始接触使用 better-scroll 都是受到了我的一门教学课程——《Vue.js高仿饿了么外卖App》 的影响。在那门课程中，我们把 better-scroll 和 Vue 做了结合，实现了很多列表滚动的效果。在 Vue 中的使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">    &lt;div class=&quot;wrapper&quot; ref=&quot;wrapper&quot;&gt; </span><br><span class="line">        &lt;ul class=&quot;content&quot;&gt; </span><br><span class="line">            &lt;li&gt;...&lt;/li&gt; </span><br><span class="line">            &lt;li&gt;...&lt;/li&gt;</span><br><span class="line">             ... </span><br><span class="line">        &lt;/ul&gt; </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/template&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">import BScroll from &apos;better-scroll&apos; </span><br><span class="line">    export default &#123; </span><br><span class="line">        mounted() &#123; </span><br><span class="line">            this.$nextTick(() =&gt; &#123; this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;) </span><br><span class="line">                &#125;) </span><br><span class="line">               &#125; </span><br><span class="line">            &#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>Vue.js提供了我们一个获取DOM对象的接口–vm.refs。在这里，我们通过<code>this.$refs.wrapper</code>访问到这个DOM对象，并且我们在mounted这个钩子函数里，<code>this.$nextTick</code>的回掉函数里初始化better-scroll。因为这个时候，wrapper的DOM已经渲染了，我们可以正确计算它以及它内层contend的高度，1⃣以确保可以正常滚动。</p>
<p>这里的 <code>this.$nextTick</code> 是一个异步函数，为了确保 DOM 已经渲染，感兴趣的同学可以了解一下它的内部实现细节，底层用到了 MutationObserver 或者是 <code>setTimeout(fn, 0)</code>。其实我们在这里把 <code>this.$nextTick</code> 替换成 <code>setTimeout(fn, 20)</code> 也是可以的（20 ms 是一个经验值，每一个 Tick 约为 17 ms），对用户体验而言都是无感知的。</p>
<h3 id="异步数据的处理"><a href="#异步数据的处理" class="headerlink" title="异步数据的处理"></a>异步数据的处理</h3><p>在我们的实际工作中，列表的数据往往都是异步获取的，因此我们初始化 better-scroll 的时机需要在数据获取后，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">created() &#123; </span><br><span class="line">    requestData().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="keyword">this</span>.data = res.data <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.scroll = <span class="keyword">new</span> Bscroll(<span class="keyword">this</span>.$refs.wrapper, &#123;&#125;) </span><br><span class="line">        &#125;) </span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的 requestData 是伪代码，作用就是发起一个 http 请求从服务端获取数据，并且这个函数返回的是一个 promise（实际项目中我们可能会用 axios 或者 vue-resource）。我们获取到数据的后，需要通过异步的方式再去初始化 better-scroll，因为 Vue 是数据驱动的， Vue 数据发生变化（this.data = res.data）到页面重新渲染是一个异步的过程，我们的初始化时机是要在 DOM 重新渲染后，所以这里用到了 this.$nextTick，当然替换成 setTimeout(fn, 20) 也是可以的。</p>
<p>为什么这里在 created 这个钩子函数里请求数据而不是放到 mounted 的钩子函数里？因为 requestData 是发送一个网络请求，这是一个异步过程，当拿到响应数据的时候，Vue 的 DOM 早就已经渲染好了，但是数据改变 —&gt; DOM 重新渲染仍然是一个异步过程，所以即使在我们拿到数据后，也要异步初始化 better-scroll。</p>
<h3 id="数据的动态更新"><a href="#数据的动态更新" class="headerlink" title="数据的动态更新"></a>数据的动态更新</h3><p>我们在实际开发中，除了数据异步获取，还有一些场景可以动态更新列表中的数据，比如常见的下拉加载，上拉刷新等。比如我们用better-scroll配合Vue实现的下拉加载的功能，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;wrapper&quot; ref=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;content&quot;&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;div class=&quot;loading-wrapper&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import BScroll from &apos;better-scroll&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        data: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      this.loadData()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      loadData() &#123;</span><br><span class="line">        requestData().then((res) =&gt; &#123;</span><br><span class="line">          this.data = res.data.concat(this.data)</span><br><span class="line">          this.$nextTick(() =&gt; &#123;</span><br><span class="line">            if (!this.scroll) &#123;</span><br><span class="line">              this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span><br><span class="line">              this.scroll.on(&apos;touchend&apos;, (pos) =&gt; &#123;</span><br><span class="line">                // 下拉动作</span><br><span class="line">                if (pos.y &gt; 50) &#123;</span><br><span class="line">                  this.loadData()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              this.scroll.refresh()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码比之前稍微复杂一些, 当我们在滑动列表松开手指时候， better-scroll 会对外派发一个 touchend 事件，我们监听了这个事件，并且判断了 pos.y &gt; 50（我们把这个行为定义成一次下拉的动作）。如果是下拉的话我们会重新请求数据，并且把新的数据和之前的 data 做一次 concat，也就更新了列表的数据，那么数据的改变就会映射到 DOM 的变化。需要注意的一点，这里我们对 this.scroll 做了判断，如果没有初始化过我们会通过 new BScroll 初始化，并且绑定一些事件，否则我们会调用 this.scroll.refresh 方法重新计算，来确保滚动效果的正常。</p>
<h3 id="scroll组件的抽象和封装"><a href="#scroll组件的抽象和封装" class="headerlink" title="scroll组件的抽象和封装"></a>scroll组件的抽象和封装</h3><p>因此，我们有强烈的需求抽象一个scroll组件，类似小程序scroll-view组件，方便开发者使用</p>
<p>这里我们用到了 Vue 的特殊元素—— slot 插槽，它可以满足我们灵活定制列表 DOM 结构的需求。接下来我们来看看 JS 部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">  import BScroll from &apos;better-scroll&apos;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      probeType: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      click: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: true</span><br><span class="line">      &#125;,</span><br><span class="line">      listenScroll: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default: null</span><br><span class="line">      &#125;,</span><br><span class="line">      pullup: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeScroll: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;,</span><br><span class="line">      refreshDelay: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 20</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        this._initScroll()</span><br><span class="line">      &#125;, 20)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      _initScroll() &#123;</span><br><span class="line">        if (!this.$refs.wrapper) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        this.scroll = new BScroll(this.$refs.wrapper, &#123;</span><br><span class="line">          probeType: this.probeType,</span><br><span class="line">          click: this.click</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        if (this.listenScroll) &#123;</span><br><span class="line">          let me = this</span><br><span class="line">          this.scroll.on(&apos;scroll&apos;, (pos) =&gt; &#123;</span><br><span class="line">            me.$emit(&apos;scroll&apos;, pos)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.pullup) &#123;</span><br><span class="line">          this.scroll.on(&apos;scrollEnd&apos;, () =&gt; &#123;</span><br><span class="line">            if (this.scroll.y &lt;= (this.scroll.maxScrollY + 50)) &#123;</span><br><span class="line">              this.$emit(&apos;scrollToEnd&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.beforeScroll) &#123;</span><br><span class="line">          this.scroll.on(&apos;beforeScrollStart&apos;, () =&gt; &#123;</span><br><span class="line">            this.$emit(&apos;beforeScroll&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      disable() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.disable()</span><br><span class="line">      &#125;,</span><br><span class="line">      enable() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.enable()</span><br><span class="line">      &#125;,</span><br><span class="line">      refresh() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.refresh()</span><br><span class="line">      &#125;,</span><br><span class="line">      scrollTo() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments)</span><br><span class="line">      &#125;,</span><br><span class="line">      scrollToElement() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          this.refresh()</span><br><span class="line">        &#125;, this.refreshDelay)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>可以很明显的看到我们的 JS 部分精简了非常多的代码，没有对 better-scroll 再做命令式的操作了，同时把数据请求和 better-scroll 也做了剥离，父组件只需要把数据 data 通过 prop 传给 scroll 组件，就可以保证 scroll 组件的滚动效果。同时，如果想实现下拉刷新的功能，只需要通过 prop 把 pulldown 设置为 true，并且监听 pulldown 的事件去做一些数据获取并更新的动作即可，整个逻辑也是非常清晰的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Vue中better-scroll/">Vue中better-scroll</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/28/几种移动端很常用的布局/" title="几种移动端很常用的布局" itemprop="url">几种移动端很常用的布局</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-01-28T11:13:08.000Z" itemprop="datePublished"> Published 2018-01-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="左边定宽右边自适应布局"><a href="#左边定宽右边自适应布局" class="headerlink" title="左边定宽右边自适应布局"></a>左边定宽右边自适应布局</h2><hr>
<p>html代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 左边定宽 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 右边自适应 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>方法一：左边设置左浮动，右边宽度设置100%</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">width</span>:<span class="number">100%</span>&#125;</span><br></pre></td></tr></table></figure>
<p>方法二： 父容器设置 display：flex；Right部分设置 flex：1 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    display:flex</span><br><span class="line">&#125;</span><br><span class="line">.right:&#123;</span><br><span class="line">    flex:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三: 设置浮动+在css中使用calc（）函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.left&#123;</span><br><span class="line">    float:left</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    width:calc(<span class="number">100</span>%<span class="number">-200</span>px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【分析】</p>
<ol>
<li><p>浮动。（注意：为了不影响其他元素，别忘了在父级上清除浮动）</p>
</li>
<li><p>calc() = calc(四则运算) 用于在 css 中动态计算长度值，需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</p>
</li>
</ol>
<p>方法四：使用负margin</p>
<p>首先修改页面结构，为自适应部分添加容器 .container, 同时改变左右部分的位置，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        right</span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>:&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子元素根据父元素的宽度来实现子元素的在元素中居中"><a href="#子元素根据父元素的宽度来实现子元素的在元素中居中" class="headerlink" title="子元素根据父元素的宽度来实现子元素的在元素中居中"></a>子元素根据父元素的宽度来实现子元素的在元素中居中</h2><hr>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'father'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'son'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">       <span class="attribute">background</span>: yellow;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: center;</span><br><span class="line">       <span class="attribute">align-items</span>:center;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-class">.son</span>&#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">padding-bottom</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">background</span>: red;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>【分析】</p>
<p> 先对子元素用flex实现上下和左右居中，有父元素的宽度来确定子元素正方形的宽度，宽高都是父元素的二分之一。</p>
<h2 id="几种子元素在父元素中居中水平垂直居中的方式"><a href="#几种子元素在父元素中居中水平垂直居中的方式" class="headerlink" title="几种子元素在父元素中居中水平垂直居中的方式"></a>几种子元素在父元素中居中水平垂直居中的方式</h2><ol>
<li>子元素相对于父元素绝对定位，并且margin值减去自己宽高的一半</li>
</ol>
<h2 id="该方法具有一定的局限性，因为其必须要知道子元素本身的宽高"><a href="#该方法具有一定的局限性，因为其必须要知道子元素本身的宽高" class="headerlink" title="该方法具有一定的局限性，因为其必须要知道子元素本身的宽高"></a>该方法具有一定的局限性，因为其必须要知道子元素本身的宽高</h2> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">item</span>&#123;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">            <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>2.子元素相对于父元素绝对定位，并且margin值位auto</p>
<p>该方式不受元素宽高所限制，比较好用（推荐使用）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="selector-class">.box</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">          <span class="attribute">position</span>: relative;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-tag">item</span>&#123;</span><br><span class="line">           <span class="attribute">position</span>: absolute;</span><br><span class="line">           <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">           <span class="attribute">margin</span>: auto;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">           <span class="attribute">background</span>: green;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>3.diplay：table-cell</p>
<p>该方式是将元素转换成表格样式，再利用表格的样式来进行居中（推荐）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="selector-class">.box</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">           <span class="attribute">display</span>: table-cell;</span><br><span class="line">           <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-tag">item</span>&#123;</span><br><span class="line">           <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">           <span class="attribute">background</span>: green;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>水平垂直居中（四） 绝对定位和transfrom</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">            <span class="attribute">position</span>:relative;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">item</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>5.css3中的flex属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">            <span class="attribute">display</span>: flex;</span><br><span class="line">            <span class="attribute">justify-content</span>: center;</span><br><span class="line">            <span class="attribute">align-items</span>: center;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">item</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/几种移动端很常用的布局/">几种移动端很常用的布局</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/26/webpack-之十三（提升webpack的构建速度）/" title="webpack十二之提升webpack的构建速度" itemprop="url">webpack十二之提升webpack的构建速度</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-11-26T12:48:54.000Z" itemprop="datePublished"> Published 2017-11-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="提升webpack的构建速度"><a href="#提升webpack的构建速度" class="headerlink" title="提升webpack的构建速度"></a>提升webpack的构建速度</h2><hr>
<p>我们的前端项目随着时间推移和业务发展，页面可能会越来越多，或者功能和业务代码会越来越多，又或者依赖的外部类库会越来越多，这个时候原本不足为道的 webpack 构建时间消耗就会慢慢地进入我们的视野。</p>
<p>构建消耗的时间变长了，如果是使用 CI 服务来做构建，大部分情况下我们无须等待，其实影响不大。但是本地的 webpack 开发环境服务启动时的速度和我们日常开发工作息息相关，在一些性能不是特别突出的设备上（例如便携式笔记本等等），启动时的长时间等待可能会让你越来越受不了。</p>
<p>笔者亲身经历的一个项目，使用 webpack 构建的时长可以达到 6 分钟左右，这种场景下，就算用 CI 服务，在遇见需要紧急发布修复问题时，也会让人很抓狂。所以这一小节我们来聊聊如何提升 webpack 的构建速度，也许某一天你负责的项目也会到了需要优化 webpack 构建性能的时候。</p>
<h2 id="让webpack少干点活"><a href="#让webpack少干点活" class="headerlink" title="让webpack少干点活"></a>让webpack少干点活</h2><hr>
<p>提升 webpack 构建速度本质上就是想办法让 webpack 少干点活，活少了速度自然快了，尽量避免 webpack 去做一些不必要的事情。</p>
<h3 id="减少resolve的解析"><a href="#减少resolve的解析" class="headerlink" title="减少resolve的解析"></a>减少<code>resolve</code>的解析</h3><p>我们可以精简 <code>resolve</code>配置，让webpack在查询模块路径时尽可能快速地定位到需要的模块，不做额外的查询工作，那么webpack的构建速度也会快一些，下面举个例子，介绍<code>resolve</code>这一块做优化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    path.resolve(__dirname, <span class="string">'node_modules'</span>), <span class="comment">// 使用绝对路径指定 node_modules，不做过多查询</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除不必要的后缀自动补全，少了文件后缀的自动匹配，即减少了文件路径查询的工作</span></span><br><span class="line">  <span class="comment">// 其他文件可以在编码时指定后缀，如 import('./index.scss')</span></span><br><span class="line">  extensions: [<span class="string">".js"</span>], </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免新增默认文件，编码时使用详细的文件路径，代码会更容易解读，也有益于提高构建速度</span></span><br><span class="line">  mainFiles: [<span class="string">'index'</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>上述是可以从配置 <code>resolve</code> 下手提升 webpack 构建速度的配置例子。</p>
<p>我们在编码时，如果是使用我们自己本地的代码模块，尽可能编写完整的路径，避免使用目录名，如：<code>import &#39;./lib/slider/index.js&#39;</code>，这样的代码既清晰易懂，webpack 也不用去多次查询来确定使用哪个文件，一步到位。</p>
<h2 id="把loader应用的文件范围缩小"><a href="#把loader应用的文件范围缩小" class="headerlink" title="把loader应用的文件范围缩小"></a>把loader应用的文件范围缩小</h2><p>我们在使用 loader 的时候，尽可能把 loader 应用的文件范围缩小，只在最少数必须的代码模块中去使用必要的 loader，例如 node_modules 目录下的其他依赖类库文件，基本就是直接编译好可用的代码，无须再经过 loader 处理了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rules: [ </span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">    include: [ </span><br><span class="line">      path.resolve(__dirname, <span class="string">'src'</span>), </span><br><span class="line">      <span class="comment">// 限定只在 src 目录下的 js/jsx 文件需要经 babel-loader 处理</span></span><br><span class="line">      <span class="comment">// 通常我们需要 loader 处理的文件都是存放在 src 目录</span></span><br><span class="line">    ],</span><br><span class="line">    use: <span class="string">'babel-loader'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>如上边这个例子，如果没有配置 <code>include</code>，所有的外部依赖模块都经过 Babel 处理的话，构建速度也是会收很大影响的。</p>
<h2 id="减少plugin的消耗"><a href="#减少plugin的消耗" class="headerlink" title="减少plugin的消耗"></a>减少plugin的消耗</h2><p>webpack 的 plugin 会在构建的过程中加入其它的工作步骤，如果可以的话，适当地移除掉一些没有必要的 plugin。</p>
<p>这里再提一下 webpack 4.x 的 mode，区分 mode 会让 webpack 的构建更加有针对性，更加高效。例如当 mode 为 development 时，webpack 会避免使用一些提高应用代码加载性能的配置项，如 UglifyJsPlugin，ExtractTextPlugin 等，这样可以更快地启动开发环境的服务，而当 mode 为 production 时，webpack 会避免使用一些便于 debug 的配置，来提升构建时的速度，例如极其消耗性能的 Source Maps 支持。</p>
<h3 id="换种方式处理图片"><a href="#换种方式处理图片" class="headerlink" title="换种方式处理图片"></a>换种方式处理图片</h3><p>我们在前边的小节提到图片可以使用 webpack 的 image-webpack-loader 来压缩图片，在对 webpack 构建性能要求不高的时候，这样是一种很简便的处理方式，但是要考虑提高 webpack 构建速度时，这一块的处理就得重新考虑一下了，思考一下是否有必要在 webpack 每次构建时都处理一次图片压缩。</p>
<p>这里介绍一种解决思路，我们可以直接使用 imagemin 来做图片压缩，编写简单的命令即可。然后使用 pre-commit 这个类库来配置对应的命令，使其在 git commit 的时候触发，并且将要提交的文件替换为压缩后的文件。</p>
<p>这样提交到代码仓库的图片就已经是压缩好的了，以后在项目中再次使用到的这些图片就无需再进行压缩处理了，image-webpack-loader 也就没有必要了。</p>
<h2 id="使用DLLPlugin"><a href="#使用DLLPlugin" class="headerlink" title="使用DLLPlugin"></a>使用DLLPlugin</h2><hr>
<p>DLLPlugin 是 webpack 官方提供的一个插件，也是用来分离代码的，和 optimization.splitChunks（3.x 版本的是 CommonsChunkPlugin）有异曲同工之妙，之所以把 DLLPlugin 放到 webpack 构建性能优化这一部分，是因为它的配置相对繁琐，如果项目不涉及性能优化这一块，基本上使用 optimization.splitChunks 即可。</p>
<p>我们来看一下 DLLPlugin 如何使用，使用这个插件时需要额外的一个构建配置，用来打包公共的那一部分代码，举个例子，假设这个额外配置是 webpack.dll.config.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  name: <span class="string">'vendor'</span>,</span><br><span class="line">  entry: [<span class="string">'lodash'</span>], <span class="comment">// 这个例子我们打包 lodash 作为公共类库</span></span><br><span class="line"></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"vendor.js"</span>,</span><br><span class="line">    library: <span class="string">"vendor_[hash]"</span> <span class="comment">// 打包后对外暴露的类库名称</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor_[hash]'</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">"dist/manifest.json"</span>), <span class="comment">// 使用 DLLPlugin 在打包的时候生成一个 manifest 文件</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是我们正常的应用构建配置，在那个的基础上添加两个一个新的 <code>webpack.DllReferencePlugin</code> 配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      manifest: path.resolve(__dirname, <span class="string">'dist/manifest.json'</span>), </span><br><span class="line">      <span class="comment">// 指定需要用到的 manifest 文件，</span></span><br><span class="line">      <span class="comment">// webpack 会根据这个 manifest 文件的信息，分析出哪些模块无需打包，直接从另外的文件暴露出来的内容中获取</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建的时候我们需要要优先使用<code>webpack.dll.config.js</code>来打包，如<code>webpack -c webpack.dll.config.js --mode production</code>,构建生成公共代码某块的文件<code>vendor.js</code>和<code>manifest.json</code>,然后再进行应用代码的构建。</p>
<p>你会发现构建结果的应用代码中不包含 lodash 的代码内容，这一部分代码内容会放在 <code>vendor.js</code> 这个文件中，而你的应用要正常使用的话，需要在 HTML 文件中按顺序引用这两个代码文件，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"vendor.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>作用是不是和<code>·optimization.splitChunks</code> 很相似，但是有个区别，DLLPlugin 构建出来的内容无需每次都重新构建，后续应用代码部分变更时，你不用再执行配置为 <code>webpack.dll.config.js</code> 这一部分的构建，沿用原本的构建结果即可，所以相比 <code>optimization.splitChunks</code>，使用 DLLPlugin 时，构建速度是会有显著提高的。</p>
<p>但是很显然，DLLPlugin 的配置要麻烦得多，并且需要关心你公共部分代码的变化，当你升级 lodash（即你的公共部分代码的内容变更）时，要重新去执行 <code>webpack.dll.config.js</code> 这一部分的构建，不然沿用的依旧是旧的构建结果，使用上并不如 <code>optimization.splitChunks</code> 来得方便。这是一种取舍，根据项目的实际情况采用合适的做法。</p>
<p>还有一点需要注意的是，html-webpack-plugin 并不会自动处理 DLLPlugin 分离出来的那个公共代码文件，我们需要自己处理这一部分的内容，可以考虑使用 add-asset-html-webpack-plugin，关于这一个的使用就不讲解了，详细参考官方的说明文档：使用 add-asset-html-webpack-plugin。</p>
<h2 id="webpack4-x的构建性能"><a href="#webpack4-x的构建性能" class="headerlink" title="webpack4.x的构建性能"></a>webpack4.x的构建性能</h2><hr>
<p>从官方发布的 webpack 4.0 更新日志来看，webpack 4.0 版本做了很多关于提升构建性能的工作，我觉得比较重要的改进有这么几个：</p>
<ul>
<li>AST 可以直接从 loader 直接传递给 webpack，避免额外的解析，对这一个优化细节有兴趣的可以查看这个 PR。</li>
<li>使用速度更快的 md4 作为默认的 hash 方法，对于大型项目来说，文件一多，需要 hash 处理的内容就多，webpack 的 hash 处理优化对整体的构建速度提升应该还是有一定的效果的。</li>
<li>Node 语言层面的优化，如用 for of 替换 forEach，用 Map 和 Set 替换普通的对象字面量等等，这一部分就不展开讲了，有兴趣的同学可以去 webpack 的 PRs 寻找更多的内容。</li>
<li>默认开启 uglifyjs-webpack-plugin 的 cache 和 parallel，即缓存和并行处理，这样能大大提高 production mode 下压缩代码的速度。</li>
</ul>
<p>除此之外，还有比较琐碎的一些内容，可以查阅：webpack release 4.0，留意 performance 关键词。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/提升webpack的构建速度/">提升webpack的构建速度</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/06/webpack-之十二（创建自己的loader）/" title="webpack之十二创建自己的loader" itemprop="url">webpack之十二创建自己的loader</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-11-06T08:35:45.000Z" itemprop="datePublished"> Published 2017-11-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="loader是一个函数"><a href="#loader是一个函数" class="headerlink" title="loader是一个函数"></a>loader是一个函数</h2><hr>
<p>先来看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">"marked"</span>);</span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">"loader-utils"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">markdown</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 loaderUtils 来获取 loader 的配置项</span></span><br><span class="line">    <span class="comment">// this 是构建运行时的一些上下文信息</span></span><br><span class="line">    <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.cacheable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把配置项直接传递给 marked</span></span><br><span class="line">    marked.setOptions(options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 marked 处理 markdown 字符串，然后返回</span></span><br><span class="line">    <span class="keyword">return</span> marked(markdown);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是markdown-loader的实现代码，笔者添加了一些代码说明，看上去很简单。</p>
<p>markdown-loader 本身仅仅只是一个函数，接收模块代码的内容，然后返回代码内容转化后的结果。webpack loader 的本质就是这样的一个函数。</p>
<p>上述代码中用到的 loader-utils 是 webpack 官方提供的一个工具库，提供 loader 处理时需要用到的一些工具方法，例如用来解析上下文 loader 配置项的 <code>getOptions</code>。关于这个工具库的内容和功能不是特别复杂，就不展开了，直接参考这个库的官方文档即可。</p>
<p>代码中还用到了 marked，marked 是一个用于解析 Markdown 的类库，可以把 Markdown 转为 HTML，markdown-loader 的核心功能就是用它来实现的。基本上，webpack loader 都是基于一个实现核心功能的类库来开发的，例如 sass-loader 是基于 node-sass 实现的，等等。</p>
<h2 id="开始一个loader的开发"><a href="#开始一个loader的开发" class="headerlink" title="开始一个loader的开发"></a>开始一个loader的开发</h2><hr>
<p>我们可以在 webpack 配置中直接使用路径来指定使用本地的 loader，或者在 loader 路径解析中加入本地开发 loader 的目录。看看配置例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... </span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader: path.resolve(<span class="string">'./loader/index.js'</span>), <span class="comment">// 使用本地的 ./loader/index.js 作为 loader</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 resolveLoader 中添加本地开发的 loaders 存放路径</span></span><br><span class="line"><span class="comment">// 如果你同时需要开发多个 loader，那么这个方式会更加适合你</span></span><br><span class="line">resolveLoader: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    <span class="string">'node_modules'</span>,</span><br><span class="line">    path.resolver(__dirname, <span class="string">'loaders'</span>)</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>如果你熟悉 Node 的话，也可以使用 npm link 的方式来开发和调试，关于这个方式，可以参考 npm 的官方文档 npm-link。</p>
<h2 id="复杂一点的情况"><a href="#复杂一点的情况" class="headerlink" title="复杂一点的情况"></a>复杂一点的情况</h2><hr>
<p>当我们选择上述任意一种方法，并且做好相应的准备后，我们就可以开始写 loader 的代码了，然后通过执行 webpack 构建来查看 loader 是否正常工作。</p>
<p>上面已经提到，loader 是一个函数，接收代码内容，然后返回处理结果，有一些 loader 的实现基本上就是这么简单，但是有时候会遇见相对复杂一点的情况。</p>
<p>首先loader函数接受的参数是有三个的：<code>content,map,meta</code>。<code>content</code>是模块内容，但是不仅限于字符串，也可以是buffer，例如一些图片或者字体等文件。<code>map</code>则是sourcemap对象，<code>meta</code>是其他的一些元数据。loader函数单纯返回一个值，这个值是当成content去处理，但如果你需要返回sourcemap对象或者meta数据，甚至抛出一个loader异常给webpack时，你需要使用<code>this.callback(err, content, map, meta)</code>来传递数据。</p>
<p>我们日常使用webpack，有时候会把多个loader串起来一起使用，最常见的莫过于css-loader和style-loader了。当我们配置<code>use: [&#39;bar-loader&#39;, &#39;foo-loader&#39;]</code>时，laoder是以相反的顺序执行的，即先跑foo-loader，再跑bar-loader。这一部分内容配置loader 的小节中有提及，这里再以开发 loader 的角度稍稍强调下，搬运官网的一段说明：</p>
<ul>
<li>最后的 loader 最早调用，传入原始的资源内容（可能是代码，也可能是二进制文件，用 buffer 处理）</li>
<li>第一个 loader 最后调用，期望返回是 JS 代码和 sourcemap 对象（可选）</li>
<li>中间的 loader 执行时，传入的是上一个 loader 执行的结果</li>
</ul>
<p>虽然有多个 loader 时遵循这样的执行顺序，但对于大多数单个 loader 来说无须感知这一点，只负责好处理接受的内容就好。</p>
<p>还有一个场景是loader中的异步处理。有一些loader在执行古城中可能依赖于外部I/O的结果，导致它必须使异步的方式来处理，这个使用需要在loader执行使用<code>this.asyn（）</code>来标识该loader是异步的，然后使用<code>this.callback</code>来返回loader处理结果。例子可以参考官方文档：<code>异步loader</code></p>
<h2 id="Pitching-loader"><a href="#Pitching-loader" class="headerlink" title="Pitching loader"></a>Pitching loader</h2><hr>
<p>我们可以使用<code>pitch</code>来跳过loader的处理，<code>pitch</code>方法时loader额外实现的一个函数，看下官方文档中的一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content, <span class="keyword">this</span>.data.value); <span class="comment">// pitch 的缘故，这里的 data.value 为 42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂在 loader 函数上的 pitch 函数</span></span><br><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span>(<span class="params">remainingRequest, precedingRequest, data</span>) </span>&#123;</span><br><span class="line">  data.value = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以简单的把<code>pitch</code>理解为loader的前置钩子，它可以使用<code>this.data</code>来传递数据，然后具备跳过剩余loader的能力。</p>
<p>在一个<code>use</code>配置中所有的loader执行前会执行对应的<code>pitch</code>,并且于loader执行顺序时相反的，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">use: [</span><br><span class="line">  <span class="string">'bar-loader'</span>,</span><br><span class="line">  <span class="string">'foo-loader'</span>,</span><br><span class="line">],</span><br><span class="line"><span class="comment">// 执行 bar-loader 的 pitch</span></span><br><span class="line"><span class="comment">// 执行 foo-loader 的 pitch</span></span><br><span class="line"><span class="comment">// bar-loader</span></span><br><span class="line"><span class="comment">// foo-loader</span></span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">其中，当pith中返回了结果，那么执行顺序会回过头来，跳掉剩余的loader，如`</span>bar-loader<span class="string">`的pitch返回结果了，那么执行只剩下</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">// 执行 bar-loader 的 pitch</span></span><br></pre></td></tr></table></figure>
<p>可能只有比较少的 loader 会用到 pitch 这个功能，但有的时候考虑实现 loader 功能需求时把 pitch 纳入范围会有不一样的灵感，它可以让你更加灵活地去定义 loader 的执行。</p>
<p>这里的简单介绍仅做抛砖引玉之用，详细的学习和了解可以参考官方文档 Pitching loader 或者 bundler-loader 源码 bundler-loader。</p>
<h2 id="loader-上下文"><a href="#loader-上下文" class="headerlink" title="loader 上下文"></a>loader 上下文</h2><hr>
<p>上述提及的一些代码会使用到<code>this</code>,即loader函数的额上下文，包括<code>this.callback</code>和<code>this.data</code>等，可以这样简单地理解：  <code>this</code>是作为loader运行时数据和方法补充载体。</p>
<p>loader上下文有很多运行时的信息，如<code>this.context</code>和<code>this.request</code>等等，而最重要的方法莫过于<code>this.callback</code>和<code>this.async</code>,官方文档有比较详细的说明：loader API。当你在开发 loader 过程中发现需要某些运行时数据时，就可以查阅 loader API，基本上该有的数据都有了。</p>
<h2 id="一个好的loader时什么样的"><a href="#一个好的loader时什么样的" class="headerlink" title="一个好的loader时什么样的"></a>一个好的loader时什么样的</h2><hr>
<p>loader 作为 webpack 解析资源的一种扩展方式，最重要的是足够简单易用，专注于处理自己那一块的内容，便于维护，可以和其他多个 loader 协同来处理更加复杂的情况。</p>
<p>官方对于 loader 的使用和开发有一些准则，一个好的 loader 应该符合官方的这些定义：Loader 准则。</p>
<p>社区中有相当多的优秀 loader 可以作为参考，例如刚开始提及的 markdown-loader，相当地简单易用。由于 loader 的这种准则和特性，大部分的 loader 源码都相对容易解读，便于我们学习参考。</p>
<p>作为一个 loader 开发者，你应该尽可能遵循这些准则（有些特殊情况需要特殊处理），这样会让你开发出质量更高、更易维护和使用的 webpack loader。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/创建自己的loader/">创建自己的loader</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/30/webpack-之十一（进一步控制JS大小）/" title="优化前端资源加载 3 - 进一步控制 JS 大小" itemprop="url">优化前端资源加载 3 - 进一步控制 JS 大小</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-10-30T01:10:59.000Z" itemprop="datePublished"> Published 2017-10-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>前面已经介绍了一些优化资源加载的方法，这一小节是这个主题的最后一部分，内容更为深入，主要介绍如何把我们的 JS 代码文件变得更小。</p>
<h2 id="按需加载模块"><a href="#按需加载模块" class="headerlink" title="按需加载模块"></a>按需加载模块</h2><hr>
<p>前面讲述了如何把大的代码文件进行拆分，抽离出多个页面共享的部分,但是当你的Web应用是单个页面，并且极其复杂的时候，你会发现一些代码并不是每一个用户都需要涌动的。你可能希望将这一部分代码抽离出去，仅当用户真正需要用到时才加载，这个时候就需要用到webpack提供的一个优化功能———— 按需加载代码模块</p>
<p>在webpck的构建环境中，要按需加载代码模块很简单，尊许ES标准的动态加载语法<code>dynamic-import</code>来编写代码即可，webpack回自动处理使用该语法编写的模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import 作为一个方法使用，传入模块名即可，返回一个 promise 来获取模块暴露的对象</span></span><br><span class="line"><span class="comment">// 注释 webpackChunkName: "lodash" 可以用于指定 chunk 的名称，在输出文件时有用</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "lodash" */</span> <span class="string">'lodash'</span>).then(<span class="function">(<span class="params">_</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(_.lash([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// 打印 3</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意一下，如果你使用了<code>Babel</code>的话，还需要<code>Syntax Dynamic Import</code>这个Babel插件来处理<code>import()</code>这种语法。</p>
<p>由于动态加载代码模块的语法依赖于promise，对于低版本的浏览器，需要添加promise的polyfill才能使用。</p>
<p>如上的代码，webpack构建时回自动把lodash某块分离出来，并且在代码内部实现动态加载lodash的功能。动态加载代码时依赖于网络，其模块内容会异步返回，所以<code>import</code>方法是返回一个promise来获取动态加载的内容某块内容。</p>
<p><code>import</code>后面注释<code>webpackChunkName:lodash</code>用于告知webpack所要动态加载某块的名称。我们在webpack配置中添加一个<code>output.chunkFilename</code>的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  filename: <span class="string">'[name].[hash:8].js'</span>,</span><br><span class="line">  chunkFilename: <span class="string">'[name].[hash:8].js'</span> <span class="comment">// 指定分离出来的代码文件的名称</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>如果没有添加注释 <code>webpackChunkName: &quot;lodash&quot;</code> 以及 <code>output.chunkFilename</code> 配置，那么分离出来的文件名称会以简单数字的方式标识，不便于识别。</p>
<h2 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree shaking"></a>Tree shaking</h2><hr>
<p>Tree shaking 这个术语起源于 ES2015 模块打包工具 <code>rollup</code>，依赖于 ES2015 模块系统中的<code>静态结构特性</code>，可以移除 JavaScript 上下文中的未引用代码，删掉用不着的代码，能够有效减少 JS 代码文件的大小。拿官方文档的例子来说明一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; cube &#125; <span class="keyword">from</span> <span class="string">'./math.js'</span> <span class="comment">// 在这里只是引用了 cube 这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cube(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>如果整个项目代码只是上述的两个文件，那么很明显，<code>square</code>这个方式是未被引用的代码，是可以删掉的。在webapck中，只有启动了JS代码压缩功能（即使用uglify）时，会做Tree shaking的优化。webpack 4.x需要指定mode为production，而webpack 3.x的话需要配置UglifyJsPlugin。启动了之后，构建出来的结果就会移除<code>square</code>的那一部分代码了。</p>
<p>如果你在项目中使用了Babel的话，要把Babel解析某班语法功能关掉，在<code>.babelrc</code>配置中增加<code>&quot;modules&quot;: false</code>这个配置：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [[<span class="string">"env"</span>, &#123; <span class="attr">"modules"</span>: <span class="literal">false</span> &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以把 <code>import/export</code> 的这一部分模块语法交由 webpack 处理，否则没法使用 Tree shaking 的优化。</p>
<p>有的时候你启用了 Tree shaking 功能，但是发现好像并没有什么用，例如这样一个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/component.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (&#123; name &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (&#123; model &#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.model = model</span><br><span class="line">  &#125;</span><br><span class="line">  getModel () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Apple &#125; <span class="keyword">from</span> <span class="string">'./components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appleModel = <span class="keyword">new</span> Apple(&#123;</span><br><span class="line">  model: <span class="string">'X'</span></span><br><span class="line">&#125;).getModel()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(appleModel)</span><br></pre></td></tr></table></figure>
<h2 id="sideEffects"><a href="#sideEffects" class="headerlink" title="sideEffects"></a>sideEffects</h2><hr>
<p>这是 webpack 4.x 才具备的特性，暂时官方还没有比较全面的介绍文档，笔者从 webpack 的 examples 里找到一个东西：side-effects/README.md。</p>
<p>我们拿<code>lodash</code>举个例子，有些同学可能对<code>lodash</code>已经蛮熟悉了，他是一个工具库，提供了大量的对字符串、数组、对象等常见数据类型的处理函数，但是有的时候我们只是使用了其中的几个函数，全部函数的实现都打包到我们的应用代码中其实很浪费。</p>
<p>webpack的sideEffects可以帮助我们解决这个问题。现在lodash<code>ES版本</code>在<code>package.json</code>文件中已经有<code>sideEffects: false</code>这个声明了，当某个模块的 package.json 文件中有了这个声明之后，webpack 会认为这个模块没有任何副作用，只是单纯用来对外暴露模块使用，那么在打包的时候就会做一些额外的处理。</p>
<p>例如你这么使用 <code>lodash</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; forEach, includes &#125; <span class="keyword">from</span> <span class="string">'lodash-es'</span></span><br><span class="line"></span><br><span class="line">forEach([<span class="number">1</span>, <span class="number">2</span>], (item) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(includes([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>由于 lodash-es 这个模块的 <code>package.json</code> 文件有 <code>sideEffects: false</code> 的声明，所以 webpack 会将上述的代码转换为以下的代码去处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> forEach &#125; <span class="keyword">from</span> <span class="string">'lodash-es/forEach'</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> includes &#125; <span class="keyword">from</span> <span class="string">'lodash-es/includes'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 其他代码...</span></span><br></pre></td></tr></table></figure>
<p>最终 webpack 不会把 lodash-es 所有的代码内容打包进来，只是打包了你用到的那两个方法，这便是 sideEffects 的作用。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/优化前端资源加载-3-进一步控制-JS-大小/">优化前端资源加载 3 - 进一步控制 JS 大小</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/10/24/webpack-之十（分离代码文件）/" title="优化前端资源加载 2 - 分离代码文件" itemprop="url">优化前端资源加载 2 - 分离代码文件</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-10-24T08:49:53.000Z" itemprop="datePublished"> Published 2017-10-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="分离代码文件"><a href="#分离代码文件" class="headerlink" title="分离代码文件"></a>分离代码文件</h2><hr>
<p>关于分离CSS文件这个主题，在webpack中使用<code>extract-text-webpack-plugin</code>插件即可。</p>
<p>先解释一下为什么要把CSS文件分离出来，而不是直接一起打包在JS中。最主要的原因是我们希望更好地利用缓存。</p>
<p>假设我们原本页面的静态资源打包成一个JS文件，加载页面时虽然只需要加载一个JS文件，但是我们的代码一旦改变了，用户访问新的页面时就需要重新加载一个新的JS文件。在有些情况下，我们只是单独修改了样式，这样重新加载整个JS文件，相当不划算。</p>
<p>还有一种情况我们有多个页面，他们都可以公用一部分样式（这是常见的，CSSReset、基础组件样式等基本都是可以跨页面通用），如果每个页面都单独打包一个JS文件，那么每次访问页面都会重复加载原本可以共享的那些CSS代码。如果分离开来，第二个页面就有了CSS缓存，访问速度自然回加快。虽然对第一个页面来说多了一个请求，但是对随后的页面来说，缓存带来的速度提升相当可观。</p>
<p>因此当我们考虑更好地利用缓存来加速静态资源访问时，会尝试把一些公共资源单独分离开来，利用缓存加速，以避免重复的加载。除了公共的 CSS 文件或者图片资源等，当我们的 JS 代码文件过大的时候，也可以用代码文件拆分的办法来进行优化。</p>
<p>那么，如何使用 webpack 来把代码中公共使用的部分分离成为独立的文件呢？由于 webpack 4.x 和 webpack 3.x 在代码分离这一块的内容差别比较大，因而我们分别都介绍一下。</p>
<p>3.x 以前的版本是使用 CommonsChunkPlugin 来做代码分离的，而 webpack 4.x 则是把相关的功能包到了 optimize.splitChunks 中，直接使用该配置就可以实现代码分离。</p>
<p>我们先介绍在 webpack 4.x 中如何使用这个配置来实现代码分离。</p>
<h2 id="webpck4-x的optimization"><a href="#webpck4-x的optimization" class="headerlink" title="webpck4.x的optimization"></a>webpck4.x的optimization</h2><hr>
<p>webpack的作者直接推荐这样简单地配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line"></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">"all"</span>, <span class="comment">// 所有的 chunks 代码公共的部分分离出来成为一个单独的文件</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要在 HTML 中引用两个构建出来的 JS 文件，并且 commons.js 需要在入口代码之前。下面是个简单的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"commons.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"entry.bundle.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你使用了html-webpack-plugin，那么对应需要的JS文件都会在HTML文件中正确引用，不用担心，如果没有使用，那么你需要从<code>status</code>的<code>entrypoints</code>属性来获取入口文件应该引用哪些JS文件，可以参考<code>Node API</code>了解如何从status中获取信息，或者开发一个plugin来处理正确引用JS文件这个问题。</p>
<p>之前我们提到拆分文件是为了更好的利用缓存，分离公共类库是为了让更多的页面利用缓存，从而减少代码量的下载，同时，也有代码变更时可以利用缓存减少下载代码量的好处。从这个角度出发，笔者建议讲公共使用的类库显示地为公共部分，而不是webpack自己去处理判断，因为公共的第三方类库通常升级频率相对低一些，着样可以避免因公共chunk的频繁而导致缓存失效。</p>
<p>显示配置共享类库可以这么操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">"react"</span>, <span class="string">"lodash"</span>, <span class="string">"angular"</span>, ...], <span class="comment">// 指定公共使用的第三方类库</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          test: <span class="string">"vendor"</span>,</span><br><span class="line">          name: <span class="string">"vendor"</span>, <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          test: <span class="regexp">/react|angluar|lodash/</span>, <span class="comment">// 直接使用 test 来做路径匹配</span></span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          name: <span class="string">"vendor"</span>,</span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          chunks: <span class="string">"initial"</span>,</span><br><span class="line">          test: path.resolve(__dirname, <span class="string">"node_modules"</span>) <span class="comment">// 路径在 node_modules 目录下的都作为公共部分</span></span><br><span class="line">          name: <span class="string">"vendor"</span>, <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">          enforce: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述第一种做法是显示指定哪些类库作为公共部分，第二种做法实现的功能差不多，只是利用了 <code>test</code> 来做模块路径的匹配，第三种做法是把所有在 node_modules 下的模块，即作为依赖安装的，都作为公共部分。你可以针对项目情况，选择最合适的做法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">webpack 3.x 的 CommonsChunkPlugin</span><br><span class="line">------</span><br><span class="line">下面我们简单介绍一下在 webpack 3.x 中如何配置代码分离。webpack 3.x 以下的版本需要用到 webpack 自身提供的 CommonsChunkPlugin 插件。我们先来看一个最简单的例子：</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &quot;commons&quot;, // 公共使用的 chunk 的名称</span><br><span class="line">      filename: &quot;commons.js&quot;, // 公共 chunk 的生成文件名</span><br><span class="line">      minChunks: 3, // 公共的部分必须被 3 个 chunk 共享</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>chunk 在这里是构建的主干，可以简单理解为一个入口对应一个 chunk。</p>
<p>以上插件配置在构建后会生成一个 commons.js 文件，该文件就是代码中的公共部分。上面的配置中  <code>minChunks</code> 字段为 3，该字段的意思是当一个模块被 3 个以上的 chunk 依赖时，这个模块就会被划分到 <code>commons</code> chunk 中去。单从这个配置的角度上讲，这种方式并没有 4.x 的 <code>chunks: &quot;all&quot;</code> 那么方便。</p>
<p>CommonChunkPlugin也是显式配置共享类库的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendor: [<span class="string">'react'</span>, <span class="string">'react-redux'</span>], <span class="comment">// 指定公共使用的第三方类库</span></span><br><span class="line">    app: <span class="string">'./src/entry'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: <span class="string">'vendor'</span> <span class="comment">// 使用 vendor 入口作为公共部分</span></span><br><span class="line">      filename: <span class="string">"vendor.js"</span>, </span><br><span class="line">      minChunks: <span class="literal">Infinity</span>, <span class="comment">// 这个配置会让 webpack 不再自动抽离公共模块</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述配置会生成一个名为 vendor.js 的共享代码文件，里面包含了 React 和 React-Redux 库的代码，可以提供给多个不同的入口代码使用。这里的 <code>minChunks</code> 字段的配置，我们使用了 <code>Infinity</code>，可以理解为 webpack 不自动抽离公共模块。如果这里和之前一样依旧设置为 3，那么被 3 个以上的 chunk 依赖的模块会和 React、React-Redux 一同打包进 vendor，这样就失去显式指定的意义了。</p>
<p><code>minChunks</code>其实还可以是一个函数，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minChunks: <span class="function">(<span class="params"><span class="built_in">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>, count);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>该函数在分析每一个依赖的时候会被调用，传入当前依赖模块的信息 <code>module</code>，以及已经被作为公共模块的数量 <code>count</code>，你可以在函数中针对每一个模块做更加精细化的控制。看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">minChunks: <span class="function">(<span class="params"><span class="built_in">module</span>, count</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.context &amp;&amp; <span class="built_in">module</span>.context.includes(<span class="string">"node_modules"</span>); </span><br><span class="line">  <span class="comment">// node_modules 目录下的模块都作为公共部分，效果就如同 webpack 4.x 中的 test: path.resolve(__dirname, "node_modules")</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>更多使用 CommonsChunkPlugin 的配置参考官方文档 commons-chunk-plugin。</p>
<p>而关于 webpack 4.x 的 splitChunks 配置，笔者写这一部分的时候官方文档还没有更新出来，上述配置预估可以满足大部分项目的需求，更加详细的内容还请等待官方文档更新后查阅。 </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/优化前端资源加载-2-分离代码文件/">优化前端资源加载 2 - 分离代码文件</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/09/23/webpack-之九 （前端资源加载）/" title="优化前端资源加载 1 - 图片加载优化和代码压缩" itemprop="url">优化前端资源加载 1 - 图片加载优化和代码压缩</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-09-23T08:48:00.000Z" itemprop="datePublished"> Published 2017-09-23</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们总是希望浏览器在加载页面时用的时间越短越好，所以构建出来的文件应该越少越小越好，一来减少浏览器需要发起请求的数量，二来减少下载静态资源的时间。</p>
<p>其实 webpack 把多个代码文件打包成几个必需的静态资源，已经很大程度减少了静态资源请求数量了，接下来我们来介绍下如何使用 webpack 实现更多的前端资源加载的优化需求。</p>
<h2 id="CSS-Script"><a href="#CSS-Script" class="headerlink" title="##CSS Script"></a>##CSS Script</h2><p><code>CSS Script</code>技术时前端领域一种常见减少图片请求数的优化方式，这里不做详细的介绍。</p>
<blockquote>
<p>在了解webpack配置之前，需要先明白CSS Script的原理。</p>
</blockquote>
<p>如果你是用的webpack 3.x版本，需要CSS Script的话，可以使用<code>webpack-spritesmith</code> 或者 <code>sprite-webpack-plugin</code>。</p>
<p>我们以 webpack-spritesmith 为例，先安装依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-spritesmith --save-dev</span><br></pre></td></tr></table></figure>
<p>在webpack的配置中应用插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    <span class="comment">// ... 这里需要有处理图片的 loader，如 file-loader</span></span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">resolve: &#123;</span><br><span class="line">  modules: [</span><br><span class="line">    <span class="string">'node_modules'</span>, </span><br><span class="line">    <span class="string">'spritesmith-generated'</span>, <span class="comment">// webpack-spritesmith 生成所需文件的目录</span></span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> SpritesmithPlugin(&#123;</span><br><span class="line">    src: &#123;</span><br><span class="line">      cwd: path.resolve(__dirname, <span class="string">'src/ico'</span>), <span class="comment">// 多个图片所在的目录</span></span><br><span class="line">      glob: <span class="string">'*.png'</span> <span class="comment">// 匹配图片的路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    target: &#123;</span><br><span class="line">      <span class="comment">// 生成最终图片的路径</span></span><br><span class="line">      image: path.resolve(__dirname, <span class="string">'src/spritesmith-generated/sprite.png'</span>), </span><br><span class="line">      <span class="comment">// 生成所需 SASS/LESS/Stylus mixins 代码，我们使用 Stylus 预处理器做例子</span></span><br><span class="line">      css: path.resolve(__dirname, <span class="string">'src/spritesmith-generated/sprite.styl'</span>), </span><br><span class="line">    &#125;,</span><br><span class="line">    apiOptions: &#123;</span><br><span class="line">      cssImageRef: <span class="string">"~sprite.png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>在你需要的样式中引入<code>sprite。styl</code>后调用需要的mixins即可</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@import <span class="string">'~sprite.styl'</span></span><br><span class="line"></span><br><span class="line">.close-button</span><br><span class="line">    sprite(<span class="variable">$close</span>)</span><br><span class="line">.open-button</span><br><span class="line">    sprite(<span class="variable">$open</span>)</span><br></pre></td></tr></table></figure>
<p>更多的 webpack-spritesmith 配置可以参考：Config of webpack-spritesmith。</p>
<p>遗憾的是，上面提到的两个plugin还没有更新到webpack4.x, 你需要配合postcss和postcss-sprites相关构建</p>
<h2 id="图片压缩"><a href="#图片压缩" class="headerlink" title="##图片压缩"></a>##图片压缩</h2><p>在一般的项目中，图片资源会占前端资源的很大一部分，既然代码都进行压缩了，占大头的图片就更不用说了。</p>
<p>用file-loader来处理图片文件，在此基础上，我们再添加一个<code>image-webpack-loader</code>来压缩图片文件。简单的配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/.*\.(gif|png|jpe?g|svg|webp)$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'file-loader'</span>,</span><br><span class="line">            options: &#123;&#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'image-webpack-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123; <span class="comment">// 压缩 jpeg 的配置</span></span><br><span class="line">                progressive: <span class="literal">true</span>,</span><br><span class="line">                quality: <span class="number">65</span></span><br><span class="line">              &#125;,</span><br><span class="line">              optipng: &#123; <span class="comment">// 使用 imagemin-optipng 压缩 png，enable: false 为关闭</span></span><br><span class="line">                enabled: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              pngquant: &#123; <span class="comment">// 使用 imagemin-pngquant 压缩 png</span></span><br><span class="line">                quality: <span class="string">'65-90'</span>,</span><br><span class="line">                speed: <span class="number">4</span></span><br><span class="line">              &#125;,</span><br><span class="line">              gifsicle: &#123; <span class="comment">// 压缩 gif 的配置</span></span><br><span class="line">                interlaced: <span class="literal">false</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">              webp: &#123; <span class="comment">// 开启 webp，会把 jpg 和 png 图片压缩为 webp 格式</span></span><br><span class="line">                quality: <span class="number">75</span></span><br><span class="line">              &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>image-webpack-loader的压缩是使用<code>imagemin</code>提供的一系列图片库来处理的，如果需要进一步了解详细的配置，可以查看对应类库的官方文档<code>usage of image-webpck-loader</code>。</p>
<h2 id="使用DataURL"><a href="#使用DataURL" class="headerlink" title="使用DataURL"></a>使用DataURL</h2><hr>
<p>有的时候我们项目中会有一些很小的图片，因为某些缘故并不想使用CSS Script的方式来处理（譬如小图片不多，因此引入CSS Script感觉麻烦），那么我们可以在webpack中使用url-loader来处理这些很小的图片。</p>
<p><code>url-loader</code>和<code>file-loader</code>的功能类似，但是在处理文件的时候，可以通过配置指定一个大小，当文件小于这个配置时，url-loader会将其转换为一个base64的DataURL，配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'url-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              limit: <span class="number">8192</span>, <span class="comment">// 单位是 Byte，当文件小于 8KB 时作为 DataURL 处理</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多关于url-loader的配置可以参考官方文档<code>url-loader</code>,一般情况下使用<code>limit</code>即可。</p>
<h2 id="代码压缩"><a href="#代码压缩" class="headerlink" title="##代码压缩"></a>##代码压缩</h2><p>除了 JS 代码之外，我们一般还需要 HTML 和 CSS 文件，这两种文件也都是可以压缩的，虽然不像 JS 的压缩那么彻底（替换掉长变量等），只能移除空格换行等无用字符，但也能在一定程度上减小文件大小。在 webpack 中的配置使用也不是特别麻烦，所以我们通常也会使用。</p>
<p>对于 HTML 文件，html-webpack-plugin 插件可以帮助我们生成需要的 HTML 并对其进行压缩：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>, <span class="comment">// 配置输出文件名和路径</span></span><br><span class="line">      template: <span class="string">'assets/index.html'</span>, <span class="comment">// 配置文件模板</span></span><br><span class="line">      minify: &#123; <span class="comment">// 压缩 HTML 的配置</span></span><br><span class="line">        minifyCSS: <span class="literal">true</span>, <span class="comment">// 压缩 HTML 中出现的 CSS 代码</span></span><br><span class="line">        minifyJS: <span class="literal">true</span> <span class="comment">// 压缩 HTML 中出现的 JS 代码</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，使用<code>minify</code>字段配置就可以使用HTML压缩，这个插件是使用<code>html-minifier</code>来实现HTML代码压缩的<code>minify</code>下的配置项直接透传给html-minifier，配置产考html-minifier文档即可。</p>
<p>对于 CSS 文件，我们之前介绍过用来处理 CSS 文件的 css-loader，也提供了压缩 CSS 代码的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css/</span>,</span><br><span class="line">        include: [</span><br><span class="line">          path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">        ],</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              minimize: <span class="literal">true</span>, <span class="comment">// 使用 css 的压缩功能</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 css-loader 的选项中配置 minimize 字段为 true 来使用 CSS 压缩代码的功能。css-loader 是使用 cssnano 来压缩代码的，minimize 字段也可以配置为一个对象，来将相关配置传递给 cssnano。更多详细内容请参考 cssnano 官方文档。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/优化前端资源加载-1-图片加载优化和代码压缩/">优化前端资源加载 1 - 图片加载优化和代码压缩</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/09/21/webpack-之八（用HRM提高开发效率）/" title="用HRM提高开发效率" itemprop="url">用HRM提高开发效率</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-09-21T11:30:49.000Z" itemprop="datePublished"> Published 2017-09-21</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="用HMR提高开发效率"><a href="#用HMR提高开发效率" class="headerlink" title="##用HMR提高开发效率"></a>##用HMR提高开发效率</h2><p>HMR 全称是Hot Module Replacement，即某块替换。在这个概念之前使用郭Hot Reloading，当代码变更是通知浏览器刷新页面，以避免频繁手动刷新浏览器页面。HRM可以理解为增强版的Hot Reloading，但不用整个页面刷新，而是局部替换模块代码并且使其生效，可以看到代码变更的效果。所以HRM即避免了频繁手动刷新页面，也减少了页面刷新时的等待，可以极大地提高前端页面开发效率。</p>
<h2 id="配置使用HMR"><a href="#配置使用HMR" class="headerlink" title="配置使用HMR"></a>配置使用HMR</h2><hr>
<p>HRM是webpack提供的非常有用的一个功能，跟我们之前提到的一样，安装好web-dev-server，添加一些简单的配置，即在webpack的配置文件中添加HMR需要的两个插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span> <span class="comment">// dev server 的配置要启动 hot，或者在命令行中带参数开启</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(), <span class="comment">// 用于启动 HMR 时可以显示模块的相对路径</span></span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">// Hot Module Replacement 的插件</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HMR运行原理"><a href="#HMR运行原理" class="headerlink" title="HMR运行原理"></a>HMR运行原理</h2><hr>
<p>HRM的实现和运行相对复杂，需要多个部分协同配合，这里稍微介绍一下HRM的运行原理。</p>
<p>首先我们知道一个概念：webpack内部运行时，回维护一份用于管理构建代码时各个幂快之间交互的表数据。webpack官方称之为Manifest，其中包括入口文件和构建出来的bundle文件的关系。可以使用<code>WebpackManifestPlugin</code>插件来输出这样的一份数据。</p>
<p>开启了hot功能的webpack回往我们应用的主要代码中添加WS相关的代码，用于和服务器保持连接，等待更新动作。</p>
<p>当你配置了HMR的插件时，会往应用代码中添加HRM运行时的代码，主要用于定义代码模块更新时的API，</p>
<p>有了这两个部分就可以支持HMR的功能了。当有更新时，webpack-dev-server发送更新信号给HMR运行时，然后HMR再请求所需要的更新数据，请求的更新数据没有问题的话就应用更新数据。</p>
<p>如果HMR只是简单替换代码模块的内容，如替换掉所谓的<code>installedModules</code>中需要更新新的部分，那么浏览器就没有办法把跟新后的结果实时地在浏览器上显示出来。</p>
<p>前面提到的HMR运行时的代码会提供定义模版应用跟新执行时的API，这些API可以让我们在模块中定义接收到HMR更新应用信号时，需要额外做些什么工作，例如<code>style-loader</code>就需要实现HMR接口，当收到更新时，使用新的样式替换掉久的样式，大概就是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'/some/path'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 用新样式替换旧样式</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详情可以产考style-loader中的代码实现<code>HMR interface implemention in style-loader</code> 。</p>
<p>HRM应用更新时是使用<code>webpackHotUpdate</code>来处理的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webpackHotUpdate(id, &#123; </span><br><span class="line">  <span class="string">'modulePath'</span>: </span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 模块更新后的代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行<code>webpackHotUpdate</code>时如发现模块代码实现了HMR接口，就会执行相应的回调或者方法，从而达到应用更新时，模块可以自行管理自己所需要额外做的工作。不过，并不是所有的模块都需要做相关的处理，当遇见没有HMR接口的模块时，就会开始向上层冒泡。</p>
<p>这里还有一个问题提是，webpack如何保证HMR接口中的引用是最新的模块代码？看一个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./index.css'</span></span><br><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">'./bar'</span></span><br><span class="line"></span><br><span class="line">hello()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./bar'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// console.log('Accepting the updated bar module!')</span></span><br><span class="line">    hello()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上看，hello都是同一个，这样的话并没有办法引入最新的代码，但是我们看一下上述代码webpack构建后的结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">"./src/bar.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">__WEBPACK_OUTDATED_DEPENDENCIES__</span>) </span>&#123; </span><br><span class="line">    <span class="comment">/* harmony import */</span> </span><br><span class="line">    __WEBPACK_IMPORTED_MODULE_1__bar__ = __webpack_require__(<span class="string">"./src/bar.js"</span>); </span><br><span class="line">    (<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log('Accepting the updated bar module!')</span></span><br><span class="line">      <span class="built_in">Object</span>(__WEBPACK_IMPORTED_MODULE_1__bar__[<span class="string">"default"</span>])()</span><br><span class="line">    &#125;)(__WEBPACK_OUTDATED_DEPENDENCIES__); </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他代码比较复杂，我们集中看<code>module.hot</code>的处理部分。这里可以发现，我们的hello已经重新使用<code>_webpack_require_</code>来引入了，所以可以确保它是最新的代码。</p>
<p>基本上HMR的执行原理就是这样，更具体的实现部分就不展开讲解了。在日常开发中，我们更多的需要工具来实现HMR的接口，避免编写过多HMR需要的代码。例如，React在组件代码更新时可能需要触发render开实现组件的展示效果，官方提供了一些现有的工具，需要的可以参考一下：<code>hot module replacement tools</code>。</p>
<h2 id="module-hot常见API"><a href="#module-hot常见API" class="headerlink" title="module.hot常见API"></a>module.hot常见API</h2><hr>
<p>前面HMR实现部分已经讲解了HRM接口的重要性，下面来看看常见的<code>module.hot</code>API有哪些，以及如何使用。</p>
<p>之前已经介绍过，<code>module.hot.accept</code>方法指定在应用特定代码某块更新时执行相应的callback，第一个参数可以是字符串或者时数组，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept([<span class="string">'./bar.js'</span>, <span class="string">'./index.css'</span>], () =&gt; &#123;</span><br><span class="line">    <span class="comment">// ... 这样当 bar.js 或者 index.css 更新时都会执行该函数</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module.hot,decline</code>对于指定的代码模块，拒绝进行某块代码更新，进入更新失败状态，如<code>module.hot.decline(&#39;./bar.js&#39;)</code>。这个方法比较少用到。</p>
<p><code>module.hot.dispose</code>用于添加一个处理函数，在当前模块代码被替换时运行该函数，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.dispose(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// data 用于传递数据，如果有需要传递的数据可以挂在 data 对象上，然后在模块代码更新后可以通过 module.hot.data 来获取</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>module.hot.accept</code>通常用于指定当前依赖的某个模块需要更新时需要做的处理，如果当前模块跟新时需要处理的动作，使用<code>module.hot.dispose</code>会更加容易方便。</p>
<p><code>module.hot.removeDisposeHandler</code>用于移除<code>dispose</code>方法添加的callback。</p>
<p>关于<code>module.hot</code>的更多API详情可以产考官方文档：Hot Module Replacement APIs。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/用HRM提高开发效率/">用HRM提高开发效率</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/09/01/webpack-之七 （开发和生产环境的构建配置差异）/" title="开发和生产环境的构建配置差异" itemprop="url">开发和生产环境的构建配置差异</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2017-08-31T17:15:54.000Z" itemprop="datePublished"> Published 2017-09-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们在日常的前端开发工作中，一般都会有两套构建环境：一套开发时使用，构建结果用于本地开发调试，不进行代码压缩，打印 debug 信息，包含 sourcemap 文件；另外一套构建后的结果是直接应用于线上的，即代码都是压缩后，运行时不打印 debug 信息，静态文件不包括 sourcemap 的。有的时候可能还需要多一套测试环境，在运行时直接进行请求 mock 等工作。</p>
<p>webpack4.x版本引入了mode的概念，在运行webpack时需要指定使用production或development两个mode其中一个，这个功能也就是我们所需要的运行两套构建环境的能力。</p>
<p>当你指定使用production mode时，默认会启用各种性能优化的功能，包括构建结果优化以及webpack运行性优化，而如果是development mode的话，则会开启debug工具，运行时打印详细的错误信息，以及更加快速的增量编译构建。关于这两个 mode 的更详细区别，可以查阅 webpack 作者的这篇文章：<code>webpack 4: mode and optimization</code>。</p>
<p>虽然webpack的mode参数已经给我们带来了很方便的环境差异化配置，但是针对一些项目的情况，例如使用css-loader或者url-loader等，不同环境传入loader的配置也不一样，而mode病没有帮组我们做这些事情，因此有些配置还是需要手动区分环境后来进行调整。</p>
<h2 id="在配置文件中区分mode"><a href="#在配置文件中区分mode" class="headerlink" title="在配置文件中区分mode"></a>在配置文件中区分mode</h2><hr>
<p>之前我们的配置文件都是直接对外暴露一个JS对象，这种方式暂时没有办法获取到webpack的mode参数，我们需要更换一种方式来处理配置。根据官方文档<code>多种配置类型</code>，配置文件可以对外暴露一个函数，因此我们可以这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env, argv</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// ... 其他配置</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimize: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 使用 argv 来获取 mode 参数的值</span></span><br><span class="line">    minimizer: argv.mode === <span class="string">'production'</span> ? [</span><br><span class="line">      <span class="keyword">new</span> UglifyJsPlugin(&#123; <span class="comment">/* 你自己的配置 */</span> &#125;), </span><br><span class="line">      <span class="comment">// 仅在我们要自定义压缩配置时才需要这么做</span></span><br><span class="line">      <span class="comment">// mode 为 production 时 webpack 会默认使用压缩 JS 的 plugin</span></span><br><span class="line">    ] : [],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这样获取mode之后，我们就能区分不同的构建环境，然后根据不同环境再对特殊的loader或plugin做额外的配置就可以了。</p>
<p>以上是webpck 4.x的做法，由于有了mode参数，区分就变的简答了。不过在当前业界还是使用webpck3.x版本居多，这里我们就简单介绍一下3.x如何区分环境。</p>
<p>webpack的运行环境是Node.js,我们可以通过Node.js提供的机制给要运行的webpack程序传递环境变量，来控制不同环境下的构建行为。例如，我们在npm的<code>script</code>字段添加一个用于生产环境的构建命令：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span>:&#123;</span><br><span class="line">     <span class="attr">"build"</span>: <span class="string">"NODE_ENV=production webpack"</span>,</span><br><span class="line">    <span class="attr">"develop"</span>: <span class="string">"NODE_ENV=development webpack-dev-server"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>webpack.config.js</code>文件可以通过<code>process.env.NODE_ENV</code>来过去命令传入的环境变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="comment">// 生产环境需要做的事情，如使用代码压缩插件等</span></span><br><span class="line">  config.plugins.push(<span class="keyword">new</span> UglifyJsPlugin())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure>
<h2 id="运行时的环境变量"><a href="#运行时的环境变量" class="headerlink" title="运行时的环境变量"></a>运行时的环境变量</h2><hr>
<p>我们使用webpack时传递的mode参数，是可以在我们的应用代码运行是，通过<code>process.env.NODE_EVN</code>这个变量来获取的。这样方便我们在运行是判断当前执行的构建环境，使用最多的场景莫过于控制是否打印debug信息。</p>
<p>下面这个简单的例子，在应用开发的代码中实现一个简单的console打印封装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'development'</span> &amp;&amp; <span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.log) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，以上是webpack4.x的做法，下面介绍一下3.x版本应该如何实现。这里需要用DefinePlugin插件，它可以帮助我们在构建是给运行时定义变量，那么我们只要在前面webpack3.x版本区分构建环境例子的基础上，再使用DefinePlugin添加环境变量即可影响运行时的代码。</p>
<p>在webpack的配置中添加DefinePlugin插件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// webpack 的配置</span></span><br><span class="line"></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="comment">// webpack 3.x 的 process.env.NODE_ENV 是通过手动在命令行中指定 NODE_ENV=... 的方式来传递的</span></span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常见的环境差异配置"><a href="#常见的环境差异配置" class="headerlink" title="常见的环境差异配置"></a>常见的环境差异配置</h2><hr>
<p>前面提及的使用环境变量的方式可以让我们在不同的构建环境中完成不同的构建需求，这里列举一下常见的webpack构建差异配置：</p>
<ul>
<li>生产环境需要分离CSS成单独的文件，以便多个页面课共享同一个CSS文件</li>
<li>生产环境需要压缩HTML/CSS/JS代码</li>
<li>生产环境需要压缩图片</li>
<li>生产环境需要生成sourcemap文件</li>
<li>开发环境需要打印debug信息</li>
<li>开发环境需要live reload或者hot reload的功能</li>
</ul>
<p>以上是常见的环境需求差异，可能更复杂的项目中会有更多的构建需求（如划分静态域名等），但是我们都可以通过判断环境变量来实现这些有环境差异的构建需求。</p>
<p>以上是常见的环境需求差异，可能更加复杂的项目我们会有更多的构建需求（如划分静态域名等），但是我们都可以通过判断环境变量来实现这些有环境差异的构建需求。</p>
<p>webpack4.x的mode已经提供了上述配置的大部分功能，mode为production时默认使用JS压缩代码，而mode为developement时默认启用hot reload，等等。这样让我们的配置更为简洁，我们只需要针对特别使用的loader和pugin做区分配置就可以了。</p>
<p>webapck 3.x版本还是只能自己动手修改配置来满足大部分环境差异需求，所以如果你要使用一个新的项目，建议使用webpack4.x版本。</p>
<h2 id="拆分配置"><a href="#拆分配置" class="headerlink" title="拆分配置"></a>拆分配置</h2><hr>
<p>前面我们列出了几个环境差异配置，可能这些构建需求就已经有点多了，会让整个webpack的配置变得复杂，尤其是有着大量环境变量判断的配置。我们可以吧webapck的配置按照不同环境拆分成多个文件，运行是直接根据环境变量加载对应的配置即可。基本可以划分如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* webapck.base.js:基础部分，即多个文件中的共享配置</span><br><span class="line">* webpack.development.js: 开发环境中使用的配置</span><br><span class="line">* webpack.production.js:生产环境中使用的配置</span><br><span class="line">* webpack.test.js 测试环境中使用的配置</span><br></pre></td></tr></table></figure>
<p>一些复杂的项目可能会有更多配置。这里介绍一下如何处理这样的配置拆分。</p>
<p>首先我们要明白，对于webpack的配置，其实是对外暴露一个JS对象，所以对于这个对象，我们都可以用JS代码来修改它，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// ... webpack 配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们可以修改这个 config 来调整配置，例如添加一个新的插件</span></span><br><span class="line">config.plugins.push(<span class="keyword">new</span> YourPlugin());</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<p>因此，只要有一个工具能够智能地合并多个配置对象，我们就可以轻松的拆分webapck配置，然后通过判断环境变量，使用工具将对应环境的多个配置对象整合后提供给webpack使用。这个工具就是<code>webpack-merge</code>。</p>
<p>我们webpack配置基础部分，即webpack.base.js应该大致是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'...'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里是一个简单的例子，后面介绍 API 时会用到</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">        use: [<span class="string">'babel'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后webpack.development.js需要添加loader或plugin，这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'...'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 这里是一个简单的例子，后面介绍 API 时会用到</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>, </span><br><span class="line">        use: [<span class="string">'babel'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后webpack.development.js需要添加loader或plugin，就可以使用webpack-merge的API，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; smart &#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> base = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = smart(base, &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 用 smart API，当这里的匹配规则相同且 use 值都是数组时，smart 会识别后处理</span></span><br><span class="line">      <span class="comment">// 和上述 base 配置合并后，这里会是 &#123; test: /\.js$/, use: ['babel', 'coffee'] &#125;</span></span><br><span class="line">      <span class="comment">// 如果这里 use 的值用的是字符串或者对象的话，那么会替换掉原本的规则 use 的值</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [<span class="string">'coffee'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// plugins 这里的数组会和 base 中的 plugins 数组进行合并</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV),</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可见webppack-marge提供的<code>smart</code>方法，可以帮助我们更加轻松地处理loader配置的合并。webpack-merge还有其他的API可以用于自定义合并行为，这里就不详细介绍了，需要更深入了解的同学可以直接查阅官方文档<code>webpack-merge</code>。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/开发和生产环境的构建配置差异/">开发和生产环境的构建配置差异</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/优化前端资源加载-2-分离代码文件/" title="优化前端资源加载 2 - 分离代码文件">优化前端资源加载 2 - 分离代码文件<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack-如何解析模块代码路径/" title="webpack 如何解析模块代码路径">webpack 如何解析模块代码路径<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack搭建前端基本环境/" title="webpack搭建前端基本环境">webpack搭建前端基本环境<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/使用Plugin/" title="使用Plugin">使用Plugin<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/用HRM提高开发效率/" title="用HRM提高开发效率">用HRM提高开发效率<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/更好的使用webpack-dev-server/" title="更好的使用webpack-dev-server">更好的使用webpack-dev-server<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/优化前端资源加载-3-进一步控制-JS-大小/" title="优化前端资源加载 3 - 进一步控制 JS 大小">优化前端资源加载 3 - 进一步控制 JS 大小<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/创建自己的loader/" title="创建自己的loader">创建自己的loader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/优化前端资源加载-1-图片加载优化和代码压缩/" title="优化前端资源加载 1 - 图片加载优化和代码压缩">优化前端资源加载 1 - 图片加载优化和代码压缩<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/几种移动端很常用的布局/" title="几种移动端很常用的布局">几种移动端很常用的布局<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/正则表达式总结/" title="正则表达式总结">正则表达式总结<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack的使用方法/" title="webpack的使用方法">webpack的使用方法<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/开发和生产环境的构建配置差异/" title="开发和生产环境的构建配置差异">开发和生产环境的构建配置差异<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/提升webpack的构建速度/" title="提升webpack的构建速度">提升webpack的构建速度<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/内部工作流程/" title="内部工作流程">内部工作流程<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/配置loader/" title="配置loader">配置loader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Vue中better-scroll/" title="Vue中better-scroll">Vue中better-scroll<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="xxinso">xxinso</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
