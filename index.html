
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="xxinso">
    

    
    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">

    
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Hexo" title="Hexo"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Hexo">Hexo</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/面试基础二/" title="面试基础二" itemprop="url">面试基础二</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T02:35:23.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="1-说一说js异步发展史"><a href="#1-说一说js异步发展史" class="headerlink" title="1.说一说js异步发展史"></a>1.说一说js异步发展史</h3><p>异步最早的解决方案是回调函数，如事件的回调，setInterval/setTimeout中的回调。但是回调函数有一个很常见的问题，就是回调地狱的问题(稍后会举例说明);</p>
<p>为了解决回调地狱的问题，社区提出了Promise解决方案，ES6将其写进了语言标准。Promise解决了回调地狱的问题，但是Promise也存在一些问题，如错误不能被try catch，而且使用Promise的链式调用，其实并没有从根本上解决回调地狱的问题，只是换了一种写法。</p>
<p>ES6引入了gennerater，Generator是一种异步编程解决方案，Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权，Generator 函数可以看出是异步任务的容器，需要暂停的地方，都用yield语句注明。但是 Generator 使用起来较为复杂。</p>
<p>ES7又提出了新的异步解决方案:async/await，async是 Generator 函数的语法糖，async/await 使得异步代码看起来像同步代码，异步编程发展的目标就是让异步逻辑的代码看起来像同步一样。</p>
<blockquote>
<p>1.回调函数: callback</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node读取文件</span></span><br><span class="line">fs.readFile(xxx, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数的使用场景(包括但不限于):</p>
<ul>
<li>1.事件回调</li>
<li>2.Node API</li>
<li>3.setTimeout/setInterval中的回调函数</li>
</ul>
<p>异步回调嵌套会导致代码难以维护，并且不方便统一处理错误，不能try catch 和 回调地狱(如先读取A文本内容，再根据A文本内容读取B再根据B的内容读取C…)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(A, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    fs.readFile(B, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        fs.readFile(C, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            fs.readFile(D, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">                <span class="comment">//....</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.Promise</p>
</blockquote>
<p>Promise 主要解决了回调地狱的问题，Promise 最早由社区提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>那么我们看看Promise是如何解决回调地狱问题的，仍然以上文的readFile为例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">read(A).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> read(B);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> read(C);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> read(D);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3.Generator</p>
</blockquote>
<p>Generator 函数是 ES6 提供的一种异步编程解决方案，整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。<br>Generator 函数一般配合 yield 或 Promise 使用。Generator函数返回的是迭代器。对生成器和迭代器不了解的同学，请自行补习下基础。下面我们看一下 Generator 的简单使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">111</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">222</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">333</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">yield</span> <span class="number">444</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = gen();</span><br><span class="line"><span class="comment">//next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</span></span><br><span class="line">t.next(<span class="number">1</span>); <span class="comment">//第一次调用next函数时，传递的参数无效</span></span><br><span class="line">t.next(<span class="number">2</span>); <span class="comment">//a输出2;</span></span><br><span class="line">t.next(<span class="number">3</span>); <span class="comment">//b输出3; </span></span><br><span class="line">t.next(<span class="number">4</span>); <span class="comment">//c输出4;</span></span><br><span class="line">t.next(<span class="number">5</span>); <span class="comment">//d输出5;</span></span><br></pre></td></tr></table></figure>
<p>仍然以上文的readFile为例，使用 Generator + co库来实现:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">const</span> bluebird = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = bluebird.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> readFile(A, <span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="keyword">yield</span> readFile(B, <span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="keyword">yield</span> readFile(C, <span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">co(read()).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4.async/await</p>
</blockquote>
<p>ES7中引入了 async/await 概念。async其实是一个语法糖，它的实现就是将Generator函数和自动执行器（co），包装在一个函数中。</p>
<p>async/await 的优点是代码清晰，不用像 Promise 写很多 then 链，就可以处理回调地狱的问题。错误可以被try catch。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> bluebird = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = bluebird.promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> readFile(A, <span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="keyword">await</span> readFile(B, <span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="keyword">await</span> readFile(C, <span class="string">'utf-8'</span>);</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-谈谈对-async-await-的理解，async-await-的实现原理是什么"><a href="#2-谈谈对-async-await-的理解，async-await-的实现原理是什么" class="headerlink" title="2.谈谈对 async/await 的理解，async/await 的实现原理是什么?"></a>2.谈谈对 async/await 的理解，async/await 的实现原理是什么?</h3><p>async/await就是Generater的语法糖，使异步变的更加方便</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">read</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oneStep = <span class="keyword">yield</span> readFile(<span class="string">"one"</span>,<span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">let</span> twoStep = <span class="keyword">yield</span> readFile(<span class="string">"two"</span>,<span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">let</span> threeStep = <span class="keyword">yield</span> readFile(<span class="string">"three"</span>,<span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">return</span> threeStep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">read</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> oneStep = <span class="keyword">await</span> readFile(<span class="string">"one"</span>,<span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">let</span> twoStep = <span class="keyword">await</span> readFile(<span class="string">"two"</span>,<span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">let</span> threeStep = <span class="keyword">await</span> readFile(<span class="string">"three"</span>,<span class="string">"utf-8"</span>);</span><br><span class="line">    <span class="keyword">return</span> threeStep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async 函数就是将 Generator 函数的星号（*）替换成 async，将 yield 替换成await。</p>
<blockquote>
<p>我们说 async 是 Generator 的语法糖，那么这个糖究竟甜在哪呢？</p>
</blockquote>
<ul>
<li><p>1.async函数内置执行器，函数调用之后，会自动执行，输出最后结果。而Generator需要调用next或者配合co模块使用。</p>
</li>
<li><p>2.更好的语义，async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
</li>
<li><p>3.更广的适用性。co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值。</p>
</li>
<li><p>4.返回值是Promise，async函数的返回值是 Promise 对象，Generator的返回值是 Iterator，Promise 对象使用起来更加方便。</p>
</li>
</ul>
<blockquote>
<p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
</blockquote>
<h3 id="3-使用-async-await-需要注意什么？"><a href="#3-使用-async-await-需要注意什么？" class="headerlink" title="3.使用 async/await 需要注意什么？"></a>3.使用 async/await 需要注意什么？</h3><p>1.await 命令后面的Promise对象，运行结果可能是 rejected，此时等同于 async 函数返回的 Promise 对象被reject。因此需要加上错误处理，可以给每个 await 后的 Promise 增加 catch 方法；也可以将 await 的代码放在 try…catch 中。<br>2.多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两种写法都可以同时触发</span></span><br><span class="line"><span class="comment">//法一</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, <span class="number">600</span>);</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, <span class="number">600</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    ])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, <span class="number">800</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> fn2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, <span class="number">800</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">await</span> fn1;</span><br><span class="line">    <span class="keyword">await</span> fn2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><ol>
<li>await命令只能用在async函数之中，如果用在普通函数，会报错。</li>
</ol>
</li>
<li><ol>
<li>async 函数可以保留运行堆栈。</li>
</ol>
</li>
</ul>
<h3 id="4-如何实现-Promise-race？"><a href="#4-如何实现-Promise-race？" class="headerlink" title="4.如何实现 Promise.race？"></a>4.如何实现 Promise.race？</h3><p>在代码实现前，我们需要先了解 Promise.race 的特点：</p>
<ul>
<li>1.Promise.race返回的仍然是一个Promise. 它的状态与第一个完成的Promise的状态相同。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个Promise是哪一种状态。</li>
<li>2.如果传入的参数是不可迭代的，那么将会抛出错误。</li>
<li>3.如果传的参数数组是空，那么返回的 promise 将永远等待。</li>
<li>4.如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//promises 必须是一个可遍历的数据结构，否则抛错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> promises[<span class="built_in">Symbol</span>.iterator] !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="comment">//真实不是这个错误</span></span><br><span class="line">            <span class="built_in">Promise</span>.reject(<span class="string">'args is not iteratable!'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">                <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                    resolve(data);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;, (err) =&gt; &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-可遍历数据结构的有什么特点？"><a href="#5-可遍历数据结构的有什么特点？" class="headerlink" title="5.可遍历数据结构的有什么特点？"></a>5.可遍历数据结构的有什么特点？</h3><p>一个对象如果要具备可被 for…of 循环调用的 Iterator 接口，就必须在其 Symbol.iterator 的属性上部署遍历器生成方法(或者原型链上的对象具有该方法)</p>
<p>PS: 遍历器对象根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如为对象添加Iterator 接口;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Yvette"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    job: <span class="string">'engineer'</span>,</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(self);</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; keys.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: self[keys[index++]],</span><br><span class="line">                        done: <span class="literal">false</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">//Yvette  18  engineer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Generator 函数(遍历器对象生成函数)简写 Symbol.iterator 方法，可以简写如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">"Yvette"</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    job: <span class="string">'engineer'</span>,</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator] () &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(self);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>;index &lt; keys.length; index++) &#123;</span><br><span class="line">            <span class="keyword">yield</span> self[keys[index]];<span class="comment">//yield表达式仅能使用在 Generator 函数中</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>原生具备 Iterator 接口的数据结构如下。</p>
</blockquote>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
<li>ES6 的数组、Set、Map 都部署了以下三个方法: entries() / keys() / values()，调用后都返回遍历器对象。</li>
</ul>
<h3 id="requestAnimationFrame-和-setTimeout-setInterval-有什么区别？使用-requestAnimationFrame-有哪些好处？"><a href="#requestAnimationFrame-和-setTimeout-setInterval-有什么区别？使用-requestAnimationFrame-有哪些好处？" class="headerlink" title="requestAnimationFrame 和 setTimeout/setInterval 有什么区别？使用 requestAnimationFrame 有哪些好处？"></a>requestAnimationFrame 和 setTimeout/setInterval 有什么区别？使用 requestAnimationFrame 有哪些好处？</h3><p>在 requestAnimationFrame 之前，我们主要使用 setTimeout/setInterval 来编写JS动画。</p>
<p>编写动画的关键是循环间隔的设置，一方面，循环间隔足够短，动画效果才能显得平滑流畅；另一方面，循环间隔还要足够长，才能确保浏览器有能力渲染产生的变化。</p>
<p>大部分的电脑显示器的刷新频率是60HZ，也就是每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会提升。因此，最平滑动画的最佳循环间隔是 1000ms / 60 ，约为16.7ms。</p>
<p>setTimeout/setInterval 有一个显著的缺陷在于时间是不精确的，setTimeout/setInterval 只能保证延时或间隔不小于设定的时间。因为它们实际上只是把任务添加到了任务队列中，但是如果前面的任务还没有执行完成，它们必须要等待。</p>
<p>requestAnimationFrame 才有的是系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p>
<p>综上所述，requestAnimationFrame 和 setTimeout/setInterval 在编写动画时相比，优点如下:</p>
<ul>
<li>1.requestAnimationFrame 不需要设置时间，采用系统时间间隔，能达到最佳的动画效果。</li>
<li>2.requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成。</li>
</ul>
<h3 id="7-JS-类型转换的规则是什么？"><a href="#7-JS-类型转换的规则是什么？" class="headerlink" title="7.JS 类型转换的规则是什么？"></a>7.JS 类型转换的规则是什么？</h3><p>JS的类型转换分为 强制类型转换和隐式类型转换</p>
<ul>
<li>通过 Number()、parseInt()、parseFloat()、toString()、String()、Boolean(),进行强制类型转换。</li>
<li>逻辑运算符(&amp;&amp;、 ||、 !)、运算符(+、-、*、/)、关系操作符(&gt;、 &lt;、 &lt;= 、&gt;=)、相等运算符(==)或者 if/while 的条件，可能会进行隐式类型转换。</li>
</ul>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><blockquote>
<p>1.Number() 将任意类型的参数转换为数值类型</p>
</blockquote>
<p>规则如下</p>
<ul>
<li>如果是布尔值，true和false分别被转换为1和0</li>
<li>如果是数字，返回自身</li>
<li>如果是 null，返回 0</li>
<li>如果是undefined返回NaN</li>
<li>如果是字符串，遵循以下规则:<br> 1.如果字符串中只包含数字(或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号)，则将其转换为十进制。<br> 2.如果字符串中包含有效的浮点格式，将其转换为浮点数值。<br> 3.如果是空字符串，将其转换为0。<br> 4.如不是以上格式的字符串，均返回 NaN</li>
<li>如果是Symbol，抛出错误</li>
<li>如果是对象，则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值。如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的规则转换返回的字符串值。<br>部分内置对象调用默认的 valueOf 的行为:</li>
</ul>
<table>
<thead>
<tr>
<th>对象</th>
<th style="text-align:center">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array</td>
<td style="text-align:center">数组本身（对象类型）</td>
</tr>
<tr>
<td>Boolean</td>
<td style="text-align:center">布尔值（原始类型）</td>
</tr>
<tr>
<td>Date</td>
<td style="text-align:center">从 UTC 1970 年 1 月 1 日午夜开始计算，到所封装的日期所经过的毫秒数</td>
</tr>
<tr>
<td>Function</td>
<td style="text-align:center">函数本身（对象类型）</td>
</tr>
<tr>
<td>Number</td>
<td style="text-align:center">数字值（原始类型）</td>
</tr>
<tr>
<td>Object</td>
<td style="text-align:center">对象本身（对象类型）</td>
</tr>
<tr>
<td>String</td>
<td style="text-align:center">字符串值（原始类型）</td>
</tr>
</tbody>
</table>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">'0111'</span>); <span class="comment">//111</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0X11'</span>) <span class="comment">//17</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">''</span>); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'1a'</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">-0X11</span>);<span class="comment">//-17</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.parseInt(param, radix)<br>如果第一个参数传入的是字符串类型:</p>
<ul>
<li>1.忽略字符串前面的空格，直至找到第一个非空字符，如果是空字符串，返回NaN</li>
<li>2.如果第一个字符不是数字符号或者正负号，返回NaN</li>
<li>3.如果第一个字符是数字/正负号，则继续解析直至字符串解析完毕或者遇到一个非数字符号为止</li>
</ul>
</blockquote>
<p>如果第一个参数传入的Number类型:</p>
<ul>
<li>1.数字如果是0开头，则将其当作八进制来解析(如果是一个八进制数)；如果以0x开头，则将其当作十六进制来解析。<br>如果第一个参数是 null 或者是 undefined，或者是一个对象类型：</li>
<li>1.返回NaN<br>如果第一个参数是数组： 1. 去数组的第一个元素，按照上面的规则进行解析<br>如果第一个参数是Symbol类型： 1. 抛出错误<br>如果指定radix参数，以radix为基数进行解析</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0111'</span>); <span class="comment">//111</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0111</span>); <span class="comment">//八进制数 73</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>);<span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0X11'</span>); <span class="comment">//17</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1a'</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'a1'</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>([<span class="string">'10aa'</span>,<span class="string">'aaa'</span>]);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>([]);<span class="comment">//NaN; parseInt(undefined);</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>toString()</p>
</blockquote>
<ul>
<li>如果是Number类型，输出数字字符串</li>
<li>如果是 null 或者是 undefined，抛错</li>
<li>如果是数组，那么将数组展开输出。空数组，返回’’</li>
<li>如果是对象，返回 [object Object]</li>
<li>如果是Date, 返回日期的文字表示法</li>
<li>如果是函数，输出对应的字符串(如下demo)</li>
<li>如果是Symbol，输出Symbol字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arry = [];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'稳住，我们能赢！'</span>)&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="built_in">console</span>.log([].toString()); <span class="comment">// ''</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">undefined</span>, <span class="number">5</span>, <span class="number">6</span>].toString());<span class="comment">//1,2,3,,5,6</span></span><br><span class="line"><span class="built_in">console</span>.log(arry.toString()); <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.toString()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(date.toString()); <span class="comment">// Sun Apr 21 2019 16:11:39 GMT+0800 (CST)</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.toString());<span class="comment">// function () &#123;console.log('稳住，我们能赢！')&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(str.toString());<span class="comment">// 'hello world'</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString());<span class="comment">// Symbol(100)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>.toString());<span class="comment">// 抛错</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>.toString());<span class="comment">// 抛错</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>String()<br>String() 的转换规则与 toString() 基本一致，最大的一点不同在于 null 和 undefined，使用 String 进行转换，null 和 undefined对应的是字符串 ‘null’ 和 ‘undefined’</p>
</blockquote>
<blockquote>
<p>Boolean<br>除了 undefined、 null、 false、 ‘’、 0(包括 +0，-0)、 NaN 转换出来是false，其它都是true.</p>
</blockquote>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><blockquote>
<p>&amp;&amp; 、|| 、 ! 、 if/while 的条件判断<br>需要将数据转换成 Boolean 类型，转换规则同 Boolean 强制类型转换</p>
</blockquote>
<blockquote>
<p>运算符: + - * /</p>
</blockquote>
<ul>
<li>号操作符，不仅可以用作数字相加，还可以用作字符串拼接。<br>仅当 + 号两边都是数字时，进行的是加法运算。如果两边都是字符串，直接拼接，无需进行隐式类型转换。</li>
</ul>
<p>除了上面的情况外，如果操作数是对象、数值或者布尔值，则调用toString()方法取得字符串值(toString转换规则)。对于 undefined 和 null，分别调用String()显式转换为字符串，然后再进行拼接。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(&#123;&#125;+<span class="number">10</span>); <span class="comment">//[object Object]10</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">undefined</span>, <span class="number">5</span>, <span class="number">6</span>] + <span class="number">10</span>);<span class="comment">//1,2,3,,5,610</span></span><br></pre></td></tr></table></figure>
<p>-、*、/ 操作符针对的是运算，如果操作值之一不是数值，则被隐式调用Number()函数进行转换。如果其中有一个转换除了为NaN，结果为NaN.</p>
<blockquote>
<p>关系操作符: ==、&gt;、&lt; 、&lt;=、&gt;=<br><strong>&gt;</strong>, <strong>&lt;</strong>,<strong>&lt;=</strong>,<strong>&gt;=</strong></p>
</blockquote>
<ul>
<li>1.如果两个操作值都是数值，则进行数值比较</li>
<li>2.如果两个操作值都是字符串，则比较字符串对应的字符编码值</li>
<li>3.如果有一方是Symbol类型，抛出错误</li>
<li>4.除了上述情况之外，都进行Number()进行类型转换，然后再进行比较。</li>
</ul>
<p>注: NaN是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回false。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10</span> &gt; &#123;&#125;);<span class="comment">//返回false.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *&#123;&#125;.valueOf ---&gt; &#123;&#125;</span></span><br><span class="line"><span class="comment"> *&#123;&#125;.toString() ---&gt; '[object Object]' ---&gt; NaN</span></span><br><span class="line"><span class="comment"> *NaN 和 任何类型比大小，都返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1.如果类型相同，无需进行类型转换。</li>
<li>2.如果其中一个操作值是 null 或者是 undefined，那么另一个操作符必须为 null 或者 undefined 时，才返回 true，否则都返回 false。</li>
<li>3.如果其中一个是 Symbol 类型，那么返回 false。</li>
<li>4.两个操作值是否为 string 和 number，就会将字符串转换为 number。</li>
<li>5.如果一个操作值是 boolean，那么转换成 number。</li>
<li>6.如果一个操作值为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断(调用object的valueOf/toString方法进行转换)</li>
</ul>
<blockquote>
<p>对象如何转换成原始数据类型<br>如果部署了 [Symbol.toPrimitive] 接口，那么调用此接口，若返回的不是基础数据类型，抛出错误。</p>
</blockquote>
<p>如果没有部署 [Symbol.toPrimitive] 接口，那么先返回 valueOf() 的值，若返回的不是基础类型的值，再返回 toString() 的值，若返回的不是基础类型的值， 则抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/先调用 valueOf, 后调用 toString</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    valueOf() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">300</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果 valueOf 返回的不是基本数据类型，则会调用 toString， </span></span><br><span class="line"><span class="comment">//如果 toString 返回的也不是基本数据类型，会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(obj + <span class="number">200</span>); <span class="comment">//400</span></span><br></pre></td></tr></table></figure>
<h3 id="8-简述下对-webWorker-的理解？"><a href="#8-简述下对-webWorker-的理解？" class="headerlink" title="8.简述下对 webWorker 的理解？"></a>8.简述下对 webWorker 的理解？</h3><p>HTML5则提出了 Web Worker 标准，表示js允许多线程，但是子线程完全受主线程控制并且不能操作dom，只有主线程可以操作dom，所以js本质上依然是单线程语言。</p>
<p>web worker就是在js单线程执行的基础上开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完之后再回到主线程上，在这个过程中不影响主线程的执行。子线程与主线程之间提供了数据交互的接口postMessage和onmessage，来进行数据发送和接收。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'./worker.js'</span>); <span class="comment">//创建一个子线程</span></span><br><span class="line">worker.postMessage(<span class="string">'Hello'</span>);</span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data); <span class="comment">//Hi</span></span><br><span class="line">    worker.terminate(); <span class="comment">//结束线程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data); <span class="comment">//Hello</span></span><br><span class="line">    postMessage(<span class="string">"Hi"</span>); <span class="comment">//向主进程发送消息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仅是最简示例代码，项目中通常是将一些耗时较长的代码，放在子线程中运行。</p>
<h3 id="9-ES6模块和CommonJS模块的差异？"><a href="#9-ES6模块和CommonJS模块的差异？" class="headerlink" title="9.ES6模块和CommonJS模块的差异？"></a>9.ES6模块和CommonJS模块的差异？</h3><ul>
<li><ol>
<li>ES6模块在编译时，就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 模块，运行时加载。</li>
</ol>
</li>
<li><ol>
<li>ES6 模块自动采用严格模式，无论模块头部是否写了 “use strict”;</li>
</ol>
</li>
<li><ol>
<li>require 可以做动态加载，import 语句做不到，import 语句必须位于顶层作用域中。</li>
</ol>
</li>
<li><ol>
<li>ES6 模块中顶层的 this 指向 undefined，CommonJS 模块的顶层 this 指向当前模块。</li>
</ol>
</li>
<li><ol>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li>
</ol>
</li>
</ul>
<p>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'William'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> name = <span class="string">'Yvette'</span>, <span class="number">200</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    name</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="built_in">require</span>(<span class="string">'./name'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">//William</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(name), <span class="number">300</span>); <span class="comment">//William</span></span><br></pre></td></tr></table></figure>
<p>对比 ES6 模块看一下:<br>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import ，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</p>
<h3 id="10-浏览器的时间代理机制是什么"><a href="#10-浏览器的时间代理机制是什么" class="headerlink" title="10.浏览器的时间代理机制是什么"></a>10.浏览器的时间代理机制是什么</h3><p>在说浏览器事件代理机制原理之前，我们首先了解一下事件流的概念，早期浏览器，IE采用的是事件冒泡事件流，而Netscape采用的则是事件捕获。”DOM2级事件”把事件流分为三个阶段，捕获阶段、目标阶段、冒泡阶段。现代浏览器也都遵循此规范</p>
<blockquote>
<p>那么事件代理是什么呢？<br>时间代理又成为事件委托，在祖先级DOM元素绑定一个事件，当触发子孙级DOM元素的事件时，利用事件冒泡的原理来触发绑定在祖先级DOM的事件。因为事件会从目标元素一层层冒泡至document对象。<br>为什么要事件代理？</p>
<ol>
<li>添加到页面的事件数量回影响页面的运行性能，如果添加的事件过多，会导致网页的性能下降。采用事件代理的方式，可以大大减少注册事件的个数。</li>
<li>事件代理的当时，某个子孙元素是动态增加的，不需要再次对其进行事件绑定。</li>
<li>不用担心某个注册了事件的DOM元素被移除后，可能无法回收其事件处理程序，我们只要把事件处理程序委托给更高层级的元素，就可以避免此问题。</li>
</ol>
</blockquote>
<blockquote>
<p>如将页面中的所有click事件都代理到document上:</p>
</blockquote>
<p>addEventListener 接受3个参数，分别是要处理的事件名、处理事件程序的函数和一个布尔值。布尔值默认为false。表示冒泡阶段调用事件处理程序，若设置为true，表示在捕获阶段调用事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 捕获阶段调用调用事件处理程序，eventPhase是 1; </span></span><br><span class="line"><span class="comment">    * 处于目标，eventPhase是2 </span></span><br><span class="line"><span class="comment">    * 冒泡阶段调用事件处理程序，eventPhase是 1；</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="built_in">console</span>.log(e.eventPhase);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="11-js如何自定义事件？"><a href="#11-js如何自定义事件？" class="headerlink" title="11.js如何自定义事件？"></a>11.js如何自定义事件？</h3><blockquote>
<p>自定义 DOM 事件(不考虑IE9之前版本)<br>自定义事件有三种方法,一种是使用 <strong>new Event()</strong>, 另一种是 <strong>createEvent(‘CustomEvent’)</strong> , 另一种是 <strong>new customEvent()</strong></p>
</blockquote>
<p>1.使用<strong>new Event()</strong><br>获取不到<strong>event.detail</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="keyword">let</span> ev = <span class="keyword">new</span> Event(<span class="string">'alert'</span>, &#123;</span><br><span class="line">    bubbles: <span class="literal">true</span>,    <span class="comment">//事件是否冒泡;默认值false</span></span><br><span class="line">    cancelable: <span class="literal">true</span>, <span class="comment">//事件能否被取消;默认值false</span></span><br><span class="line">    composed: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">btn.addEventListener(<span class="string">'alert'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.bubbles); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.cancelable); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.detail); <span class="comment">//undefined</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">btn.dispatchEvent(ev);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-createEvent-‘CustomEvent’-DOM3"><a href="#使用-createEvent-‘CustomEvent’-DOM3" class="headerlink" title="使用 createEvent(‘CustomEvent’) (DOM3)"></a>使用 createEvent(‘CustomEvent’) (DOM3)</h3><p>要创建自定义事件，可以调用 <strong>createEvent(‘CustomEvent’)</strong>，返回的对象有 initCustomEvent 方法，接受以下四个参数:</p>
<ul>
<li>type: 字符串，表示触发的事件类型，如此处的’alert’</li>
<li>bubbles: 布尔值： 表示事件是否冒泡</li>
<li>cancelable: 布尔值，表示事件是否可以取消</li>
<li>detail: 任意值，保存在 event 对象的 detail 属性中</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="keyword">let</span> ev = btn.createEvent(<span class="string">'CustomEvent'</span>);</span><br><span class="line">ev.initCustomEvent(<span class="string">'alert'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="string">'button'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'alert'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.bubbles); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.cancelable);<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.detail); <span class="comment">//button</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">btn.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>
<h3 id="使用-new-customEvent-DOM4"><a href="#使用-new-customEvent-DOM4" class="headerlink" title="使用 new customEvent() (DOM4)"></a>使用 new customEvent() (DOM4)</h3><p>使用起来比 <strong>createEvent(‘CustomEvent’)</strong> 更加方便</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一个参数是事件类型</span></span><br><span class="line"><span class="comment"> * 第二个参数是一个对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> CustomEvent(<span class="string">'alert'</span>, &#123;</span><br><span class="line">    bubbles: <span class="string">'true'</span>,</span><br><span class="line">    cancelable: <span class="string">'true'</span>,</span><br><span class="line">    detail: <span class="string">'button'</span></span><br><span class="line">&#125;);</span><br><span class="line">btn.addEventListener(<span class="string">'alert'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.bubbles); <span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.cancelable);<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(event.detail); <span class="comment">//button</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">btn.dispatchEvent(ev);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自定义非 DOM 事件(观察者模式)</p>
</blockquote>
<p>EventTarget类型有一个单独的属性handlers，用于存储事件处理程序（观察者）。</p>
<p>addHandler() 用于注册给定类型事件的事件处理程序；</p>
<p>fire() 用于触发一个事件；</p>
<p>removeHandler() 用于注销某个事件类型的事件处理程序。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EventTarget</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handlers = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">EventTarget.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>:EventTarget,</span><br><span class="line">    addHandler:function(type,handler)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.handlers[type] === <span class="string">"undefined"</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.handlers[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handlers[type].push(handler);</span><br><span class="line">    &#125;,</span><br><span class="line">    fire:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!event.target)&#123;</span><br><span class="line">            event.target = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.handlers[event.type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> handlers = <span class="keyword">this</span>.handlers[event.type];</span><br><span class="line">            handlers.forEach(<span class="function">(<span class="params">handler</span>)=&gt;</span>&#123;</span><br><span class="line">                handler(event);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeHandler:<span class="function"><span class="keyword">function</span>(<span class="params">type,handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.handlers[type] <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> handlers = <span class="keyword">this</span>.handlers[type];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = handlers.length; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(handlers[i] === handler)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            handlers.splice(i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个新对象</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="keyword">new</span> EventTarget();</span><br><span class="line"><span class="comment">//添加一个事件处理程序</span></span><br><span class="line">target.addHandler(<span class="string">"message"</span>, handleMessage);</span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line">target.fire(&#123;<span class="attr">type</span>:<span class="string">"message"</span>, <span class="attr">message</span>:<span class="string">"Hi"</span>&#125;); <span class="comment">//Hi</span></span><br><span class="line"><span class="comment">//删除事件处理程序</span></span><br><span class="line">target.removeHandler(<span class="string">"message"</span>,handleMessage);</span><br><span class="line"><span class="comment">//再次触发事件，没有事件处理程序</span></span><br><span class="line">target.fire(&#123;<span class="attr">type</span>:<span class="string">"message"</span>,<span class="attr">message</span>: <span class="string">"Hi"</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-跨域的方法有哪些？原理是什么？"><a href="#12-跨域的方法有哪些？原理是什么？" class="headerlink" title="12.跨域的方法有哪些？原理是什么？"></a>12.跨域的方法有哪些？原理是什么？</h3><p>知其然知其所以然，在说跨域方法之前，我们先了解下什么叫跨域，浏览器有同源策略，只有当“协议”、“域名”、“端口号”都相同时，才能称之为是同源，其中有一个不同，即是跨域。</p>
<p>那么同源策略的作用是什么呢？同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p>
<p>那么我们又为什么需要跨域呢？一是前端和服务器分开部署，接口请求需要跨域，二是我们可能会加载其它网站的页面作为iframe内嵌。</p>
<blockquote>
<p>跨域的方法有哪些？<br>常用的跨域方法</p>
</blockquote>
<p>1.jsonp<br>尽管浏览器有同源策略，但是<code>&lt;script&gt;</code> 标签的 src 属性不会被同源策略所约束，可以获取任意服务器上的脚本并执行。jsonp 通过插入script标签的方式来实现跨域，参数只能通过url传入，仅能支持get请求。</p>
<p>实现原理:<br>step1: 创建 callback 方法<br>step2: 插入 script 标签<br>Step3: 后台接受到请求，解析前端传过去的 callback 方法，返回该方法的调用，并且数据作为参数传入该方法<br>Step4: 前端执行服务端返回的方法调用<br>下面代码仅为说明 jsonp 原理，项目中请使用成熟的库。分别看一下前端和服务端的简单实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前端代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123;url, params, cb&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//创建script标签</span></span><br><span class="line">        <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">        <span class="comment">//将回调函数挂在 window 上</span></span><br><span class="line">        <span class="built_in">window</span>[cb] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            resolve(data);</span><br><span class="line">            <span class="comment">//代码执行后，删除插入的script标签</span></span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回调函数加在请求地址上</span></span><br><span class="line">        params = &#123;...params, cb&#125; <span class="comment">//wb=b&amp;cb=show</span></span><br><span class="line">        <span class="keyword">let</span> arrs = [];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">            arrs.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">'&amp;'</span>)&#125;</span>`</span>;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">    url: <span class="string">'http://localhost:3000/say'</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;,</span><br><span class="line">    cb: <span class="string">'sayHi'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端代码</span></span><br><span class="line"><span class="comment">//express启动一个后台服务</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">let</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/say'</span>, (req, res) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;cb&#125; = req.query; <span class="comment">//获取传来的callback函数名，cb是key</span></span><br><span class="line">    res.send(<span class="string">`<span class="subst">$&#123;cb&#125;</span>('Hello!')`</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>2.cors<br>jsonp 只能支持 get 请求，cors 可以支持多种请求。cors 并不需要前端做什么工作。</p>
<blockquote>
<p>简单跨域请求:<br>只要服务器设置的Access-Control-Allow-Origin Header和请求来源匹配，浏览器就允许跨域</p>
<ul>
<li>1.请求的方法是get，head或者post。</li>
<li>2.Content-Type是application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一个值，或者不设置也可以，一般默认就是application/x-www-form-urlencoded。</li>
<li>3.请求中没有自定义的HTTP头部，如x-token。(应该是这几种头部 Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type）</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单跨域请求</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'XXXX'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>&lt; 带预检(Preflighted)的跨域请求</p>
<p>不满于简单跨域请求的，即是带预检的跨域请求。服务端需要设置 Access-Control-Allow-Origin (允许跨域资源请求的域) 、 Access-Control-Allow-Methods (允许的请求方法) 和 Access-Control-Allow-Headers (允许的请求头)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'XXX'</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'XXX'</span>); <span class="comment">//允许返回的头</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'XXX'</span>);<span class="comment">//允许使用put方法请求接口</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Max-Age'</span>, <span class="number">6</span>); <span class="comment">//预检的存活时间</span></span><br><span class="line">    <span class="keyword">if</span>(req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">        res.end(); <span class="comment">//如果method是OPTIONS，不做处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h3><p>使用nginx反向代理实现跨域，只需要修改nginx的配置即可解决跨域问题。</p>
<p>A网站向B网站请求某个接口时，向B网站发送一个请求，nginx根据配置文件接收这个请求，代替A网站向B网站来请求。 nginx拿到这个资源后再返回给A网站，以此来解决了跨域问题。</p>
<p>例如nginx的端口号为 8090，需要请求的服务器端口号为 3000。（localhost:8090 请求 localhost:3000/say）</p>
<p>nginx配置如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       <span class="number">8090</span>;</span><br><span class="line"></span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /Users/liuyan35/Test/Study/CORS/<span class="number">1</span>-jsonp;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    location /say &#123;</span><br><span class="line">        rewrite  ^<span class="regexp">/say/</span>(.*)$ /$<span class="number">1</span> <span class="keyword">break</span>;</span><br><span class="line">        proxy_pass   http:<span class="comment">//localhost:3000;</span></span><br><span class="line">        add_header <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;</span><br><span class="line">        add_header <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">        add_header <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    # others</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.websocket</p>
<p>Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。</p>
<p>Websocket 不受同源策略影响，只要服务器端支持，无需任何配置就支持跨域。</p>
<p>5.postMessage<br>postMessage 通过用作前端页面之前的跨域，如父页面与iframe页面的跨域。window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
<p>话说工作中两个页面之前需要通信的情况并不多，我本人工作中，仅使用过两次，一次是H5页面中发送postMessage信息，ReactNative的webview中接收此此消息，并作出相应处理。另一次是可轮播的页面，某个轮播页使用的是iframe页面，为了解决滑动的事件冲突，iframe页面中去监听手势，发送消息告诉父页面是否左滑和右滑。</p>
<blockquote>
<p>子页面向父页面发消息</p>
</blockquote>
<p>父页面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.movePage(e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>子页面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="comment">/*左滑*/</span>) &#123;</span><br><span class="line">    <span class="built_in">window</span>.parent &amp;&amp; <span class="built_in">window</span>.parent.postMessage(<span class="number">-1</span>, <span class="string">'*'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="comment">/*右滑*/</span>)&#123;</span><br><span class="line">    <span class="built_in">window</span>.parent &amp;&amp; <span class="built_in">window</span>.parent.postMessage(<span class="number">1</span>, <span class="string">'*'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>父页面向子页面发消息</p>
</blockquote>
<p>父页面</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'#iframe'</span>);</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.contentWindow.postMessage(<span class="string">'hello'</span>, <span class="string">'http://localhost:3002'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子页面:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">    e.source.postMessage(<span class="string">'Hi'</span>, e.origin); <span class="comment">//回消息</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>6.node中间件<br>node 中间件的跨域原理和nginx代理跨域，同源策略是浏览器的限制，服务端没有同源策略。<br>node中间件实现跨域的原理如下:</p>
<ul>
<li>1.接受客户端请求</li>
<li>2.将请求 转发给服务器。</li>
<li>3.拿到服务器 响应 数据。</li>
<li>4.将 响应 转发给客户端。</li>
</ul>
<h3 id="js异步加载有哪些"><a href="#js异步加载有哪些" class="headerlink" title="js异步加载有哪些"></a>js异步加载有哪些</h3><ul>
<li>1.<code>&lt;script&gt;</code> 的 defer 属性，HTML4 中新增</li>
<li>2.<code>&lt;script&gt;</code> 的 async 属性，HTML5 中新增</li>
<li><code>&lt;script&gt;</code>标签打开defer属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</li>
<li>defer 和 async 的区别在于: defer要等到整个页面在内存中正常渲染结束，才会执行；</li>
<li>async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。defer是“渲染完再执行”，async是“下载完就执行”。<br>如果有多个 defer 脚本，会按照它们在页面出现的顺序加载。<br>如果有多个 async 脚本，会按照它们在页面出现的顺序加载。</li>
</ul>
<p>3.动态插入<code>script</code>脚本<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadJS</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    varelement = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>); </span><br><span class="line">    element.src = <span class="string">"XXX.js"</span>; </span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//何时的时候，调用上述方法</span></span><br></pre></td></tr></table></figure></p>
<p>4.有条件的动态创建脚本<br>如页面 onload 之后。</p>
<h3 id="下面代码a在什么情况中打印出1？"><a href="#下面代码a在什么情况中打印出1？" class="headerlink" title="下面代码a在什么情况中打印出1？"></a>下面代码a在什么情况中打印出1？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//?</span></span><br><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span> &amp;&amp; a == <span class="number">2</span> &amp;&amp; a == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.在类型转换的时候，我们知道了对象如何转换成原始数据类型。如果部署了 [Symbol.toPrimitive]，那么返回的就是Symbol.toPrimitive的返回值。当然，我们也可以把此函数部署在valueOf或者是toString接口上，效果相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用闭包延长作用域的特性</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.利用Object.defineProperty在window/global上定义a属性，获取a属性时，会调用get.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">'a'</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.利用数组的特性<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.join = a.shift;</span><br></pre></td></tr></table></figure></p>
<h3 id="实现双向绑定-Proxy-与-Object-defineProperty-相比优劣如何"><a href="#实现双向绑定-Proxy-与-Object-defineProperty-相比优劣如何" class="headerlink" title="实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?"></a>实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?</h3><ul>
<li><p>1.Object.definedProperty 的作用是劫持一个对象的属性，劫持属性的getter和setter方法，在对象的属性发生变化时进行特定的操作。而 Proxy 劫持的是整个对象。</p>
</li>
<li><p>2.Proxy 会返回一个代理对象，我们只需要操作新对象即可，而 Object.defineProperty 只能遍历对象属性直接修改。</p>
</li>
<li><p>3.Object.definedProperty 不支持数组，更准确的说是不支持数组的各种API，因为如果仅仅考虑arry[i] = value 这种情况，是可以劫持的，但是这种劫持意义不大。而 Proxy 可以支持数组的各种API。</p>
</li>
<li><p>4.尽管 Object.defineProperty 有诸多缺陷，但是其兼容性要好于 Proxy.</p>
</li>
</ul>
<p>Vue2.x使用使用 Object.defineProperty 实现数据双向绑定,V3.0 则使用了 Proxy.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拦截器</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> temp = <span class="string">'Yvette'</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'name'</span>, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"读取成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"设置成功"</span>);</span><br><span class="line">        temp = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'Chris'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br></pre></td></tr></table></figure>
<p>Object.defineProperty 定义出来的属性，默认是不可枚举，不可更改，不可配置[无法delete]</p>
<p>我们可以看到 Proxy 会劫持整个对象，读取对象中的属性或者是修改属性值，那么就会被劫持。但是有点需要注意，复杂数据类型，监控的是引用地址，而不是值，如果引用地址没有改变，那么不会触发set。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>: <span class="string">'Yvette'</span>, <span class="attr">hobbits</span>: [<span class="string">'travel'</span>, <span class="string">'reading'</span>], <span class="attr">info</span>: &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    job: <span class="string">'engineer'</span></span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    get(target, key) &#123; <span class="comment">//第三个参数是 proxy， 一般不使用</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'读取成功'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        <span class="keyword">if</span>(key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如果是数组长度的变化，返回。</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'设置成功'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set([target, key, value]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.name = <span class="number">20</span>; <span class="comment">//设置成功</span></span><br><span class="line">p.age = <span class="number">20</span>; <span class="comment">//设置成功; 不需要事先定义此属性</span></span><br><span class="line">p.hobbits.push(<span class="string">'photography'</span>); <span class="comment">//读取成功;注意不会触发设置成功</span></span><br><span class="line">p.info.age = <span class="number">18</span>; <span class="comment">//读取成功;不会触发设置成功</span></span><br></pre></td></tr></table></figure>
<p>最后，我们再看下对于数组的劫持，Object.definedProperty 和 Proxy 的差别</p>
<p>Object.definedProperty 可以将数组的索引作为属性进行劫持，但是仅支持直接对 arry[i] 进行操作，不支持数组的API，非常鸡肋。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arry = []</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arry, <span class="string">'0'</span>, &#123;</span><br><span class="line">    get() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"读取成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    &#125;,</span><br><span class="line">    set(value) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"设置成功"</span>);</span><br><span class="line">        temp = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">arry[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">//触发设置成功</span></span><br><span class="line">arry.push(<span class="number">10</span>); <span class="comment">//不能被劫持</span></span><br></pre></td></tr></table></figure>
<p>Proxy 可以监听到数组的变化，支持各种API。注意数组的变化触发get和set可能不止一次，如有需要，自行根据key值决定是否要进行处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hobbits = [<span class="string">'travel'</span>, <span class="string">'reading'</span>];</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(hobbits, &#123;</span><br><span class="line">    get(target, key) &#123;</span><br><span class="line">        <span class="comment">// if(key === 'length') return true; //如果是数组长度的变化，返回。</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'读取成功'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        <span class="comment">// if(key === 'length') return true; //如果是数组长度的变化，返回。</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'设置成功'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set([target, key, value]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.splice(<span class="number">0</span>,<span class="number">1</span>) <span class="comment">//触发get和set，可以被劫持</span></span><br><span class="line">p.push(<span class="string">'photography'</span>);<span class="comment">//触发get和set</span></span><br><span class="line">p.slice(<span class="number">1</span>); <span class="comment">//触发get；因为 slice 是不会修改原数组的</span></span><br></pre></td></tr></table></figure>
<h3 id="Object-is-与比较操作符-、-有什么区别？"><a href="#Object-is-与比较操作符-、-有什么区别？" class="headerlink" title="Object.is() 与比较操作符 ===、== 有什么区别？"></a>Object.is() 与比较操作符 ===、== 有什么区别？</h3><p>以下情况，Object.is认为是相等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">两个值都是 <span class="literal">undefined</span></span><br><span class="line">两个值都是 <span class="literal">null</span></span><br><span class="line">两个值都是 <span class="literal">true</span> 或者都是 <span class="literal">false</span></span><br><span class="line">两个值是由相同个数的字符按照相同的顺序组成的字符串</span><br><span class="line">两个值指向同一个对象</span><br><span class="line">两个值都是数字并且</span><br><span class="line">都是正零 +<span class="number">0</span></span><br><span class="line">都是负零 <span class="number">-0</span></span><br><span class="line">都是 <span class="literal">NaN</span></span><br><span class="line">都是除零和 <span class="literal">NaN</span> 外的其它同一个数字</span><br></pre></td></tr></table></figure>
<p>Object.is() 类似于 ===，但是有一些细微差别，如下：</p>
<ul>
<li>1.NaN 和 NaN 相等</li>
<li>2.-0 和 +0 不相等</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">-0</span>, +<span class="number">0</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-0</span> === +<span class="number">0</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>Object.is 和 ==差得远了， == 在类型不同时，需要进行类型转换，前文已经详细说明。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/面试基础/">面试基础</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/面试基础一/" title="面试基础一" itemprop="url">面试基础一</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T02:35:23.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h4 id="1-基本类型有哪几种？null-是对象吗？基本数据类型和复杂数据类型存储有什么区别？"><a href="#1-基本类型有哪几种？null-是对象吗？基本数据类型和复杂数据类型存储有什么区别？" class="headerlink" title="1.基本类型有哪几种？null 是对象吗？基本数据类型和复杂数据类型存储有什么区别？"></a>1.基本类型有哪几种？null 是对象吗？基本数据类型和复杂数据类型存储有什么区别？</h4><ul>
<li>基本类型有6种，分别是undefined、null、bool、string、number、symbol（ES6）更新。</li>
<li>虽然 typeof null 返回的值是 object,但是null不是对象，而是基本数据类型的一种。</li>
<li>复杂数据类型的值存储在内存，地址（指向堆的值）存储在栈内存，当我们把对象赋值给另一个变量的时候复制的是地址，指向同一块内存空间，当其中的一个对象改变时，另一个也会跟着改变。</li>
</ul>
<h4 id="typeof-是否正确判断类型-instanceof呢？-instanceof-的实现原理是什么？"><a href="#typeof-是否正确判断类型-instanceof呢？-instanceof-的实现原理是什么？" class="headerlink" title="typeof 是否正确判断类型? instanceof呢？ instanceof 的实现原理是什么？"></a>typeof 是否正确判断类型? instanceof呢？ instanceof 的实现原理是什么？</h4><ul>
<li><p>首先 typeof 能够正确的判断基本数据类型，但是除了 null, typeof null输出的是对象。</p>
</li>
<li><p>但是对象来说，typeof 不能正确的判断其类型， typeof 一个函数可以输出 ‘function’,而除此之外，输出的全是 object,这种情况下，我们无法准确的知道对象的类型。</p>
</li>
<li><p>instanceof可以准确的判断复杂数据类型，但是不能正确判断基本数据类型。<code>A instanceof B</code> 在A的原型链中层层查找，是否有原型等于B.prototype,如果一直找到A的原型链的顶端(null;即Object.<strong>proto</strong>.<strong>proto</strong>),仍然不等于B.prototype，那么返回false，否则返回true.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// L instanceof R</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instance_of</span>(<span class="params">L, R</span>) </span>&#123;<span class="comment">//L 表示左表达式，R 表示右表达式</span></span><br><span class="line">    <span class="keyword">var</span> O = R.prototype;<span class="comment">// 取 R 的显式原型</span></span><br><span class="line">    L = L.__proto__;    <span class="comment">// 取 L 的隐式原型</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (L === <span class="literal">null</span>) <span class="comment">//已经找到顶层</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">if</span> (O === L)   <span class="comment">//当 O 严格等于 L 时，返回 true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        L = L.__proto__;  <span class="comment">//继续向上一层原型链查找</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-for-of-for-in-和-forEach-map-的区别。"><a href="#3-for-of-for-in-和-forEach-map-的区别。" class="headerlink" title="3. for of , for in 和 forEach,map 的区别。"></a>3. for of , for in 和 forEach,map 的区别。</h4><ul>
<li>具有 iterator 接口，就可以用for…of循环遍历它的成员(属性值)。for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象、Generator 对象，以及字符串。for…of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。对于普通的对象，for…of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。可以中断循环。</li>
<li>for…in…循环: 遍历对象自身的和继承的可枚举的属性, 不能直接获取属性值。可以中断循环。</li>
<li>forEach: 只能遍历数组，不能中断，没有返回值(或认为返回值是undefined)。</li>
<li>map: 只能遍历数组，不能中断，返回值是修改后的数组。</li>
</ul>
<p><strong>关于forEach是否会改变原数组的问题，为此我写了代码测试了下(注意数组项是复杂数据类型的情况)。 除了forEach之外，map等API，也有同样的问题。</strong></p>
<h3 id="4-如何判断一个变量是不是数组？"><a href="#4-如何判断一个变量是不是数组？" class="headerlink" title="4. 如何判断一个变量是不是数组？"></a>4. 如何判断一个变量是不是数组？</h3><ul>
<li>使用 Array.isArray 判断，如果返回 true, 说明是数组</li>
<li>使用instanceof Array判断如果返回的是true，说明是数组</li>
<li>使用Object.prototype.toString.call判断，如果值是[Object,Array],说明是数组。</li>
</ul>
<h3 id="5-类数组和数组的区别是什么"><a href="#5-类数组和数组的区别是什么" class="headerlink" title="5.类数组和数组的区别是什么"></a>5.类数组和数组的区别是什么</h3><ul>
<li><p>1）拥有length属性，其它属性（索引）为非负整数（对象中的索引会被当做字符串来处理）;</p>
</li>
<li><p>2）不具有数组所具有的方法；</p>
</li>
</ul>
<p>类数组是一个普通对象，而真实的数组是Array类型。常见的类数组有: 函数的参数 arguments, DOM 对象列表(比如通过 document.querySelectorAll 得到的列表), jQuery 对象 (比如 $(“div”)).</p>
<p>类数组可以转换为数组:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(arrayLike, start);</span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line">[...arrayLike];</span><br><span class="line"><span class="comment">//第三种方法:</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure>
<p>PS: 任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。</p>
<p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。</p>
<h3 id="6-和-有什么区别？"><a href="#6-和-有什么区别？" class="headerlink" title="6.== 和 === 有什么区别？"></a>6.== 和 === 有什么区别？</h3><ul>
<li>=== 不需要进行类型转换，只有类型相同并且值相等时，才返回 true.</li>
<li><p>== 如果两者类型不同，首先需要进行类型转换。具体流程如下:</p>
</li>
<li><ol>
<li>首先判断两者类型是否相同，如果相等，判断值是否相等.</li>
</ol>
</li>
<li><ol>
<li>如果类型不同，进行类型转换.</li>
</ol>
</li>
<li><ol>
<li>判断比较的是否是 null 或者是 undefined, 如果是, 返回 true .</li>
</ol>
</li>
<li><ol>
<li>判断其中一方是否为 boolean, 如果是, 将 boolean 转为 number 再进行判断</li>
</ol>
</li>
<li><ol>
<li>判断两者类型是否为 string 和 number, 如果是, 将字符串转换成 number</li>
</ol>
</li>
<li><ol>
<li>判断其中一方是否为 object 且另一方为 string、number 或者 symbol , 如果是, 将 object 转为原始类型再进行判断</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">    age: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person2 = person1;</span><br><span class="line">person2.gae = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2); <span class="comment">//true,注意复杂数据类型，比较的是引用</span></span><br></pre></td></tr></table></figure>
<p><strong>思考: [] == ![]</strong></p>
<ul>
<li>1.首先我们知道！的优先级高于 == 。</li>
<li>2.[] 引用类型转换成布尔值都是true,因此![]的是false。</li>
<li>3.根据上面的比较步骤中的第四条，其中一方是 boolean，将 boolean 转为 number 再进行判断，false转换成 number，对应的值是 0.</li>
<li>4.根据上面比较步骤中的第六条，有一方是 number，那么将object也转换成Number,空数组转换成数字，对应的值是0.(空数组转换成数字，对应的值是0，如果数组中只有一个数字，那么转成number就是这个数字，其它情况，均为NaN)</li>
<li>5.0 == 0; 为true</li>
</ul>
<h3 id="7-let、const-以及-var-的区别是什么？"><a href="#7-let、const-以及-var-的区别是什么？" class="headerlink" title="7 let、const 以及 var 的区别是什么？"></a>7 let、const 以及 var 的区别是什么？</h3><ul>
<li>let 和 const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</li>
<li>let 和 const 是JS中的块级作用域</li>
<li>let 和 const 不允许重复声明(会抛出错误)</li>
<li>let 和 const 定义的变量在定义语句之前，如果使用会抛出错误(形成了暂时性死区)，而 var 不会。</li>
<li>const 声明一个只读的常量。一旦声明，常量的值就不能改变(如果声明是一个对象，那么不能改变的是对象的引用地址)</li>
</ul>
<h3 id="8-在JS中什么是变量提升？什么是暂时性死区？"><a href="#8-在JS中什么是变量提升？什么是暂时性死区？" class="headerlink" title="8.在JS中什么是变量提升？什么是暂时性死区？"></a>8.在JS中什么是变量提升？什么是暂时性死区？</h3><p>变量提升就是变量在声明之前就可以使用，值为undefined。</p>
<p>在代码块内，使用 let/const 命令声明变量之前，该变量都是不可用的(会抛出错误)。这在语法上，称为“暂时性死区”。暂时性死区也意味着 typeof 不再是一个百分百安全的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError(暂时性死区，抛错)</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> y; <span class="comment">// 值是undefined,不会报错</span></span><br></pre></td></tr></table></figure>
<p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h3 id="9-如何正确的判断this-箭头函数的this是什么？"><a href="#9-如何正确的判断this-箭头函数的this是什么？" class="headerlink" title="9.如何正确的判断this? 箭头函数的this是什么？"></a>9.如何正确的判断this? 箭头函数的this是什么？</h3><p>this的绑定规则有四种：默认绑定，隐式绑定，显式绑定，new绑定。</p>
<ul>
<li>1.函数是否在 new 中调用(new绑定)，如果是，那么 this 绑定的是新创建的对象【前提是构造函数中没有返回对象或者是function，否则this指向返回的对象/function】</li>
<li>2.函数是否通过 call,apply 调用，或者使用了 bind (即硬绑定)，如果是，那么this绑定的就是指定的对象。</li>
<li>3.函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this 绑定的是那个上下文对象。一般是 obj.foo()</li>
<li>4.如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到 undefined，否则绑定到全局对象。</li>
<li>5.如果把null或者undefined作为 this 的绑定对象传入 call、apply 或者 bind,这些值在调用时会被忽略，实际应用的是默认绑定规则。</li>
<li>6.箭头函数没有自己的 this, 它的this继承于上一层代码块的this。</li>
</ul>
<h3 id="10-词法作用域和this的区别。"><a href="#10-词法作用域和this的区别。" class="headerlink" title="10.词法作用域和this的区别。"></a>10.词法作用域和this的区别。</h3><ul>
<li>词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。</li>
<li>this 是在调用时被绑定的，this 指向什么，完全取决于函数的调用位置(关于this的指向问题，本文已经有说明)。</li>
</ul>
<h3 id="11-词法作用域和this的区别。"><a href="#11-词法作用域和this的区别。" class="headerlink" title="11.词法作用域和this的区别。"></a>11.词法作用域和this的区别。</h3><ul>
<li>词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。</li>
<li>this 是在调用时被绑定的，this 指向什么，完全取决于函数的调用位置(关于this的指向问题，本文已经有说明)。</li>
</ul>
<h3 id="12-谈谈你对JS执行上下文栈和作用域链的理解。"><a href="#12-谈谈你对JS执行上下文栈和作用域链的理解。" class="headerlink" title="12.谈谈你对JS执行上下文栈和作用域链的理解。"></a>12.谈谈你对JS执行上下文栈和作用域链的理解。</h3><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境, JS执行上下文栈可以认为是一个存储函数调用的栈结构，遵循先进后出的原则。</p>
<ul>
<li>JavaScript执行在单线程上，所有的代码都是排队执行。</li>
<li>一开始浏览器执行全局的代码时，首先创建全局的执行上下文，压入执行栈的顶部。</li>
<li>每当进入一个函数的执行就会创建函数的执行上下文，并且把它压入执行栈的顶部。当前函数执行-完成后，当前函数的执行上下文出栈，并等待垃圾回收。</li>
<li>浏览器的JS执行引擎总是访问栈顶的执行上下文。</li>
<li>全局上下文只有唯一的一个，它在浏览器关闭时出栈。</li>
</ul>
<p>作用域链: 无论是 LHS 还是 RHS 查询，都会在当前的作用域开始查找，如果没有找到，就会向上级作用域继续查找目标标识符，每次上升一个作用域，一直到全局作用域为止。</p>
<h3 id="13-什么是闭包？闭包的作用是什么？闭包有哪些使用场景？"><a href="#13-什么是闭包？闭包的作用是什么？闭包有哪些使用场景？" class="headerlink" title="13.什么是闭包？闭包的作用是什么？闭包有哪些使用场景？"></a>13.什么是闭包？闭包的作用是什么？闭包有哪些使用场景？</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常用的方式就是在一个函数内部创建另一个函数。</p>
<ul>
<li><ol>
<li>封装私有变量。</li>
</ol>
</li>
<li><ol>
<li>模仿块级作用域(ES5中没有块级作用域)</li>
</ol>
</li>
<li><ol>
<li>实现JS的模块</li>
</ol>
</li>
</ul>
<h3 id="14-call、apply有什么区别？call-aplly和bind的内部是如何实现的？"><a href="#14-call、apply有什么区别？call-aplly和bind的内部是如何实现的？" class="headerlink" title="14. call、apply有什么区别？call,aplly和bind的内部是如何实现的？"></a>14. call、apply有什么区别？call,aplly和bind的内部是如何实现的？</h3><ul>
<li>fn.call(obj, arg1, arg2, …),调用一个函数, 具有一个指定的this值和分别地提供的参数(参数的列表)。</li>
<li>fn.apply(obj, [argsArray]),调用一个函数，具有一个指定的this值，以及作为一个数组（或类数组对象）提供的参数。</li>
</ul>
<blockquote>
<p>call核心:</p>
</blockquote>
<ul>
<li>1.将函数设为传入参数的属性。</li>
<li>2.指定this到函数并传入给定参数执行函数。</li>
<li>3.如果不传入参数或者参数为null，默认指向为 window / global。</li>
<li>4.删除参数上的函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/** 如果第一个参数传入的是 null 或者是 undefined, 那么指向this指向 window/global */</span></span><br><span class="line">    <span class="comment">/** 如果第一个参数传入的不是null或者是undefined, 那么必须是一个对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined</span></span><br><span class="line">        context = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ? global : <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">//this指向的是当前的函数(Function的实例)</span></span><br><span class="line">    <span class="keyword">let</span> rest = [...arguments].slice(<span class="number">1</span>);<span class="comment">//获取除了this指向对象以外的参数, 空数组slice后返回的仍然是空数组</span></span><br><span class="line">    <span class="keyword">let</span> result = context.fn(...rest); <span class="comment">//隐式绑定,当前函数的this指向了context.</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'Selina'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Chirs'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">job, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(job, age);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo, <span class="string">'programmer'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// Selina programmer 20</span></span><br><span class="line">bar.call(<span class="literal">null</span>, <span class="string">'teacher'</span>, <span class="number">25</span>);</span><br><span class="line"><span class="comment">// 浏览器环境: Chirs teacher 25; node 环境: undefined teacher 25</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>apply </p>
</blockquote>
<p>apply的实现和call很类似，但是需要注意他们的参数是不一样的，apply的第二个参数是数组或类数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined时,设置默认值</span></span><br><span class="line">        context = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ? global : <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(rest === <span class="literal">undefined</span> || rest === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//undefined 或者 是 null 不是 Iterator 对象，不能被 ...</span></span><br><span class="line">        result = context.fn(rest);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> rest === <span class="string">'object'</span>) &#123;</span><br><span class="line">        result = context.fn(...rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    name: <span class="string">'Selina'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Chirs'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">job, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    <span class="built_in">console</span>.log(job, age);</span><br><span class="line">&#125;</span><br><span class="line">bar.apply(foo, [<span class="string">'programmer'</span>, <span class="number">20</span>]);</span><br><span class="line"><span class="comment">// Selina programmer 20</span></span><br><span class="line">bar.apply(<span class="literal">null</span>, [<span class="string">'teacher'</span>, <span class="number">25</span>]);</span><br><span class="line"><span class="comment">// 浏览器环境: Chirs programmer 20; node 环境: undefined teacher 25</span></span><br></pre></td></tr></table></figure>
<p>bind 和 call/apply 有一个很重要的区别，一个函数被 call/apply 的时候，会直接调用，但是 bind 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>)&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"not a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    Fn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [...args, ...arguments]; <span class="comment">//bind传递的参数和函数调用时传递的参数拼接</span></span><br><span class="line">        context = <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context || <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原型链</span></span><br><span class="line">    bound.prototype = <span class="keyword">new</span> Fn();</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Jack'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">age, job, gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name , age, job, gender);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Yve = &#123;<span class="attr">name</span> : <span class="string">'Yvette'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> result = person.bind(Yve, <span class="number">22</span>, <span class="string">'enginner'</span>)(<span class="string">'female'</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="14-new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？"><a href="#14-new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？" class="headerlink" title="14.new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？"></a>14.new的原理是什么？通过new的方式创建对象和通过字面量创建有什么区别？</h3><p>new:</p>
<ul>
<li>1.创建一个新的对象</li>
<li>2.这个新对象会被执行[[原型]]连接。</li>
<li>3.属性和方法被加入到 this 引用的对象中。并执行了构造函数中的方法.</li>
<li>4.如果函数没有返回其他对象，那么this指向这个新对象，否则this指向构造函数中返回的对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">    target.__proto__ = func.prototype;</span><br><span class="line">    <span class="keyword">let</span> res = func.call(target);</span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; <span class="keyword">typeof</span>(res) == <span class="string">"object"</span> || <span class="keyword">typeof</span>(res) == <span class="string">"function"</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字面量创建对象，不会调用 Object构造函数, 简洁且性能更好;</p>
<p>new Object() 方式创建对象本质上是方法调用，涉及到在proto链中遍历该方法，当找到该方法后，又会生产方法调用必须的 堆栈信息，方法调用结束后，还要释放该堆栈，性能不如字面量的方式。</p>
<p>通过对象字面量定义对象时，不会调用Object构造函数。</p>
<h3 id="15-谈谈你对原型的理解？"><a href="#15-谈谈你对原型的理解？" class="headerlink" title="15.谈谈你对原型的理解？"></a>15.谈谈你对原型的理解？</h3><p>在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。使用原型对象的好处是所有对象实例共享它所包含的属性和方法。</p>
<h3 id="16-什么是原型链？【原型链解决的是什么问题？】"><a href="#16-什么是原型链？【原型链解决的是什么问题？】" class="headerlink" title="16.什么是原型链？【原型链解决的是什么问题？】"></a>16.什么是原型链？【原型链解决的是什么问题？】</h3><p>原型链解决的主要是继承问题。</p>
<p>每个对象拥有一个原型对象，通过 proto (读音: dunder proto) 指针指向其原型对象，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null(Object.proptotype.<strong>proto</strong> 指向的是null)。这种关系被称为原型链 (prototype chain)，通过原型链一个对象可以拥有定义在其他对象中的属性和方法。</p>
<p>构造函数 Parent、Parent.prototype 和 实例 p 的关系如下:(p.<strong>proto</strong> === Parent.prototype)</p>
<h3 id="16-prototype-和-proto-区别是什么？"><a href="#16-prototype-和-proto-区别是什么？" class="headerlink" title="16.prototype 和 proto 区别是什么？"></a>16.prototype 和 <strong>proto</strong> 区别是什么？</h3><p>prototype是构造函数的属性。<br><strong>proto</strong> 是每个实例都有的属性，可以访问 [[prototype]] 属性。<br>实例的<strong>proto</strong> 与其构造函数的prototype指向的是同一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.setAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Jack = <span class="keyword">new</span> Student(<span class="string">'jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Jack.__proto__);</span><br><span class="line"><span class="comment">//console.log(Object.getPrototypeOf(Jack));;</span></span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(Jack.__proto__ === Student.prototype);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="17-使用ES5实现一个继承？"><a href="#17-使用ES5实现一个继承？" class="headerlink" title="17.使用ES5实现一个继承？"></a>17.使用ES5实现一个继承？</h3><blockquote>
<p>组合继承(最常用的继承方式)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-什么是深拷贝？深拷贝和浅拷贝有什么区别？"><a href="#18-什么是深拷贝？深拷贝和浅拷贝有什么区别？" class="headerlink" title="18.什么是深拷贝？深拷贝和浅拷贝有什么区别？"></a>18.什么是深拷贝？深拷贝和浅拷贝有什么区别？</h3><p>浅拷贝是指只复制第一层对象，但是当对象的属性是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p>
<p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123; <span class="comment">//递归拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//null 的情况</span></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">//如果不是复杂数据类型，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span></span><br><span class="line"><span class="comment">     * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> t = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">//如果 obj[key] 是复杂数据类型，递归</span></span><br><span class="line">        t[key] = deepClone(obj[key]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-防抖和节流的区别是什么？防抖和节流的实现。"><a href="#19-防抖和节流的区别是什么？防抖和节流的实现。" class="headerlink" title="19.防抖和节流的区别是什么？防抖和节流的实现。"></a>19.防抖和节流的区别是什么？防抖和节流的实现。</h3><p>防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于设置的时间，防抖的情况下只会调用一次，而节流的情况会每隔一定时间调用一次函数。</p>
<blockquote>
<p>防抖(debounce): n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">func, wait, immediate = true</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">const</span> later = <span class="function">(<span class="params">context,args</span>) =&gt;</span>setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(!immediate)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            <span class="comment">// 执行回调</span></span><br><span class="line">            context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,wait)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> debounced = <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = params;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = later(context, args);</span><br><span class="line">            <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">                <span class="comment">//立即执行</span></span><br><span class="line">                func.apply(context, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            <span class="comment">//函数在每个等待时延的结束被调用</span></span><br><span class="line">            timer = later(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        debounced.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> debounced;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>防抖应用场景：</p>
<ul>
<li>每次 resize/scroll 触发统计事件</li>
<li>文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）</li>
</ul>
<blockquote>
<p>节流(throttle): 高频事件在规定时间内只会执行一次，执行一次后，只有大于设定的执行周期后才会执行第二次。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout, context, args, result;</span><br><span class="line">    <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : <span class="built_in">Date</span>.now() || <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> throttled = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now() || <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">            <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否设置了定时器和 trailing</span></span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        throttled.cancel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        previous = <span class="number">0</span>;</span><br><span class="line">        timeout = context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数节流的应用场景有:</p>
<ul>
<li>DOM 元素的拖拽功能实现（mousemove）</li>
<li>射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）</li>
<li>计算鼠标移动的距离（mousemove）</li>
<li>Canvas 模拟画板功能（mousemove）</li>
<li>搜索联想（keyup）</li>
<li>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次</li>
</ul>
<h3 id="20-取数组的最大值（ES5、ES6）"><a href="#20-取数组的最大值（ES5、ES6）" class="headerlink" title="20.取数组的最大值（ES5、ES6）"></a>20.取数组的最大值（ES5、ES6）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>, <span class="number">30</span>]);</span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>, <span class="number">30</span>]);</span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line">[<span class="number">14</span>,<span class="number">3</span>,<span class="number">77</span>,<span class="number">30</span>].reduce(<span class="function">(<span class="params">accumulator, currentValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accumulator = accumulator &gt; currentValue ? accumulator : currentValue</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="21-ES6新的特性有哪些？"><a href="#21-ES6新的特性有哪些？" class="headerlink" title="21.ES6新的特性有哪些？"></a>21.ES6新的特性有哪些？</h3><ul>
<li>1.新增了块级作用域(let,const)</li>
<li>2.提供了定义类的语法糖(class)</li>
<li>3.新增了一种基本数据类型(Symbol)</li>
<li>4.新增了变量的解构赋值</li>
<li>5.函数参数允许设置默认值，引入了rest参数，新增了箭头函数</li>
<li>6.数组新增了一些API，如 isArray / from / of 方法;数组实例新增了 entries()，keys() 和 values() 等方法</li>
<li>7.对象和数组新增了扩展运算符</li>
<li>8.ES6 新增了模块化(import/export)</li>
<li>9.ES6 新增了 Set 和 Map 数据结构</li>
<li>10.ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例</li>
<li>11.ES6 新增了生成器(Generator)和遍历器(Iterator)</li>
</ul>
<h3 id="22-setTimeout倒计时为什么会出现误差？"><a href="#22-setTimeout倒计时为什么会出现误差？" class="headerlink" title="22.setTimeout倒计时为什么会出现误差？"></a>22.setTimeout倒计时为什么会出现误差？</h3><p>setTimeout() 只是将事件插入了“任务队列”，必须等当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并没办法保证回调函数一定会在 setTimeout() 指定的时间执行。所以， setTimeout() 的第二个参数表示的是最少时间，并非是确切时间。</p>
<p>HTML5标准规定了 setTimeout() 的第二个参数的最小值不得小于4毫秒，如果低于这个值，则默认是4毫秒。在此之前。老版本的浏览器都将最短时间设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常是间隔16毫秒执行。这时使用 requestAnimationFrame() 的效果要好于 setTimeout();</p>
<h3 id="23-为什么-0-1-0-2-0-3"><a href="#23-为什么-0-1-0-2-0-3" class="headerlink" title="23.为什么 0.1 + 0.2 != 0.3 ?"></a>23.为什么 0.1 + 0.2 != 0.3 ?</h3><p>0.1 + 0.2 != 0.3 是因为在进制转换和进阶运算的过程中出现精度损失。<br>计算机无法直接对十进制的数字直接进行运算，首先要转换喂二进制然后进行对阶运算。</p>
<blockquote>
<p>1.进制转换</p>
</blockquote>
<p>0.1和0.2转换成二进制后会无限循环</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> -&gt; <span class="number">0.0001100110011001</span>...(无限循环)</span><br><span class="line"><span class="number">0.2</span> -&gt; <span class="number">0.0011001100110011</span>...(无限循环)</span><br></pre></td></tr></table></figure>
<p>但是由于IEEE 754尾数位数限制，需要将后面多余的位截掉，这样在进制之间的转换中精度已经损失。</p>
<blockquote>
<p>2.对阶运算</p>
</blockquote>
<p>由于指数位数不相同，运算时需要对阶运算 这部分也可能产生精度损失。<br>按照上面两步运算（包括两步的精度损失），最后的结果是<br>0.0100110011001100110011001100110011001100110011001100<br>结果转换成十进制之后就是 0.30000000000000004。</p>
<h3 id="24-promise-有几种状态-Promise-有什么优缺点"><a href="#24-promise-有几种状态-Promise-有什么优缺点" class="headerlink" title="24.promise 有几种状态, Promise 有什么优缺点 ?"></a>24.promise 有几种状态, Promise 有什么优缺点 ?</h3><p>promise有三种状态: fulfilled, rejected, pending.</p>
<blockquote>
<p>Promise的优点</p>
</blockquote>
<p>1.一旦状态改变，就不会再变，任何时候都可以得到这个结果。<br>2.可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p>
<blockquote>
<p>promise的缺点<br>1.无法取消 Promise。<br>2.当处于pending状态时，无法得知目前进展到哪一个阶段。</p>
</blockquote>
<h3 id="25-Promise构造函数是同步还是异步执行，then中的方法呢-promise如何实现then处理"><a href="#25-Promise构造函数是同步还是异步执行，then中的方法呢-promise如何实现then处理" class="headerlink" title="25.Promise构造函数是同步还是异步执行，then中的方法呢 ?promise如何实现then处理 ?"></a>25.Promise构造函数是同步还是异步执行，then中的方法呢 ?promise如何实现then处理 ?</h3><p>Promise的构造函数是同步执行的。then 中的方法是异步执行的。</p>
<h3 id="26-Promise和setTimeout的区别"><a href="#26-Promise和setTimeout的区别" class="headerlink" title="26.Promise和setTimeout的区别 ?"></a>26.Promise和setTimeout的区别 ?</h3><p>Promise 是微任务，setTimeout 是宏任务，同一个事件循环中，promise.then总是先于 setTimeout 执行。</p>
<h3 id="27-promise-all"><a href="#27-promise-all" class="headerlink" title="27.promise.all"></a>27.promise.all</h3><p>要实现 Promise.all,首先我们需要知道 Promise.all 的功能：</p>
<ul>
<li><ol>
<li>如果传入的参数是一个空的可迭代对象，那么此promise对象回调完成(resolve),只有此情况，是同步执行的，其它都是异步返回的。</li>
</ol>
</li>
<li><ol>
<li>如果传入的参数不包含任何 promise，则返回一个异步完成. promises 中所有的promise都“完成”时或参数中不包含 promise 时回调完成。</li>
</ol>
</li>
<li><ol>
<li>如果参数中有一个promise失败，那么Promise.all返回的promise对象失败</li>
</ol>
</li>
<li><ol>
<li>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组</li>
</ol>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">            resolve(result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">processValue</span>(<span class="params">i, data</span>) </span>&#123;</span><br><span class="line">                result[i] = data;</span><br><span class="line">                <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">                    resolve(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">                <span class="comment">//promises[i] 可能是普通值</span></span><br><span class="line">                <span class="built_in">Promise</span>.resolve(promises[i]).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">                    processValue(i, data);</span><br><span class="line">                &#125;, (err) =&gt; &#123;</span><br><span class="line">                    reject(err);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="28-如何实现-Promise-finally"><a href="#28-如何实现-Promise-finally" class="headerlink" title="28.如何实现 Promise.finally?"></a>28.如何实现 Promise.finally?</h3><p>不管成功还是失败，都会走到finally中,并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, (err) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="29-什么是函数柯里化？实现-sum-1-2-3-返回结果是1-2-3之和"><a href="#29-什么是函数柯里化？实现-sum-1-2-3-返回结果是1-2-3之和" class="headerlink" title="29. 什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是1,2,3之和"></a>29. 什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是1,2,3之和</h3><p>函数柯里话是把接收多个参数的函数变成接收一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a+b+c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>引申：实现一个curry函数，将普通函数进行柯里化:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> rest = [...args, ...arguments];</span><br><span class="line">        <span class="keyword">if</span> (rest.length &lt; fn.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> curry.call(<span class="keyword">this</span>,fn,rest);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>,rest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b,c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sumFn = curry(sum);</span><br><span class="line"><span class="built_in">console</span>.log(sumFn(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(sumFn(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//6</span></span><br></pre></td></tr></table></figure></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/面试基础/">面试基础</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/web安全/" title="web安全" itemprop="url">web安全</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T02:35:23.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h3><p>XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<p>XSS的本质是:恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。</p>
<blockquote>
<p>XSS分类</p>
</blockquote>
<p>根据攻击的来源，XSS攻击可以分为存储型(持久性)、反射型(非持久型)和DOM型三种。下面我们来详细了解一下这三种XSS攻击：</p>
<blockquote>
<p><code>1.1反射型XSS</code><br>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入脚本，比如一个错误信息，搜索结果等，未进行过滤直接返回到用户的浏览器上。</p>
</blockquote>
<blockquote>
<p>反射型 XSS 的攻击步骤：</p>
</blockquote>
<ul>
<li>1.攻击者构造出特殊的<code>URL</code>，其中包含恶意代码</li>
<li>2.用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 <code>HTML</code> 中返回给浏览器。</li>
<li>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<p>反射型 XSS 漏洞常见于通过 <code>URL</code>传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 <code>URL</code> 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<h4 id="如何防范反射型XSS攻击"><a href="#如何防范反射型XSS攻击" class="headerlink" title="如何防范反射型XSS攻击"></a>如何防范反射型XSS攻击</h4><p>对url的查询参数进行转义后再输出到页面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/welcome'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//对查询参数进行编码，避免反射型 XSS攻击</span></span><br><span class="line">    res.send(<span class="string">`<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(req.query.type)&#125;</span>`</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.2DOM的XSS攻击<br>DOM 型 XSS 攻击，实际上就是前端 <code>JavaScript</code> 代码不够严谨，把不可信的内容插入到了页面。在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>.appendChild</code>、<code>document.write()</code>等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 <code>.innerText、`</code>.textContent、<code></code>.setAttribute()` 等。</p>
</blockquote>
<ul>
<li>1.攻击者构造出特殊数据，其中包含恶意代码。</li>
<li>2.用户浏览器执行了恶意代码。</li>
<li>3.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
<blockquote>
<p>如何防范 DOM 型 XSS 攻击</p>
</blockquote>
<p>防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)</p>
<ul>
<li>1.对于<code>url</code>链接(例如图片的src属性)，那么直接使用<code>encodeURIComponent</code>来转义。</li>
<li>2.非<code>url</code>，我们可以这样进行编码：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeHtml</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;apos;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.3 存储型XSS<br>恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。</p>
</blockquote>
<blockquote>
<p>存储型 XSS 的攻击步骤：</p>
<ul>
<li>1.攻击者将恶意代码提交到目标网站的数据库中。</li>
<li>2.用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li>
<li>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li>
</ul>
</blockquote>
<p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<blockquote>
<p>如何防范存储型XSS攻击：</p>
<ul>
<li>1.前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)</li>
<li>2.服务器接收到数据，在存储到数据库之前，进行转义/过滤</li>
<li>3.前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤</li>
</ul>
</blockquote>
<p><code>除了谨慎的转义，我们还需要其他一些手段来防范XSS攻击:</code><br>在服务端使用 HTTP的 <code>Content-Security-Policy</code> 头部来指定策略，或者在前端设置 <code>meta</code>标签。</p>
<p>例如下面的配置只允许加载同域下的资源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">'self'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Content-Security-Policy"</span> content=<span class="string">"form-action 'self';"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>前端和服务端设置 <code>CSP</code>的效果相同，但是<code>meta</code>无法使用report</p>
<p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p>
<ul>
<li><ol>
<li>禁止加载外域代码，防止复杂的攻击逻辑。</li>
</ol>
</li>
<li><ol>
<li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li>
</ol>
</li>
<li><ol>
<li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li>
</ol>
</li>
<li><ol>
<li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li>
</ol>
</li>
<li><ol>
<li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li>
</ol>
</li>
</ul>
<h4 id="2-输入内容长度控制"><a href="#2-输入内容长度控制" class="headerlink" title="2.输入内容长度控制"></a>2.输入内容长度控制</h4><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p>
<h4 id="3-输入内容限制"><a href="#3-输入内容限制" class="headerlink" title="3.输入内容限制"></a>3.输入内容限制</h4><p>对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等。</p>
<h4 id="4-其他安全措施"><a href="#4-其他安全措施" class="headerlink" title="4.其他安全措施"></a>4.其他安全措施</h4><ul>
<li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li>
<li>验证码：防止脚本冒充用户提交危险操作。</li>
</ul>
<blockquote>
<p>1.4XSS检测<br>读到这儿，相信大家已经知道了什么是XSS攻击，XSS攻击的类型，以及如何去防范XSS攻击。但是有一个非常重要的问题是：我们如何去检测XSS攻击，怎么知道自己的页面是否存在XSS漏洞？</p>
</blockquote>
<p>很多大公司，都有专门的安全部门负责这个工作，但是如果没有安全部门，作为开发者本身，该如何去检测呢？</p>
<blockquote>
<p>1.使用通用 XSS 攻击字串手动检测 XSS 漏洞<br>如<code>jaVasCript:/*-/*/*\</code>/<em>‘/</em>“/*<em>/(/</em> */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/–!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e`能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞，也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞，并且能绕过一些 XSS 过滤器。</p>
</blockquote>
<blockquote>
<p>CSRF</p>
</blockquote>
<p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p>典型的CSRF攻击流程：</p>
<ul>
<li>1.受害者登录A站点，并保留了登录凭证（Cookie）。</li>
<li>2.攻击者诱导受害者访问了站点B。</li>
<li>3.站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。</li>
<li>4.站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。</li>
<li>5.站点A以受害者的名义执行了站点B的请求。</li>
<li>6.攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。</li>
</ul>
<blockquote>
<p>CSRF的特点</p>
<ul>
<li>1.攻击通常在第三方网站发起，如图上的站点B，站点A无法防止攻击发生。</li>
<li>2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；并不会去获取cookie信息(cookie有同源策略)</li>
<li>3.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等(来源不明的链接，不要点击)</li>
</ul>
</blockquote>
<h4 id="CSRF攻击防御"><a href="#CSRF攻击防御" class="headerlink" title="CSRF攻击防御"></a>CSRF攻击防御</h4><ul>
<li>1.添加验证码<br>验证码能够防御CSRF攻击，但是我们不可能每一次交互都需要验证码，否则用户的体验会非常差，但是我们可以在转账，交易等操作时，增加验证码，确保我们的账户安全。</li>
<li><p>2.判断请求的来源：检测Referer(并不安全，Referer可以被更改)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`Referer`</span> 可以作为一种辅助手段，来判断请求的来源是否是安全的，但是鉴于 <span class="string">`Referer`</span> 本身是可以被修改的，因为不能仅依赖于  <span class="string">`Referer`</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3.使用Token(主流)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。</span><br><span class="line"></span><br><span class="line">- 服务端给用户生成一个token，加密后传递给用户</span><br><span class="line">- 用户在提交请求时，需要携带这个token</span><br><span class="line">- 服务端验证token是否正确</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>点击劫持是指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。</p>
<h4 id="点击劫持的流程"><a href="#点击劫持的流程" class="headerlink" title="点击劫持的流程"></a>点击劫持的流程</h4><ul>
<li>1.攻击者构建了一个非常有吸引力的网页【不知道哪些内容对你们来说有吸引力，我就不写页面了，偷个懒】</li>
<li>2.将被攻击的页面放置在当前页面的<code>iframe</code> 中</li>
<li>3.使用样式将 iframe 叠加到非常有吸引力内容的上方</li>
<li>4.将iframe设置为100%透明</li>
<li>5.你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。</li>
</ul>
<p>点击劫持防御</p>
<ol>
<li>frame busting<br>frame busting<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( top.location != <span class="built_in">window</span>.location )&#123;</span><br><span class="line">    top.location = <span class="built_in">window</span>.location</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>需要注意的是: HTML5中iframe的 sandbox 属性、IE中iframe的security 属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得 frame busting 失效。</p>
<ol>
<li>X-Frame-Options<br>X-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。</li>
</ol>
<p>可以设置为以下值:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DENY: 拒绝任何域加载</span><br><span class="line">SAMEORIGIN: 允许同源域下加载</span><br><span class="line">ALLOW-FROM: 可以定义允许frame加载的页面地址</span><br></pre></td></tr></table></figure></p>
<h4 id="安全扫描工具"><a href="#安全扫描工具" class="headerlink" title="安全扫描工具"></a>安全扫描工具</h4><p>上面我们介绍了几种常见的前端安全漏洞，也了解一些防范措施，那么我们如何发现自己网站的安全问题呢？没有安全部门的公司可以考虑下面几款开源扫码工具：</p>
<p>1.Arachni<br>Arachni是基于Ruby的开源，功能全面，高性能的漏洞扫描框架，Arachni提供简单快捷的扫描方式，只需要输入目标网站的网址即可开始扫描。它可以通过分析在扫描过程中获得的信息，来评估漏洞识别的准确性和避免误判。<br>Arachni默认集成大量的检测工具，可以实施 代码注入、CSRF、文件包含检测、SQL注入、命令行注入、路径遍历等各种攻击。<br>同时，它还提供了各种插件，可以实现表单爆破、HTTP爆破、防火墙探测等功能。<br>针对大型网站，该工具支持会话保持、浏览器集群、快照等功能，帮助用户更好实施渗透测试。</p>
<p>2.Mozilla HTTP Observatory<br>Mozilla HTTP Observatory，是Mozilla最近发布的一款名为Observatory的网站安全分析工具，意在鼓励开发者和系统管理员增强自己网站的安全配置。用法非常简单：输入网站URL，即可访问并分析网站HTTP标头，随后可针对网站安全性提供数字形式的分数和字母代表的安全级别。</p>
<blockquote>
<p>检查范围包括</p>
<ul>
<li>cookie</li>
<li>跨源资源共享</li>
<li>内容安全策略</li>
<li>HTTP公钥固定（Public Key Pinning）</li>
<li>HTTP严格安全传输（HSTS）状态</li>
<li>是否存在HTTP到HTTPs的自动重定向</li>
<li>子资源完整性（Subresource Integrity</li>
<li>X-Frame-Options</li>
<li>X-XSS-Protection</li>
</ul>
</blockquote>
<p>3.w3af<br>W3af是一个基于Python的Web应用安全扫描器。可帮助开发人员，有助于开发人员和测试人员识别Web应用程序中的漏洞。</p>
<p>扫描器能够识别200多个漏洞，包括跨站点脚本、SQL注入和操作系统命令。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/web安全/">web安全</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/EventLoop/" title="EventLoop" itemprop="url">EventLoop</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T02:35:23.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>我们都知道 JavaScript 是一门<code>单线程</code>语言，也就是说同一时间只能做一件事。这是因为 JavaScript 生来作为浏览器脚本语言，主要用来处理与用户的交互、网络以及操作 DOM。这就决定了它只能是单线程的，否则会带来很复杂的同步问题。</p>
<p>假设 JavaScript 有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>既然 Javascript 是单线程的，它就像是只有一个窗口的银行，客户不得不排队一个一个的等待办理。同理 JavaScript 的任务也要一个接一个的执行，如果某个任务（比如加载高清图片）是个耗时任务，那浏览器岂不得一直卡着？为了防止主线程的阻塞，JavaScript 有了<code>同步</code>和<code>异步</code>的概念。</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>如果在一个函数返回的时候，调用者就能够得到预期结果，那么这个函数就是同步的。也就是说同步方法调用一旦开始，调用者必须等到该函数调用返回后，才能继续后续的行为。下面这段段代码首先会弹出 alert 框，如果你不点击 确定 按钮，所有的页面交互都被锁死，并且后续的 console 语句不会被打印出来。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">'Yancey'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'is'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'the'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'best'</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。比如说发一个网络请求，我们告诉主程序等到接收到数据后再通知我，然后我们就可以去做其他的事情了。当异步完成后，会通知到我们，但是此时可能程序正在做其他的事情，所以即使异步完成了也需要在一旁等待，等到程序空闲下来才有时间去看哪些异步已经完成了，再去执行。</p>
<p>这也就是定时器并不能精确在指定时间后输出回调函数结果的原因。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'yancey'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="执行栈和任务队列"><a href="#执行栈和任务队列" class="headerlink" title="执行栈和任务队列"></a>执行栈和任务队列</h2><h3 id="复习一下数据结构吧"><a href="#复习一下数据结构吧" class="headerlink" title="复习一下数据结构吧"></a>复习一下数据结构吧</h3><ul>
<li><p>栈 (stack): 栈是遵循后进先出 (LIFO) 原则的有序集合，新添加或待删除的元素都保存在同一端，称为栈顶，另一端叫做栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。栈在编程语言的编译器和内存中存储基本数据类型和对象的指针、方法调用等.</p>
</li>
<li><p>队列 (queue): 队列是遵循先进先出 (FIFO) 原则的有序集合，队列在尾部添加新元素，并在顶部移除元素，最新添加的元素必须排在队列的末尾。在计算机科学中，最常见的例子就是打印队列。</p>
</li>
<li><p>堆 (heap): 堆是基于树抽象数据类型的一种特殊的数据结构。</p>
</li>
</ul>
<p>JavaScript 中的内存分为<code>堆内存</code>和<code>栈内存</code></p>
<p>avaScript 中引用类型值的大小是不固定的，因此它们会被存储到<code>堆内存</code>中，由系统自动分配存储空间。JavaScript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间，而是操作<code>对象的引用</code></p>
<p>而 <code>JavaScript</code> 中的基础数据类型都有固定的大小，因此它们被存储到 <code>栈内存</code> 中。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是 <code>按值访问</code>。此外，栈内存还会存储 <code>对象的引用 (指针)</code> 以及 <code>函数执行时的运行空间</code>。</p>
<p>下面比较一下两种存储方式的不同。</p>
<p>栈内存|堆内存<br>存储基础数据类型|存储引用数据类型<br>按值访问|按引用访问<br>存储的值大小固定|存储的值大小不定，可动态调整<br>由系统自动分配内存空间|由程序员通过代码进行分配<br>主要用来执行程序|主要用来存放对象<br>空间小，运行效率高|空间大，但是运行效率相对较低<br>先进后出，后进先出|无序存储，可根据引用直接获取</p>
<h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>当我们调用一个方法的时候，JavaScript 会生成一个与这个方法对应的执行环境，又叫执行上下文(context)。这个执行环境中保存着该方法的私有作用域、上层作用域(作用域链)、方法的参数，以及这个作用域中定义的变量和 this 的指向，而当一系列方法被依次调用的时候。由于 JavaScript 是单线程的，这些方法就会按顺序被排列在一个单独的地方，这个地方就是所谓执行栈。</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>事件队列是一个存储着<code>异步任务</code>的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果事件队列不为空的话，事件队列便将第一个任务压入执行栈中运行。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>我们注意到，在异步代码完成后仍有可能要在一旁等待，因为此时程序可能在做其他的事情，等到程序空闲下来才有时间去看哪些异步已经完成了。所以 JavaScript 有一套机制去处理同步和异步操作，那就是事件循环 (Event Loop)。</p>
<ul>
<li>所有同步任务都在主线程上执行，形成一个执行栈。</li>
<li>而异步任务会被放置到 Task Table，当异步任务有了运行结果，就将该函数移入任务队列。</li>
<li>一旦执行栈中的所有同步任务执行完毕，引擎就会读取任务队列，然后将任务队列中的第一个任务压入执行栈中运行。</li>
</ul>
<p>主线程不断重复第三步，也就是 <code>只要主线程空了，就会去读取任务队列</code>，该过程不断重复，这就是所谓的 <code>事件循环</code>。</p>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>一个很形象的例子来描述宏任务和微任务<br>因为柜员同时职能处理一个来办理业务的客户，这时每一个来办理业务的人就可以认为是银行柜员的一个宏任务来存在的，当柜员处理完当前客户的问题以后，选择接待下一位，广播报号，也就是下一个宏任务的开始。<br>所以多个宏任务合在一起就可以认为说有一个任务队列在这，里边是当前银行中所有排号的客户。<br>任务队列中的都是已经完成的异步操作，而不是说注册一个异步任务就会被放在这个任务队列中，就像在银行中排号，如果叫到你的时候你不在，那么你当前的号牌就作废了，柜员会选择直接跳过进行下一个客户的业务处理，等你回来以后还需要重新取号<br>而且一个宏任务在执行的过程中，是可以添加一些微任务的，就像在柜台办理业务，你前边的一位老大爷可能在存款，在存款这个业务办理完以后，柜员会问老大爷还有没有其他需要办理的业务，这时老大爷想了一下：“最近P2P爆雷有点儿多，是不是要选择稳一些的理财呢”，然后告诉柜员说，要办一些理财的业务，这时候柜员肯定不能告诉老大爷说：“您再上后边取个号去，重新排队”。<br>所以本来快轮到你来办理业务，会因为老大爷临时添加的“理财业务”而往后推。<br>也许老大爷在办完理财以后还想 再办一个信用卡？或者 再买点儿纪念币？<br>无论是什么需求，只要是柜员能够帮她办理的，都会在处理你的业务之前来做这些事情，这些都可以认为是微任务。<br>在当前的微任务没有执行完成时，是不会执行下一个宏任务的。<br>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><code>setTimeout</code>就是作为宏任务来存在的，而<code>Promise.then</code>则是具有代表性的微任务，上述代码的执行顺序就是按照序号来输出的。</p>
<p>所有会进入的异步都是指的事件回调中的那部分代码</p>
<p>所有会进入的异步都是指的事件回调中的那部分代码<br>也就是说<code>new Promise</code>在实例化的过程中所执行的代码都是同步进行的，而then中注册的回调才是异步执行的。<br>在同步代码执行完成后才回去检查是否有异步任务完成，并执行对应的回调，而微任务又会在宏任务之前执行。<br>所以就得到了上述的输出结论<code>1、2、3、4</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">-  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">+&#125;)</span><br><span class="line"></span><br><span class="line">+<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">+  resolve()</span><br><span class="line">+  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">+&#125;).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">-  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">+&#125;)</span><br><span class="line"></span><br><span class="line">+<span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>总结一下，异步任务分为 <code>宏任务(macrotask)</code> 与 <code>微任务 (microtask)</code>。宏任务会进入一个队列，而微任务会进入到另一个不同的队列，且微任务要优于宏任务执行。</p>
<h3 id="常见的宏任务和微任务"><a href="#常见的宏任务和微任务" class="headerlink" title="常见的宏任务和微任务"></a>常见的宏任务和微任务</h3><ul>
<li>宏任务：script(整体代码)、setTimeout、setInterval、I/O、事件、postMessage、 MessageChannel、setImmediate (Node.js)</li>
<li>微任务：Promise.then、 MutaionObserver、process.nextTick (Node.js)</li>
</ul>
<h2 id="Event-Loop-遇到-async-await"><a href="#Event-Loop-遇到-async-await" class="headerlink" title="Event Loop 遇到 async/await"></a>Event Loop 遇到 async/await</h2><p>我们知道，async/await 仅仅是生成器的语法糖，所以不要怕，只要把它转换成 Promise 的形式即可。下面这段代码是 async/await 函数的经典形式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await 前面的代码</span></span><br><span class="line">  <span class="keyword">await</span> bar();</span><br><span class="line">  <span class="comment">// await 后面的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>复制代码其中 <code>await 前面的代码</code> 是同步的，调用此函数时会直接执行；而 <code>await bar()</code>; 这句可以被转换成 <code>Promise.resolve(bar())</code>；<code>await 后面的代码</code> 则会被放到 Promise 的 then() 方法里。因此上面的代码可以被转换成如下形式，这样是不是就很清晰了？</p>
<h2 id="Node-js-与-浏览器环境下事件循环的区别"><a href="#Node-js-与-浏览器环境下事件循环的区别" class="headerlink" title="Node.js 与 浏览器环境下事件循环的区别"></a>Node.js 与 浏览器环境下事件循环的区别</h2><p>Node.js 在升级到 11.x 后，Event Loop 运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval 和 setImmediate) 就立刻执行微任务队列，这点就跟浏览器端一致。</p>
<p><code>两道练习</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then11'</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then21'</span>);</span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then23'</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then12'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'then31'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>); <span class="comment">// 1</span></span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then11'</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'promise2'</span>); <span class="comment">// 3</span></span><br><span class="line">      resolve();</span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then21'</span>); <span class="comment">// 4</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'then23'</span>); <span class="comment">// 5</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then12'</span>); <span class="comment">//6</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/EventLoop/">EventLoop</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/面试基础三/" title="面试基础三" itemprop="url">面试基础三</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T02:35:23.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="1-如何正确的判断this的指向"><a href="#1-如何正确的判断this的指向" class="headerlink" title="1.如何正确的判断this的指向"></a>1.如何正确的判断this的指向</h3><p>如果用一句话说明 this 的指向，那么即是: 谁调用它，this 就指向谁。<br>this 的指向可以按照以下顺序判断:</p>
<h4 id="全局环境的this"><a href="#全局环境的this" class="headerlink" title="全局环境的this"></a>全局环境的this</h4><ul>
<li>浏览器环境：无论在严格模式下，还是在全局环境中（在任何函数体外部）this 都指向全局对象 window;</li>
<li>node环境: 无论是否在严格模式下，在全局执行环境中（在任何函数体外部），this 都是空对象 {};</li>
</ul>
<h4 id="是否是-new-绑定"><a href="#是否是-new-绑定" class="headerlink" title="是否是 new 绑定"></a>是否是 <code>new</code> 绑定</h4><p>我们来看一下<code>new</code>实现的原理</p>
<ul>
<li>1.创建一个新的对象</li>
<li>2.这个新对象会被执行 <code>[[原型]]</code> 连接。</li>
<li>3.属性和方法被加入到 this 引用的对象中。并执行了构造函数中的方法.</li>
<li>4.如果函数没有返回其他对象，那么 this 指向这个新对象，否则 this 指向构造函数中返回的对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">    target.__proto__ = func.prototype;</span><br><span class="line">    <span class="keyword">let</span> res = func.call(target);</span><br><span class="line">    <span class="comment">//排除 null 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (res &amp;&amp; <span class="keyword">typeof</span>(res) == <span class="string">"object"</span> || <span class="keyword">typeof</span>(res) == <span class="string">"function"</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"><a href="#函数是否通过-call-apply-调用，或者使用了-bind-绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。" class="headerlink" title="函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。"></a>函数是否通过 call,apply 调用，或者使用了 bind 绑定，如果是，那么this绑定的就是指定的对象【归结为显式绑定】。</h4><p>这里同样需要注意一种特殊情况，如果 call,apply 或者 bind 传入的第一个参数值是 <code>undefined</code> 或者 <code>null</code>，严格模式下 this 的值为传入的值 null /undefined。非严格模式下，实际应用的默认绑定规则，this 指向全局对象(node环境为global，浏览器环境为window)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//node环境中:非严格模式 global，严格模式为null</span></span><br><span class="line">    <span class="comment">//浏览器环境中:非严格模式 window，严格模式为null</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    info</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">var</span> info = person.info;</span><br><span class="line"><span class="comment">//严格模式抛出错误；</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age会挂在 window 上）</span></span><br><span class="line">info.call(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>隐式绑定，函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的隐式调用为: <code>xxx.fn()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    info</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line">person.info(); <span class="comment">//20;执行的是隐式绑定</span></span><br></pre></td></tr></table></figure>
<p>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。<br>非严格模式： node环境，执行全局对象 global，浏览器环境，执行全局对象 window。<br>严格模式：执行 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">28</span>;</span><br><span class="line"><span class="comment">//严格模式；抛错</span></span><br><span class="line"><span class="comment">//非严格模式，node下输出 undefined（因为全局的age不会挂在 global 上）</span></span><br><span class="line"><span class="comment">//非严格模式。浏览器环境下输出 28（因为全局的age不会挂在 window 上）</span></span><br><span class="line"><span class="comment">//严格模式抛出，因为 this 此时是 undefined</span></span><br><span class="line">info();</span><br></pre></td></tr></table></figure>
<h4 id="箭头函数的情况"><a href="#箭头函数的情况" class="headerlink" title="箭头函数的情况"></a>箭头函数的情况</h4><p>箭头函数没有自己的this，继承外层上下文绑定的this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    info: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.age); <span class="comment">//this继承的是外层上下文绑定的this</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">age</span>: <span class="number">28</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> info = obj.info();</span><br><span class="line">info(); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info2 = obj.info.call(person);</span><br><span class="line">info2(); <span class="comment">//28</span></span><br></pre></td></tr></table></figure>
<h4 id="原始数据类型和复杂数据类型有什么区别"><a href="#原始数据类型和复杂数据类型有什么区别" class="headerlink" title="原始数据类型和复杂数据类型有什么区别"></a>原始数据类型和复杂数据类型有什么区别</h4><p>基本数据类型和复杂数据类型的区别为:</p>
<ul>
<li>1.内存的分配不同</li>
<li>基本数据类型存储在栈中。</li>
<li><p>复杂数据类型存储在堆中，栈中存储的变量，是指向堆中的引用地址。</p>
</li>
<li><p>2.访问机制不同</p>
</li>
<li>基本数据类型是按值访问</li>
<li><p>复杂数据类型按引用访问，JS不允许直接访问保存在堆内存中的对象，在访问一个对象时，首先得到的是这个对象在栈内存中的地址，然后再按照这个地址去获得这个对象中的值。</p>
</li>
<li><p>3.复制变量时不同(a=b)</p>
</li>
<li>基本数据类型：a=b;是将b中保存的原始值的副本赋值给新变量a，a和b完全独立，互不影响</li>
<li><p>复杂数据类型：a=b;将b保存的对象内存的引用地址赋值给了新变量a;a和b指向了同一个堆内存地址，其中一个值发生了改变，另一个也会改变。</p>
</li>
<li><p>4.参数传递的不同(实参/形参)<br>函数传参都是按值传递(栈中的存储的内容)：基本数据类型，拷贝的是值；复杂数据类型，拷贝的是引用地址</p>
</li>
</ul>
<h3 id="对于语意化的理解"><a href="#对于语意化的理解" class="headerlink" title="对于语意化的理解"></a>对于语意化的理解</h3><p>语义化意味着顾名思义，HTML5的语义化指的是合理正确的使用语义化的标签来创建页面结构，如 header,footer,nav，从标签上即可以直观的知道这个标签的作用，而不是滥用div。</p>
<h4 id="语义化的有点有哪些"><a href="#语义化的有点有哪些" class="headerlink" title="语义化的有点有哪些"></a>语义化的有点有哪些</h4><ul>
<li>代码结构清晰，易于阅读，利于开发和维护。</li>
<li>方便其他设备解析（如屏幕阅读器）根据语义渲染网页。</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重。<br>语义化标签主要有：</li>
<li>title：主要用于页面的头部的信息介绍</li>
<li>header：定义文档的页眉</li>
<li>nav：主要用于页面导航</li>
<li>main：规定文档的主要内容。对于文档来说应当是唯一的。它不应包含在文档中重复出现的内容，比如侧栏、导航栏、版权信息、站点标志或搜索表单。</li>
<li>article：独立的自包含内容</li>
<li>h1~h6：定义标题</li>
<li>ul: 用来定义无序列表</li>
<li>ol: 用来定义有序列表</li>
<li>address：定义文档或文章的作者/拥有者的联系信息。</li>
<li>canvas：用于绘制图像</li>
<li>dialog：定义一个对话框、确认框或窗口</li>
<li>aside：定义其所处内容之外的内容。<aside> 的内容可用作文章的侧栏。</aside></li>
<li>section：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</li>
<li>figure：规定独立的流内容（图像、图表、照片、代码等等）。figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响。</li>
<li>details：描述文档或者文档某一部分细节</li>
<li>mark：义带有记号的文本。</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/面试基础/">面试基础</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/浏览器缓存/" title="浏览器缓存机制" itemprop="url">浏览器缓存机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T02:35:23.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/浏览器缓存机制/">浏览器缓存机制</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/07/15/前端的继承方式/" title="js继承的六种方式" itemprop="url">js继承的六种方式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2019-07-15T02:35:23.000Z" itemprop="datePublished"> Published 2019-07-15</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><hr>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'arzh'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主要精髓所在</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"><span class="comment">// 此时的Child的prototype改为了new Parent（）</span></span><br><span class="line"><span class="comment">// 而new parent()并没有construct属性，所以要重新赋值。</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arzhChild = <span class="keyword">new</span> Child()</span><br><span class="line"></span><br><span class="line">arzhChild.getName() <span class="comment">// 'arzh'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原型链继承的缺点</p>
</blockquote>
<h3 id="2-借用构造函数继承"><a href="#2-借用构造函数继承" class="headerlink" title="2.借用构造函数继承"></a>2.借用构造函数继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">surperType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    surperType.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.color.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>
<p>SuperType在SubType构造函数中，在每个实例中执行，这样每个实例都会有一份SuperType中属性方法的副本，也就实现了继承SuperType；</p>
<p>这种模式的优势就是可以在子类型的构造函数中向超类型构造函数传递参数。</p>
<blockquote>
<p>存在的问题就是，所有的类型都只能使用构造函数模式（因为超类型的原型中定义的方法对于子类型不可见），因此方法都是在构造函数中定义，函数的复用就无从谈起了。</p>
</blockquote>
<h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3.组合继承"></a>3.组合继承</h3><blockquote>
<p>也叫伪经典继承，将原型链和借用的构造函数组合到一起。使用原型链对原型属性和方法的继承，而通过构造函数实现实例属性的继承。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 继承属性</span></span><br><span class="line">	SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">// "red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">// "Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">// 29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">// "red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">// "Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>将SubType的原型指定为SuperType的一个实例，大致步骤和原型链继承类似，只是多了在SubType中借调SuperType的过程。</p>
</li>
<li><p>实例属性定义在构造函数中，而方法则定义在构造函数的新原型中，同时将新原型的constructor指向构造函数。</p>
</li>
<li><p>可以通过instanceof和isPrototypeOf()来识别基于组合继承创建的对象。</p>
</li>
<li><p>避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JS中最常用的继承模式。</p>
</li>
</ul>
<blockquote>
<p>实际上是借用了构造函数，以覆盖的方式，解决了在原型链继承中原型的引用类型属性共享在所有实例中的问题。</p>
</blockquote>
<blockquote>
<p>因为在子类型中借调构造函数(SuperType.call(this))时，会在自己的所有实例中执行一遍SuperType中的代码，由于每个实例this都是不同的，因此SuperType中定义的属性会在每个实例中有一份副本，也就避免了原型链继承中，原型属性共享的问题（覆盖了原型属性）。</p>
</blockquote>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><blockquote>
<p>不自定义类型的情况下，临时创建一个构造函数，借助已有的对象作为临时构造函数的原型，然后在此基础实例化对象，并返回。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span> </span>&#123;&#125;;</span><br><span class="line">    F.protoType = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本质上是object()对传入其中的对象执行了一次浅复制</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"> name: <span class="string">"Nicholas"</span>,</span><br><span class="line"> friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends); <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>原型的引用类型属性会在各实例之间共享。</p>
</li>
<li><p>当只想单纯地让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。</p>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>ES5 通过新增 <code>Object.create()</code>方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，<code>Object.create()</code>与这里的<code>object()</code>。第二个参数与<code>Object.defineProperties()</code>方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。</p>
<h2 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h2><blockquote>
<p>其实就是在原型式继承得到对象的基础上，在内部再以某种方式来增强对象，然后返回。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> clone = object(original);</span><br><span class="line">	clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">"hi"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路与寄生构造函数和工厂模式类似。</p>
</li>
<li><p>新的对象中不仅具有original的所有属性和方法，而且还有自己的sayHi()方法。</p>
</li>
<li><p>寄生式继承在主要考虑对象而不是自定义类型和构造函数的情况下非常有用。</p>
</li>
<li><p>由于寄生式继承为对象添加函数不能做到函数复用，因此效率降低。</p>
</li>
</ul>
<h2 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6.寄生组合式继承"></a>6.寄生组合式继承</h2><blockquote>
<p>组合继承是JS中最常用的继承模式，但其实它也有不足，组合继承无论什么情况下都会调用两次超类型的构造函数，并且创建的每个实例中都要屏蔽超类型对象的所有实例属性。</p>
</blockquote>
<p>寄生组合式继承就解决了上述问题，被认为是最理想的继承范式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">superType, subType</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> prototype = object(superType.prototype);</span><br><span class="line">	prototype.constructor = subType;</span><br><span class="line">	subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">	SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SuperType, SubType);	<span class="comment">// 这一句，替代了组合继承中的SubType.prototype = new SuperType()</span></span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>既然在组合模式中我们通过借调构造函数来为每个实例定义实例属性，从而覆盖原型属性，影响了效率，那么是否可以把原型改变一下呢，不让它作为SuperType的实例，这样就不会有一些无用的原型属性了。</p>
<blockquote>
<p>不必为了指定子类型的原型而调用超类型的构造函数，我们需要的只不过是超类型原型的一个副本。</p>
</blockquote>
<ul>
<li><p>在inheritPrototype函数中用到了原型式继承中的object()方法，将超类型的原型指定为一个临时的空构造函数的原型，并返回构造函数的实例。</p>
</li>
<li><p>此时由于构造函数内部为空（不像SuperType里面有实例属性），所以返回的实例也不会自带实例属性，这很重要！因为后面用它作为SubType的原型时，就不会产生无用的原型属性了，借调构造函数也就不用进行所谓的“重写”了。</p>
</li>
<li><p>然后为这个对象重新指定constructor为SubType，并将其赋值给SubType的原型。这样，就达到了将超类型构造函数的实例作为子类型原型的目的，同时没有一些从SuperType继承过来的无用原型属性。</p>
</li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/js继承的六种方式/">js继承的六种方式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/07/01/正则表达式/" title="正则表达式" itemprop="url">正则表达式</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-06-30T16:34:42.000Z" itemprop="datePublished"> Published 2018-07-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>每次遇到正则的时候都会百度去查找，浪费了很多时间后总是下决心要把正则学会，可是下决心时下决心，做起来又很难，这次下了狠心决定来认认真真学习一下正则</p>
<h3 id="新建正则表达式"><a href="#新建正则表达式" class="headerlink" title="新建正则表达式"></a>新建正则表达式</h3><p>方式一：直接量语法</p>
<p>var reg = /pattern/attributes</p>
<p>方式二：创建RegExp对象语法</p>
<p> var reg = new RegExp(pattern, attributes);</p>
<p>参数说明：</p>
<p>参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。</p>
<p>参数 attributes 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。</p>
<p>两者区别在于：<br>1.采用直接量语法新建的正则表达式对象在代码编译时就会生成，式采用开发常用的方式；<br>2.采用正则构造函数生成的正则对象要在代码运行时生成</p>
<p>正则表达式用于：</p>
<p>正则对象的方法是指这样使用的： RegExp对象.方法(字符串) </p>
<p>字符串对象的方法是这样使用：字符串.方法(RegExp对象)</p>
<h2 id="正则表达式的属性和方法"><a href="#正则表达式的属性和方法" class="headerlink" title="正则表达式的属性和方法"></a>正则表达式的属性和方法</h2><p>属性</p>
<p>gnoreCase 返回布尔值，表示RegExp 对象是否具有标志 i<br>global 返回布尔值，表示RegExp对象是否具有标志g<br>multiline 返回布尔值，表示RegExp 对象是否具有标志 m<br>lastIndex 一个整数，标识开始下一次匹配的字符位置<br>source 返回正则表达式的源文本（不包括反斜杠）</p>
<p>i 执行对大小写不敏感的匹配</p>
<p>g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</p>
<p>m 执行多行匹配</p>
<p>正则表达时的作用</p>
<p>通常作用于两种任务：</p>
<p>1.验证</p>
<p>用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串；</p>
<p>2.搜索替换<br>搜索/替换时是否加上此限定则根据搜索的需求而定，此外，也有可能要在前后加上\b而不是^和$</p>
<p>字符类匹配</p>
<p>[…] 查找方括号之间的任何字符<br>[^…] 查找任何不在方括号之间的字符<br>[a-z] 查找任何从小写 a 到小写 z 的字符<br>[A-Z] 查找任何从大写 A 到大写 Z 的字符<br>[A-z] 查找任何从大写 A 到小写 z 的字符<br>. 查找单个字符，除了换行和行结束符<br>\w 查找单词字符，等价于[a-zA-Z0-9]<br>\W 查找非单词字符，等价于[^a-zA-Z0-9]<br>\s 查找空白字符<br>\S 查找非空白字符<br>\d 查找数字，等价于[0-9]<br>\D 查找非数字字符，等价于[^0-9]<br>\b 匹配单词边界<br>\r 查找回车<br>\t 查找制表符<br>\0 查找NULL字符<br>\n 查找换行符</p>
<p>重复字符匹配</p>
<p>{n,m} 匹配前一项至少n次，但不能超过m次<br>{n,}  匹配一项n次或更多次<br>{n}   匹配前一项n次<br>n？    匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1}<br>n+ 匹配前一项1次或多次，等价于{1，}<br>n* 匹配前一项0次或多次，等价于{0，}<br>^n 匹配任何开头以n的字符串<br>？= n 匹配任何其后紧接着指定字符串n的字符串<br>？！n 匹配任何其后没有紧接着指定字符串n的字符串</p>
<p>匹配特定数字<br>^[1-9]\d<em>$ 匹配正整数<br>^-[1-9]\d</em>$ 匹配负整数<br>^-?[0-9]\d<em>$ 匹配整数<br>^[1-9]\d</em>|0$ 匹配非负整数（）</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/正则表达式总结/">正则表达式总结</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/28/来谈谈better-scroll/" title="Vue中better-scroll" itemprop="url">Vue中better-scroll</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-05-28T15:53:50.000Z" itemprop="datePublished"> Published 2018-05-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="什么是-better-scroll"><a href="#什么是-better-scroll" class="headerlink" title="什么是 better-scroll"></a>什么是 better-scroll</h2><hr>
<p>better-scroll 是一个移动端滚动的解决方案，它是基于 iscroll 的重写，它和 iscroll 的主要区别在这里。better-scroll 也很强大，不仅可以做普通的滚动列表，还可以做轮播图、picker 等等。</p>
<h3 id="better-scroll的滚动原理"><a href="#better-scroll的滚动原理" class="headerlink" title="better-scroll的滚动原理"></a>better-scroll的滚动原理</h3><p>不少同学可能用过 better-scroll，我收到反馈最多的问题是：</p>
<blockquote>
<p>我的better-scroll初始化了，但是没法滚动</p>
</blockquote>
<p>不能滚动是现象，我们得搞清楚其中的根本原因。在这之前，我们先来看看浏览器的滚动原理</p>
<p>浏览器的滚动条大家都会遇到，当页面内容的高度超过视口高度的时候，会出现纵项滚动条；当页面内容的高度超过视<br>口宽度的时候，回出现横向滚动条，也就是当我们的视口展示不下内容的时候，回通过滚动条的方式让用户滚动屏幕看到剩余的内容。</p>
<p>那么对于better-scroll也是一样的道理，我们先来看一下better-scroll常见的html结构</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span> <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span>          <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span> ... </span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>绿色部分为 wrapper，也就是父容器，它会有固定的高度。黄色部分为 content，它是父容器的第一个子元素，它的高度会随着内容的大小而撑高。那么，当 content 的高度不超过父容器的高度，是不能滚动的，而它一旦超过了父容器的高度，我们就可以滚动内容区了，这就是 better-scroll 的滚动原理。</p>
<p>那么，我们怎么初始化 better-scroll 呢，如果是上述 html 结构，那么初始化代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BScroll <span class="keyword">from</span> <span class="string">'better-scroll'</span> <span class="keyword">let</span> wrapper = <span class="built_in">document</span>.querySelector(<span class="string">'.wrapper'</span>)<span class="keyword">let</span> scroll = <span class="keyword">new</span> BScroll(wrapper, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>better-scroll 对外暴露了一个 BScroll 的类，我们初始化只需要 new 一个类的实例即可。第一个参数就是我们 wrapper 的 DOM 对象，第二个是一些配置参数，具体参考 better-scroll 的文档。</p>
<p>better-scroll的初始化时机很重要，因为它在初始化的时候，回计算氟元素和子元素的高度和宽度，来决定是否可以纵向或者横向滚动。因此，我们在初始化的时候，必须确保父元素和子元素已经正确渲染了。如果子元素或者父元素DOM结构发生改变，必须用scroll.refresh()方法重新计算来确保滚动效果正常。所以同学们反馈的better-scroll不能滚动的问题多半是因为初始化的时机不对，或者是当DOM结构发生变化的时候并没有重新计算beter-scroll。</p>
<h2 id="better-scroll遇见Vue"><a href="#better-scroll遇见Vue" class="headerlink" title="better-scroll遇见Vue"></a>better-scroll遇见Vue</h2><p>相信很多同学对 Vue.js 都不陌生，当 better-scroll 遇见 Vue，会擦出怎样的火花呢？</p>
<h3 id="如何在-Vue-中使用-better-scroll"><a href="#如何在-Vue-中使用-better-scroll" class="headerlink" title="如何在 Vue 中使用 better-scroll"></a>如何在 Vue 中使用 better-scroll</h3><p>很多同学开始接触使用 better-scroll 都是受到了我的一门教学课程——《Vue.js高仿饿了么外卖App》 的影响。在那门课程中，我们把 better-scroll 和 Vue 做了结合，实现了很多列表滚动的效果。在 Vue 中的使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt; </span><br><span class="line">    &lt;div class=&quot;wrapper&quot; ref=&quot;wrapper&quot;&gt; </span><br><span class="line">        &lt;ul class=&quot;content&quot;&gt; </span><br><span class="line">            &lt;li&gt;...&lt;/li&gt; </span><br><span class="line">            &lt;li&gt;...&lt;/li&gt;</span><br><span class="line">             ... </span><br><span class="line">        &lt;/ul&gt; </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/template&gt; </span><br><span class="line">&lt;script&gt; </span><br><span class="line">import BScroll from &apos;better-scroll&apos; </span><br><span class="line">    export default &#123; </span><br><span class="line">        mounted() &#123; </span><br><span class="line">            this.$nextTick(() =&gt; &#123; this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;) </span><br><span class="line">                &#125;) </span><br><span class="line">               &#125; </span><br><span class="line">            &#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>Vue.js提供了我们一个获取DOM对象的接口–vm.refs。在这里，我们通过<code>this.$refs.wrapper</code>访问到这个DOM对象，并且我们在mounted这个钩子函数里，<code>this.$nextTick</code>的回掉函数里初始化better-scroll。因为这个时候，wrapper的DOM已经渲染了，我们可以正确计算它以及它内层contend的高度，1⃣以确保可以正常滚动。</p>
<p>这里的 <code>this.$nextTick</code> 是一个异步函数，为了确保 DOM 已经渲染，感兴趣的同学可以了解一下它的内部实现细节，底层用到了 MutationObserver 或者是 <code>setTimeout(fn, 0)</code>。其实我们在这里把 <code>this.$nextTick</code> 替换成 <code>setTimeout(fn, 20)</code> 也是可以的（20 ms 是一个经验值，每一个 Tick 约为 17 ms），对用户体验而言都是无感知的。</p>
<h3 id="异步数据的处理"><a href="#异步数据的处理" class="headerlink" title="异步数据的处理"></a>异步数据的处理</h3><p>在我们的实际工作中，列表的数据往往都是异步获取的，因此我们初始化 better-scroll 的时机需要在数据获取后，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">created() &#123; </span><br><span class="line">    requestData().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123; <span class="keyword">this</span>.data = res.data <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">this</span>.scroll = <span class="keyword">new</span> Bscroll(<span class="keyword">this</span>.$refs.wrapper, &#123;&#125;) </span><br><span class="line">        &#125;) </span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的 requestData 是伪代码，作用就是发起一个 http 请求从服务端获取数据，并且这个函数返回的是一个 promise（实际项目中我们可能会用 axios 或者 vue-resource）。我们获取到数据的后，需要通过异步的方式再去初始化 better-scroll，因为 Vue 是数据驱动的， Vue 数据发生变化（this.data = res.data）到页面重新渲染是一个异步的过程，我们的初始化时机是要在 DOM 重新渲染后，所以这里用到了 this.$nextTick，当然替换成 setTimeout(fn, 20) 也是可以的。</p>
<p>为什么这里在 created 这个钩子函数里请求数据而不是放到 mounted 的钩子函数里？因为 requestData 是发送一个网络请求，这是一个异步过程，当拿到响应数据的时候，Vue 的 DOM 早就已经渲染好了，但是数据改变 —&gt; DOM 重新渲染仍然是一个异步过程，所以即使在我们拿到数据后，也要异步初始化 better-scroll。</p>
<h3 id="数据的动态更新"><a href="#数据的动态更新" class="headerlink" title="数据的动态更新"></a>数据的动态更新</h3><p>我们在实际开发中，除了数据异步获取，还有一些场景可以动态更新列表中的数据，比如常见的下拉加载，上拉刷新等。比如我们用better-scroll配合Vue实现的下拉加载的功能，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;wrapper&quot; ref=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;content&quot;&gt;</span><br><span class="line">      &lt;li v-for=&quot;item in data&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;div class=&quot;loading-wrapper&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import BScroll from &apos;better-scroll&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        data: []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      this.loadData()</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      loadData() &#123;</span><br><span class="line">        requestData().then((res) =&gt; &#123;</span><br><span class="line">          this.data = res.data.concat(this.data)</span><br><span class="line">          this.$nextTick(() =&gt; &#123;</span><br><span class="line">            if (!this.scroll) &#123;</span><br><span class="line">              this.scroll = new Bscroll(this.$refs.wrapper, &#123;&#125;)</span><br><span class="line">              this.scroll.on(&apos;touchend&apos;, (pos) =&gt; &#123;</span><br><span class="line">                // 下拉动作</span><br><span class="line">                if (pos.y &gt; 50) &#123;</span><br><span class="line">                  this.loadData()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              this.scroll.refresh()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>这段代码比之前稍微复杂一些, 当我们在滑动列表松开手指时候， better-scroll 会对外派发一个 touchend 事件，我们监听了这个事件，并且判断了 pos.y &gt; 50（我们把这个行为定义成一次下拉的动作）。如果是下拉的话我们会重新请求数据，并且把新的数据和之前的 data 做一次 concat，也就更新了列表的数据，那么数据的改变就会映射到 DOM 的变化。需要注意的一点，这里我们对 this.scroll 做了判断，如果没有初始化过我们会通过 new BScroll 初始化，并且绑定一些事件，否则我们会调用 this.scroll.refresh 方法重新计算，来确保滚动效果的正常。</p>
<h3 id="scroll组件的抽象和封装"><a href="#scroll组件的抽象和封装" class="headerlink" title="scroll组件的抽象和封装"></a>scroll组件的抽象和封装</h3><p>因此，我们有强烈的需求抽象一个scroll组件，类似小程序scroll-view组件，方便开发者使用</p>
<p>这里我们用到了 Vue 的特殊元素—— slot 插槽，它可以满足我们灵活定制列表 DOM 结构的需求。接下来我们来看看 JS 部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div ref=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/ecmascript-6&quot;&gt;</span><br><span class="line">  import BScroll from &apos;better-scroll&apos;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      probeType: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 1</span><br><span class="line">      &#125;,</span><br><span class="line">      click: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: true</span><br><span class="line">      &#125;,</span><br><span class="line">      listenScroll: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;,</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default: null</span><br><span class="line">      &#125;,</span><br><span class="line">      pullup: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;,</span><br><span class="line">      beforeScroll: &#123;</span><br><span class="line">        type: Boolean,</span><br><span class="line">        default: false</span><br><span class="line">      &#125;,</span><br><span class="line">      refreshDelay: &#123;</span><br><span class="line">        type: Number,</span><br><span class="line">        default: 20</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        this._initScroll()</span><br><span class="line">      &#125;, 20)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      _initScroll() &#123;</span><br><span class="line">        if (!this.$refs.wrapper) &#123;</span><br><span class="line">          return</span><br><span class="line">        &#125;</span><br><span class="line">        this.scroll = new BScroll(this.$refs.wrapper, &#123;</span><br><span class="line">          probeType: this.probeType,</span><br><span class="line">          click: this.click</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        if (this.listenScroll) &#123;</span><br><span class="line">          let me = this</span><br><span class="line">          this.scroll.on(&apos;scroll&apos;, (pos) =&gt; &#123;</span><br><span class="line">            me.$emit(&apos;scroll&apos;, pos)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.pullup) &#123;</span><br><span class="line">          this.scroll.on(&apos;scrollEnd&apos;, () =&gt; &#123;</span><br><span class="line">            if (this.scroll.y &lt;= (this.scroll.maxScrollY + 50)) &#123;</span><br><span class="line">              this.$emit(&apos;scrollToEnd&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.beforeScroll) &#123;</span><br><span class="line">          this.scroll.on(&apos;beforeScrollStart&apos;, () =&gt; &#123;</span><br><span class="line">            this.$emit(&apos;beforeScroll&apos;)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      disable() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.disable()</span><br><span class="line">      &#125;,</span><br><span class="line">      enable() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.enable()</span><br><span class="line">      &#125;,</span><br><span class="line">      refresh() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.refresh()</span><br><span class="line">      &#125;,</span><br><span class="line">      scrollTo() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.scrollTo.apply(this.scroll, arguments)</span><br><span class="line">      &#125;,</span><br><span class="line">      scrollToElement() &#123;</span><br><span class="line">        this.scroll &amp;&amp; this.scroll.scrollToElement.apply(this.scroll, arguments)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">          this.refresh()</span><br><span class="line">        &#125;, this.refreshDelay)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;stylus&quot; rel=&quot;stylesheet/stylus&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>可以很明显的看到我们的 JS 部分精简了非常多的代码，没有对 better-scroll 再做命令式的操作了，同时把数据请求和 better-scroll 也做了剥离，父组件只需要把数据 data 通过 prop 传给 scroll 组件，就可以保证 scroll 组件的滚动效果。同时，如果想实现下拉刷新的功能，只需要通过 prop 把 pulldown 设置为 true，并且监听 pulldown 的事件去做一些数据获取并更新的动作即可，整个逻辑也是非常清晰的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Vue中better-scroll/">Vue中better-scroll</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/01/28/几种移动端很常用的布局/" title="几种移动端很常用的布局" itemprop="url">几种移动端很常用的布局</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="xxinso" target="_blank" itemprop="author">xxinso</a>
		
  <p class="article-time">
    <time datetime="2018-01-28T11:13:08.000Z" itemprop="datePublished"> Published 2018-01-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="左边定宽右边自适应布局"><a href="#左边定宽右边自适应布局" class="headerlink" title="左边定宽右边自适应布局"></a>左边定宽右边自适应布局</h2><hr>
<p>html代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 左边定宽 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">aside</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 右边自适应 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>方法一：左边设置左浮动，右边宽度设置100%</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;<span class="attribute">width</span>:<span class="number">100%</span>&#125;</span><br></pre></td></tr></table></figure>
<p>方法二： 父容器设置 display：flex；Right部分设置 flex：1 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    display:flex</span><br><span class="line">&#125;</span><br><span class="line">.right:&#123;</span><br><span class="line">    flex:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法三: 设置浮动+在css中使用calc（）函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.left&#123;</span><br><span class="line">    float:left</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    float:left;</span><br><span class="line">    width:calc(<span class="number">100</span>%<span class="number">-200</span>px)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【分析】</p>
<ol>
<li><p>浮动。（注意：为了不影响其他元素，别忘了在父级上清除浮动）</p>
</li>
<li><p>calc() = calc(四则运算) 用于在 css 中动态计算长度值，需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</p>
</li>
</ol>
<p>方法四：使用负margin</p>
<p>首先修改页面结构，为自适应部分添加容器 .container, 同时改变左右部分的位置，如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        right</span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>:&#123;</span><br><span class="line">    <span class="attribute">margin-left</span>:<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>:left;</span><br><span class="line">    <span class="attribute">margin-left</span>:-<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子元素根据父元素的宽度来实现子元素的在元素中居中"><a href="#子元素根据父元素的宽度来实现子元素的在元素中居中" class="headerlink" title="子元素根据父元素的宽度来实现子元素的在元素中居中"></a>子元素根据父元素的宽度来实现子元素的在元素中居中</h2><hr>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'father'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'son'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span>&#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">       <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">       <span class="attribute">background</span>: yellow;</span><br><span class="line">       <span class="attribute">display</span>: flex;</span><br><span class="line">       <span class="attribute">justify-content</span>: center;</span><br><span class="line">       <span class="attribute">align-items</span>:center;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-class">.son</span>&#123;</span><br><span class="line">       <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">padding-bottom</span>: <span class="number">50%</span>;</span><br><span class="line">       <span class="attribute">background</span>: red;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>【分析】</p>
<p> 先对子元素用flex实现上下和左右居中，有父元素的宽度来确定子元素正方形的宽度，宽高都是父元素的二分之一。</p>
<h2 id="几种子元素在父元素中居中水平垂直居中的方式"><a href="#几种子元素在父元素中居中水平垂直居中的方式" class="headerlink" title="几种子元素在父元素中居中水平垂直居中的方式"></a>几种子元素在父元素中居中水平垂直居中的方式</h2><ol>
<li>子元素相对于父元素绝对定位，并且margin值减去自己宽高的一半</li>
</ol>
<h2 id="该方法具有一定的局限性，因为其必须要知道子元素本身的宽高"><a href="#该方法具有一定的局限性，因为其必须要知道子元素本身的宽高" class="headerlink" title="该方法具有一定的局限性，因为其必须要知道子元素本身的宽高"></a>该方法具有一定的局限性，因为其必须要知道子元素本身的宽高</h2> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">item</span>&#123;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">            <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>2.子元素相对于父元素绝对定位，并且margin值位auto</p>
<p>该方式不受元素宽高所限制，比较好用（推荐使用）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="selector-class">.box</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">          <span class="attribute">position</span>: relative;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-tag">item</span>&#123;</span><br><span class="line">           <span class="attribute">position</span>: absolute;</span><br><span class="line">           <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">           <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">           <span class="attribute">margin</span>: auto;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">           <span class="attribute">background</span>: green;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>3.diplay：table-cell</p>
<p>该方式是将元素转换成表格样式，再利用表格的样式来进行居中（推荐）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line">       <span class="selector-class">.box</span>&#123;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">           <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">           <span class="attribute">display</span>: table-cell;</span><br><span class="line">           <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="selector-tag">item</span>&#123;</span><br><span class="line">           <span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br><span class="line">           <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">           <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">           <span class="attribute">background</span>: green;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>水平垂直居中（四） 绝对定位和transfrom</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">            <span class="attribute">position</span>:relative;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">item</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>5.css3中的flex属性</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;<span class="attribute">margin</span>: <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="selector-class">.box</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">            <span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br><span class="line">            <span class="attribute">display</span>: flex;</span><br><span class="line">            <span class="attribute">justify-content</span>: center;</span><br><span class="line">            <span class="attribute">align-items</span>: center;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">item</span>&#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100</span>x;</span><br><span class="line">            <span class="attribute">background</span>: green;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/几种移动端很常用的布局/">几种移动端很常用的布局</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/面试基础/" title="面试基础">面试基础<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/几种移动端很常用的布局/" title="几种移动端很常用的布局">几种移动端很常用的布局<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/优化前端资源加载-1-图片加载优化和代码压缩/" title="优化前端资源加载 1 - 图片加载优化和代码压缩">优化前端资源加载 1 - 图片加载优化和代码压缩<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/使用Plugin/" title="使用Plugin">使用Plugin<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/用HRM提高开发效率/" title="用HRM提高开发效率">用HRM提高开发效率<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/优化前端资源加载-3-进一步控制-JS-大小/" title="优化前端资源加载 3 - 进一步控制 JS 大小">优化前端资源加载 3 - 进一步控制 JS 大小<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/更好的使用webpack-dev-server/" title="更好的使用webpack-dev-server">更好的使用webpack-dev-server<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/创建自己的loader/" title="创建自己的loader">创建自己的loader<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/优化前端资源加载-2-分离代码文件/" title="优化前端资源加载 2 - 分离代码文件">优化前端资源加载 2 - 分离代码文件<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/js继承的六种方式/" title="js继承的六种方式">js继承的六种方式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/浏览器缓存机制/" title="浏览器缓存机制">浏览器缓存机制<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack搭建前端基本环境/" title="webpack搭建前端基本环境">webpack搭建前端基本环境<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/正则表达式总结/" title="正则表达式总结">正则表达式总结<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack-如何解析模块代码路径/" title="webpack 如何解析模块代码路径">webpack 如何解析模块代码路径<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/EventLoop/" title="EventLoop">EventLoop<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/webpack的使用方法/" title="webpack的使用方法">webpack的使用方法<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/开发和生产环境的构建配置差异/" title="开发和生产环境的构建配置差异">开发和生产环境的构建配置差异<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/内部工作流程/" title="内部工作流程">内部工作流程<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/提升webpack的构建速度/" title="提升webpack的构建速度">提升webpack的构建速度<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/配置loader/" title="配置loader">配置loader<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2019 
		
		<a href="/about" target="_blank" title="xxinso">xxinso</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
